<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>הבלגן האולימפי - קווסט האלים</title>
    <!-- טעינת Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* הגדרות כלליות וגופן */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #064e3b 100%); /* רקע אולימפוס */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .game-container {
            max-width: 600px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            text-align: center;
            direction: rtl;
        }
        .quest-title {
            color: #b91c1c; 
            font-size: 1.875rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        .quest-description {
            color: #1f2937;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }
        /* סגנון כפתורי פעולה */
        .action-btn {
            background-color: #059669;
            color: white;
            border-radius: 9999px;
            padding: 0.75rem 2rem;
            font-size: 1.125rem;
            transition: all 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .action-btn:hover {
            background-color: #047857;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        }
        /* סגנון קנבס */
        #gameCanvas {
            border: 4px solid #1f2937;
            background-color: #e5e7eb;
            touch-action: none; /* למניעת גלילה במסך מגע */
        }
        /* סגנון כפתורי שליטה במגע (למובייל) */
        .touch-controls button {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
            transition: background-color 0.1s;
        }
        .touch-controls button:active {
            background-color: #1d4ed8;
        }
        /* סגנון סרגל סטטוס ספציפי להפיסטוס */
        .hephaestus-status {
            padding: 0.5rem;
            margin-top: 1rem;
            border-radius: 8px;
            background-color: #fef3c7; /* צהוב בהיר */
            border: 1px solid #fcd34d;
            font-size: 0.875rem;
            text-align: right;
        }
    </style>
</head>
<body>

    <div id="game-app" class="game-container">
        <!-- תוכן המשחק ייטען לכאן -->
    </div>

    <script>
        // --- מנגנון גלובלי לטיפול בשגיאות קריטיות ---
        window.addEventListener('error', function(e) {
            const appElement = document.getElementById('game-app');
            if (appElement) {
                // הצגת הודעת שגיאה ויזואלית על המסך
                appElement.innerHTML = `
                    <div style="color: #991b1b; padding: 20px; text-align: center; background-color: #fee2e2; border: 2px solid #ef4444; border-radius: 8px;">
                        <h1 style="font-size: 24px; font-weight: bold;">שגיאת טעינה קריטית! 🚨</h1>
                        <p>המשחק נכשל בטעינה. אנא דווח על השגיאה הבאה:</p>
                        <p style="font-family: monospace; background: #fecaca; padding: 10px; border-radius: 4px; margin-top: 10px; overflow-wrap: break-word; color: #7f1d1d;">
                            ${e.message}
                        </p>
                        <p style="margin-top: 10px;">בדוק את קונסולת המפתחים (F12) לפרטים נוספים.</p>
                    </div>
                `;
            }
            // מונע את הטיפול המובנה של הדפדפן בשגיאה
            e.preventDefault(); 
        });

        // הגדרות בסיסיות
        const app = document.getElementById('game-app');
        let gameState = {
            currentQuest: 0,
            score: 0,
            inProgress: false,
        };

        // --- משתני קנבס גלובליים ---
        let canvas = null, ctx = null; // אתחול כ-null למניעת שגיאות מוקדמות
        let canvasState = {}; // מצב המשחק הנוכחי
        let keys = {}; // מעקב אחר מקשים לחוצים
        let gameLoopId = null; // מזהה לולאת המשחק

        // משתני עזר לניקוי מאזיני עכבר ומגע
        let mouseHandlersAdded = false;

        // --- הגדרות קווסטים ---
        const quests = [
            {
                id: 1,
                name: "זאוס: מרוץ הברקים",
                god: "זאוס",
                icon: "⚡🏃",
                description: "זאוס, תוך כדי ניסיון לשפר את יכולותיו ברשתות חברתיות, התעצבן מטרול ושלח סטורם זעם דיגיטלי. הברקים יצאו משליטה! עליך לנווט במהירות בין הברקים הפראיים כדי לנקז את האנרגיה העודפת ולייצב את שמי האולימפוס לפני שהכול יישרף. קושי גבוה! עליך להתחמק מ-15 ברקים! מותרות רק 2 פגיעות. קצב הברקים גדל במהירות.",
                type: "canvas_game",
                gameName: "zeus_dodge",
                target: 15 
            },
            {
                id: 2,
                name: "האדס: איסוף נשמות על סירת סטיקס",
                god: "האדס",
                icon: "👻🛶",
                description: "האדס ערך טורניר פוקר לילי והפסיד בהתערבות את סדר מיון הנשמות. כתוצאה מכך, גיבורים אגדיים (שצריכים ללכת לשדות אליסיום) נכנסים בטעות למסלול של הנשמות הרעות (הגולגלות האדומות). עליך לשלוט בסירה ולהחזיר את נשמות הגיבורים (עיגולים ירוקים) למסלול הנכון, תוך הימנעות מהגולגלות הזועמות! קושי גבוה! אסוף 8 נשמות טובות. הסיכוי להיתקל בגולגלות רעות הוא 50/50. האובייקטים נעים מהר יותר.",
                type: "canvas_game",
                gameName: "hades_collect",
                target: 8 
            },
            {
                id: 3,
                name: "ארטמיס: אתגר ירי החצים",
                god: "ארטמיס",
                icon: "🏹🎯",
                description: "ארטמיס ערכה תחרות קליעה כושלת עם אפולו והשתמשה ביהלומי כוח כמטרות נעות. כמובן שהם פספסו הכל והיהלומים התפזרו בשדה מטאורים מסוכן. עליך לנוע במהירות כדי לאסוף את כל 12 היהלומים לפני שהם מאבדים את האנרגיה שלהם, או שאפולו יכריז על ניצחון מטופש! קושי גבוה! אסוף 12 יהלומים נוצצים בתוך 15 שניות בלבד. הדמות מעט קטנה יותר.",
                type: "canvas_game",
                gameName: "artemis_fetch",
                target: 12 
            },
             {
                id: 4,
                name: "הרמס: בריחה מרשת הלייזר",
                god: "הרמס",
                icon: "🚀⚡",
                description: "הרמס גנב מכונה לבניית שבילים מיידיים מהפיסטוס והפעיל אותה בטעות על מצב 'אבטחה עוינת'. המכונה מזהה אותך כפולש ומפעילה גדרות לייזר אנרגטיות יורדות! **הרמס הפעיל בך קמע מהירות קבוע, כך שאתה מהיר במיוחד לאורך כל המשימה! כל גדר לייזר מכילה שני פערים שדרכם ניתן לעבור.** עליך לנווט במהירות דרך הפערים הצפופים ולהתחמק מ-15 גדרות לייזר כדי להשבית את המכונה. מותרות רק 3 פגיעות! קצב הגדרות הלייזר גדל במהירות.",
                type: "canvas_game",
                gameName: "hermes_avoidance",
                target: 15 
            },
            {
                id: 5,
                name: "אפרודיטה: ניקוי הבלגן הרומנטי",
                god: "אפרודיטה",
                icon: "💖🌹",
                description: "אפרודיטה ניסתה להכין שיקוי אהבה רב עוצמה, אבל נרדמה והחומרים התפזרו ברוח. עליך לנווט במהירות ולאסוף 15 מרכיבים: 8 לבבות ו-7 פרחים. אתה יכול לאסוף רק סוג אחד בכל פעם, והחלפה בין סוגי האיסוף (מקש רווח) לוקחת שנייה יקרה! סיים ב-20 שניות. קושי: גבוה מאוד.",
                type: "canvas_game",
                gameName: "aphrodite_clean",
                target: 15 
            },
            {
                id: 6,
                name: "פוסידון: נחשולי האצות הזועמים",
                god: "פוסידון",
                icon: "🌊🔱",
                description: "פוסידון רב עם דייג על טעם כריך טונה, ושלח צונאמי של אצות שסותם את כל נתיבי הים. עליך לנווט אנכית (למעלה/למטה) במעבר ימי צר כדי להימנע מ-20 גושים של אצות וסלעים שבאים במהירות לרוחב! זהירות: אתה זז רק למעלה ולמטה!",
                type: "canvas_game",
                gameName: "poseidon_dodge",
                target: 20 
            },
             {
                id: 7,
                name: "דיוניסוס: מרתון הברמנים הקוסמי",
                god: "דיוניסוס",
                icon: "🍷⚔️",
                description: "דיוניסוס נטש את היין המסורתי והמציא קוקטייל 'מוחיטו-יווני'. עליך לבשל 3 קוקטיילים ב-25 שניות! אסוף את שלושת המרכיבים (🍇, ☁️, ⚡) וגש למיכל הערבוב (המלבן המרכזי). **חובה לעמוד במיכל למשך 2 שניות** כדי לסיים את הערבוב. **זהירות: האל ארס כועס על השטות ותוקף אותך עם חרבות!** פגיעה מחרב מאפסת את המלאי שלך ומבטלת את הערבוב.",
                type: "canvas_game",
                gameName: "dionysus_cocktail",
                target: 3 
            },
            {
                id: 8,
                name: "הפיסטוס: הרכבת הרובוט המנצח",
                god: "הפיסטוס",
                icon: "⚙️🛠️",
                description: "הפיסטוס שכח את תחרות בניית הרובוטים! עליך להרכיב רובוט מ-4 חלקים: גוף, גלגלים, זרועות וראש. לאחר ההרכבה, הרובוט יצטרך לעבור 3 מכשולים. **זהירות: החיבור הלא נכון יגרום לכשל!** (למשל, גלגלי שטח במירוץ מהירות). הרכב את הרובוט תוך 20 שניות. גרור את החלקים לעיגולים במרכז.",
                type: "canvas_game",
                gameName: "hephaestus_build",
                target: 3 // מספר המכשולים שהרובוט צריך לעבור
            }
        ];

        // --- פונקציות עזר כלליות ---

        // פונקציה להסרת מאזיני העכבר/מגע
        function removeMouseListeners() {
            if (!canvas || !mouseHandlersAdded) return;
            // הוסר: canvas.removeEventListener('mousedown', handleMouseDownHephaestus);
            // הוסר: canvas.removeEventListener('mousemove', handleMouseMoveHephaestus);
            // הוסר: canvas.removeEventListener('mouseup', handleMouseUpHephaestus);
            // הוסר: canvas.removeEventListener('touchstart', handleMouseDownHephaestus);
            // הוסר: canvas.removeEventListener('touchmove', handleMouseMoveHephaestus);
            // הוסר: canvas.removeEventListener('touchend', handleMouseUpHephaestus);
            mouseHandlersAdded = false;
        }

        function renderScreen(htmlContent) {
            // ביטול לולאת משחק קודמת לפני רינדור מסך חדש
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            // הסרת מאזינים קודמים למקשים ולעכבר
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            removeMouseListeners(); // הסרת מאזיני ה-DND אם היו

            app.innerHTML = htmlContent;
        }

        function createActionButton(text, onClick) {
            return `
                <button onclick="${onClick}"
                    class="action-btn mt-6 w-full md:w-auto shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-300">
                    ${text}
                </button>
            `;
        }

        // --- לוגיקת משחק מרכזית ---

        function renderIntro() {
            gameState.inProgress = false;
            const content = `
                <div class="space-y-6">
                    <h1 class="text-4xl font-bold text-gray-800">ברוכים הבאים ל<span class="text-red-600">הבלגן האולימפי</span></h1>
                    <p class="text-lg text-gray-600">
                        אלי האולימפוס יצרו שיבושים. עליך לשלוט בגיבור באמצעות **מיני-משחקים דינמיים** כדי לתקן את הנזק!
                    </p>
                    <div class="text-xl font-semibold text-blue-700">
                        מטרתך: השלם את כל ${quests.length} הקווסטים המאתגרים!
                    </div>
                    ${createActionButton("התחל מסע", "startQuest()")}
                </div>
            `;
            renderScreen(content);
        }

        function startQuest() {
            gameState.currentQuest = 1;
            gameState.score = 0;
            gameState.inProgress = true;
            renderQuest();
        }

        function renderCompletionScreen() {
            const content = `
                <div class="space-y-6">
                    <h1 class="text-5xl font-extrabold text-green-600">🎉 כל הכבוד! הקווסט הושלם! 🎉</h1>
                    <p class="text-2xl text-gray-700">
                        הצלחת לתקן את כל ${quests.length} השיבושים הקוסמיים!
                    </p>
                    <div class="text-2xl text-red-600 font-bold">
                        ניקוד סופי: ${gameState.score}
                    </div>
                    ${createActionButton("שחק שוב", "renderIntro()")}
                </div>
            `;
            renderScreen(content);
        }

        function handleQuestResult(isCorrect, message, points = 100) {
            // עצירת לולאת המשחק הספציפית
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            // הסרת כל המאזינים לפני הצגת תוצאה
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            removeMouseListeners();
            
            let resultHtml;
            if (isCorrect) {
                gameState.score += points;
                resultHtml = `
                    <div class="p-4 bg-green-100 border-r-4 border-green-500 text-green-800 mt-6 rounded-lg">
                        <p class="font-bold">✨ הצלחה!</p>
                        <p>${message}</p>
                    </div>
                    ${createActionButton("המשך לקווסט הבא", "nextQuest()")}
                `;
            } else {
                resultHtml = `
                    <div class="p-4 bg-red-100 border-r-4 border-red-500 text-red-800 mt-6 rounded-lg">
                        <p class="font-bold">❌ כישלון...</p>
                        <p>${message}</p>
                    </div>
                    ${createActionButton("נסה שוב", "resetCurrentQuest()")}
                `;
            }
            // עדכון אזור התוצאה
            const questArea = app.querySelector('#quest-area');
            if (questArea) {
                questArea.innerHTML = resultHtml;
            } else {
                 app.querySelector('.game-container').innerHTML += resultHtml;
            }
        }

        function nextQuest() {
            gameState.currentQuest++;
            renderQuest();
        }

        function resetCurrentQuest() {
            renderQuest(); // פשוט רינדור מחדש של הקווסט יאתחל את הכל
        }

        function renderQuest() {
            if (gameState.currentQuest > quests.length) {
                renderCompletionScreen();
                return;
            }

            const quest = quests[gameState.currentQuest - 1];
            let questHtml = '';

            // כותרת כללית
            const header = `
                <div class="text-right mb-4 text-sm font-medium text-gray-500">
                    קווסט ${quest.id} מתוך ${quests.length}
                </div>
                <h2 class="quest-title flex items-center justify-center gap-3">
                    <span class="text-3xl">${quest.icon}</span> ${quest.name}
                </h2>
                <p class="quest-description text-gray-700">${quest.description}</p>
                <div class="h-0.5 bg-gray-200 w-full mb-6"></div>
            `;

            if (quest.type === 'canvas_game') {
                questHtml = renderCanvasGame(quest);
                renderScreen(header + questHtml);
                setupGame(quest.gameName); // רק מכין את הקנבס, לא מתחיל את הלולאה
            }
        }

        // --- לוגיקת מיני-משחקי קנבס ---

        function renderCanvasGame(quest) {
            // בקווסט הפיסטוס אין צורך בלחצני מובייל לכן נסתיר אותם
            const showTouchControls = (quest.gameName !== 'hephaestus_build');
            // בקווסט הפיסטוס אנחנו משתמשים בכפתור לבדיקת הרובוט, ולא ככפתור "התחל"
            const showStartButton = (quest.gameName !== 'hephaestus_build');

            // עדכון הוראות שליטה בהתאם לקווסט הפיסטוס
            const controlInstructions = quest.gameName === 'hephaestus_build' ? 
                'השתמשו במקשי החצים (← ↑ → ↓) כדי לנווט. לחצו **רווח** כדי לאסוף/לשחרר חלק רובוט.' : 
                'השתמש במקשי החצים (← ↑ → ↓) כדי לשלוט בדמות. קליק על המקשים למטה עבור מובייל. (מקש רווח לקווסט של אפרודיטה).';

            return `
                <div class="flex flex-col items-center space-y-4">
                    <canvas id="gameCanvas" width="350" height="350" 
                        class="border-4 border-gray-900 bg-gray-100 rounded-lg shadow-inner w-full max-w-sm"></canvas>
                    <div id="game-info" class="text-lg font-bold text-red-600">
                        ${quest.gameName === 'hephaestus_build' ? 'בנה את הרובוט שלך!' : 'לחץ \'התחל קווסט\' כדי להתחיל!'}
                    </div>
                    <div id="quest-area">
                        <button onclick="${quest.gameName === 'hephaestus_build' ? 'checkBuildCompletion()' : `startGameLogic('${quest.gameName}')`}" id="start-game-btn"
                            class="action-btn w-64 h-14 text-xl bg-blue-700 hover:bg-blue-800 focus:ring-blue-300 transition duration-150 transform hover:scale-105"
                            style="display: ${showStartButton ? 'block' : 'none'};">
                            ${showStartButton ? 'התחל קווסט' : 'התחל מירוץ רובוט!'}
                        </button>
                        <p class="text-sm text-gray-500 mt-4">${controlInstructions}</p>
                        <!-- כפתורי שליטה למסכי מגע -->
                        <div class="touch-controls flex justify-center mt-4 space-x-4 ${showTouchControls ? '' : 'hidden'} md:hidden">
                            <button onmousedown="handleTouchMove(0)" ontouchstart="handleTouchMove(0)" ontouchend="handleTouchStop()">←</button>
                            <div class="flex flex-col space-y-2">
                                <button onmousedown="handleTouchMove(1)" ontouchstart="handleTouchMove(1)" ontouchend="handleTouchStop()">↑</button>
                                <button onmousedown="handleTouchMove(3)" ontouchstart="handleTouchMove(3)" ontouchend="handleTouchStop()">↓</button>
                            </div>
                            <button onmousedown="handleTouchMove(2)" ontouchstart="handleTouchMove(2)" ontouchend="handleTouchStop()">→</button>
                            <!-- הוספת כפתור "רווח" למגע לצורך איסוף/שחרור -->
                            <button onmousedown="handleSpacePress()" ontouchstart="handleSpacePress()" ontouchend="handleSpaceRelease()">⚡</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // פונקציות שליטה למסך מגע (לתנועה, לא DND)
        function handleTouchMove(direction) {
            // 0: שמאל, 1: למעלה, 2: ימין, 3: למטה
            keys = { ArrowLeft: false, ArrowUp: false, ArrowRight: false, ArrowDown: false };
            if (direction === 0) keys.ArrowLeft = true;
            if (direction === 1) keys.ArrowUp = true;
            if (direction === 2) keys.ArrowRight = true;
            if (direction === 3) keys.ArrowDown = true;
        }

        function handleTouchStop() {
            keys = {};
        }

        // --- טיפול בלחיצת רווח במגע ---
        function handleSpacePress() {
             keys[' '] = true;
             // עבור קווסט הפיסטוס, הפעלת הלוגיקה באופן מיידי ב-update
             if(gameState.currentQuest === 8) {
                // חייבים לקרוא לעדכון ידני כי אין לולאת משחק ב-BUILD
                // שימו לב: הקוד מתחת מעביר 0 כטיימסטאמפ, זה בסדר כי לוגיקת ה-BUILD לא משתמשת בו
                updateHephaestusBuild(0); 
                keys[' '] = false; // איפוס מיידי לאחר שימוש
             }
        }
        function handleSpaceRelease() {
            // עבור קווסטים כמו אפרודיטה, איפוס המקש יקרה בתוך הלולאה.
             keys[' '] = false; 
        }
        // --- סוף טיפול מגע רווח ---

        function setupGame(gameName) {
            canvas = document.getElementById('gameCanvas');
            // בדיקה קריטית: האם הקנבס נמצא?
            if (!canvas) return; 
            
            ctx = canvas.getContext('2d');
            
            // איפוס מצב מקשים
            keys = {};

            // הסרת והוספת מאזינים
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            
            // אתחול המשחק הספציפי
            switch (gameName) {
                case 'zeus_dodge':
                    initZeusDodge();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hades_collect':
                    initHadesCollect();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'artemis_fetch':
                    initArtemisFetch();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hermes_avoidance': 
                    initHermesAvoidance();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'aphrodite_clean':
                    initAphroditeClean();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'poseidon_dodge':
                    initPoseidonDodge();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'dionysus_cocktail':
                    initDionysusCocktail();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hephaestus_build':
                    initHephaestusBuild();
                    // שינוי: הוספת מאזיני מקשים לשליטה בבנייה
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
            }
            
            // ציור ראשוני של המסך לפני ההתחלה, רק אם פונקציית ציור קיימת
            if (canvasState.draw) canvasState.draw();
        }

        // --- שינוי: startGameLogic נשאר רק למשחקי לולאה ---
        function startGameLogic(gameName) {
            // מכניס את הלוגיקה של התחלת המשחק (שליטה בכפתור)
            const btn = document.getElementById('start-game-btn');
            const info = document.getElementById('game-info');
            
            if (btn) btn.style.display = 'none';
            if (info) info.textContent = 'המשחק בעיצומו!';

            // הגדרת isRunning ל-true והתחלת הלולאה
            canvasState.isRunning = true;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function handleKeyDown(e) {
            // מניעת גלילת העמוד בעת שימוש בחצים
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            keys[e.key] = true;
        }

        function handleKeyUp(e) {
            // עבור קווסט הפיסטוס, לא נאפס כאן את הרווח כדי שהלחיצה תעבוד פעם אחת
            if(e.key === ' ' && gameState.currentQuest === 8) {
                // ניתוק הלחיצה יטופל בתוך ה-updateHephaestusBuild אם צריך
                return; 
            }

            keys[e.key] = false;
        }

        // --- לולאת המשחק הראשית ---
        function gameLoop() {
            if (canvasState.isRunning) {
                // עדכון ולוגיקת משחק
                canvasState.update(performance.now()); // מעביר timestamp
                // ציור
                canvasState.draw();
                // המשך הלולאה
                gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                // המשחק הסתיים (נצחון או הפסד)
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
        }

        // --- עזר: בדיקת התנגשות ריבוע-ריבוע ---
        function checkCollision(r1, r2) {
            // בדיקת התנגשות מלבנים סטנדרטית
            return r1.x < r2.x + r2.w &&
                   r1.x + r1.w > r2.x &&
                   r1.y < r2.y + r2.h &&
                   r1.y + r1.h > r2.y;
        }

        // --- ציור דמות (משותף לזאוס, ארטמיס, אפרודיטה, פוסידון, הרמס, דיוניסוס) ---
        function drawPlayerFigure(player, isBoosted = false) {
            if (!ctx) return; // הגנה
            const centerX = player.x + player.w / 2;
            
            // קביעת צבע הדמות בהתאם למצב החיזוק
            let bodyColor = isBoosted ? '#FFFFFF' : player.color;
            let headColor = isBoosted ? '#FFEA00' : '#FFD700';
            
            // 1. גוף (מלבן שמייצג טוניקה/שריון)
            ctx.fillStyle = bodyColor; 
            ctx.fillRect(player.x + 5, player.y + 10, player.w - 10, player.h - 15);

            // 2. ראש (קסדה מוזהבת)
            ctx.beginPath();
            ctx.arc(centerX, player.y + 7, 7, 0, Math.PI * 2);
            ctx.fillStyle = headColor;
            
            // אפקט זוהר כשהוא מחוזק (לצורך Hermes)
            ctx.shadowColor = isBoosted ? '#FFFFFF' : '#FFD700';
            ctx.shadowBlur = isBoosted ? 15 : 8;
            
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0; // איפוס צל

            // 3. רגליים (קווים פשוטים)
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 5, player.y + player.h - 5);
            ctx.lineTo(centerX - 5, player.y + player.h);
            ctx.moveTo(centerX + 5, player.y + player.h - 5);
            ctx.lineTo(centerX + 5, player.y + player.h);
            ctx.stroke();
        }

        // --- קווסט 1: זאוס - מרוץ הברקים ---
        function initZeusDodge() {
            const quest = quests[0];
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#007bff', speed: 4 }, 
                lightning: [],
                strikesDodged: 0,
                hits: 0,
                maxHits: 2, 
                lastSpawn: 0,
                spawnRate: 500, 
                update: updateZeusDodge,
                draw: drawZeusDodge,
            };
        }

        function updateZeusDodge(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // תנועת שחקן
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // יצירת ברקים
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                canvasState.lightning.push({
                    x: Math.random() * (canvas.width - 20) + 10, 
                    y: -10,
                    w: 8, 
                    h: 35,
                    speed: 4 + Math.random() * 2.5, 
                    color: '#FFEA00' 
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(150, canvasState.spawnRate - 15); 
            }

            // עדכון מיקום ברקים ובדיקת התנגשות
            for (let i = canvasState.lightning.length - 1; i >= 0; i--) {
                const bolt = canvasState.lightning[i];
                bolt.y += bolt.speed;

                if (checkCollision(player, bolt)) {
                    // פגיעה
                    canvasState.hits++;
                    canvasState.lightning.splice(i, 1);
                    if (canvasState.hits >= canvasState.maxHits) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `חטפת ${canvasState.hits} פגיעות! זאוס ממלמל משהו על 'משחק הוגן'. נסה שוב.`);
                        return;
                    }
                } else if (bolt.y > canvas.height) {
                    // ברק יצא מהמסך
                    canvasState.strikesDodged++;
                    canvasState.lightning.splice(i, 1);
                    if (canvasState.strikesDodged >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `התחמקת מ-15 ברקים! זאוס חזר לשלוט במזג האוויר. ניקוד: 200`, 200);
                    }
                }
            }
        }

        function drawZeusDodge() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור ברקים
            canvasState.lightning.forEach(bolt => {
                ctx.fillStyle = bolt.color;
                ctx.fillRect(bolt.x, bolt.y, bolt.w, bolt.h);
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `התחמקות: ${canvasState.strikesDodged} / ${quest.target} | פגיעות: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }

        // --- קווסט 2: האדס - איסוף נשמות ---
        function initHadesCollect() {
            const quest = quests[1];
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 17.5, y: canvas.height - 40, w: 35, h: 18, color: '#3b82f6', speed: 4.5 }, 
                collectibles: [], 
                obstacles: [], 
                soulsCollected: 0,
                badSoulsHit: 0,
                maxBadSouls: 3,
                lastSpawn: 0,
                spawnRate: 650, 
                update: updateHadesCollect,
                draw: drawHadesCollect,
            };
        }

        function updateHadesCollect(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // תנועת שחקן
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;

            // יצירת אובייקטים
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const x = Math.random() * (canvas.width - 20);
                const isCollectible = Math.random() > 0.5; 
                const item = { x, y: -20, r: 10, speed: 2.5 + Math.random() * 2 }; 

                if (isCollectible) {
                    canvasState.collectibles.push({ ...item, w: item.r*2, h: item.r*2, color: '#10b981' }); 
                } else {
                    canvasState.obstacles.push({ ...item, w: item.r*2, h: item.r*2, color: '#ef4444' }); 
                }

                canvasState.lastSpawn = timestamp;
            }

            // עדכון ואיסוף
            for (let i = canvasState.collectibles.length - 1; i >= 0; i--) {
                const item = canvasState.collectibles[i];
                item.y += item.speed;

                // בדיקת איסוף 
                if (checkCollision(player, item)) {
                    canvasState.soulsCollected++;
                    canvasState.collectibles.splice(i, 1);
                    if (canvasState.soulsCollected >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `אספת 8 נשמות טובות! האדס משבח את סדרנותך. ניקוד: 300`, 300);
                        return;
                    }
                } else if (item.y > canvas.height) {
                    canvasState.collectibles.splice(i, 1);
                }
            }

            // עדכון והימנעות
            for (let i = canvasState.obstacles.length - 1; i >= 0; i--) {
                const item = canvasState.obstacles[i];
                item.y += item.speed;

                // בדיקת פגיעה
                 if (checkCollision(player, item)) {
                    canvasState.badSoulsHit++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.badSoulsHit >= canvasState.maxBadSouls) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `פגעת ב-3 גולגלות! סירת סטיקס נשברה. נסה שוב.`);
                        return;
                    }
                } else if (item.y > canvas.height) {
                    canvasState.obstacles.splice(i, 1);
                }
            }
        }

        function drawHadesCollect() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור נשמות טובות (עיגולים ירוקים)
            canvasState.collectibles.forEach(item => {
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
                ctx.fillStyle = item.color;
                ctx.fill();
                ctx.closePath();
            });

            // ציור גולגלות רעות (ריבועים אדומים)
            canvasState.obstacles.forEach(item => {
                ctx.fillStyle = item.color;
                // ציור כריבוע במקום עיגול כדי לייצג גולגולת
                ctx.fillRect(item.x - item.r, item.y - item.r, item.r * 2, item.r * 2);
            });

            // ציור שחקן (סירה) - צורה מעוצבת
            const player = canvasState.player;
            ctx.fillStyle = '#78350f'; // חום כהה (סירת עץ)
            
            // גוף הסירה (טרפז הפוך)
            ctx.beginPath();
            ctx.moveTo(player.x, player.y + player.h); // קצה שמאלי תחתון
            ctx.lineTo(player.x + player.w, player.y + player.h); // קצה ימני תחתון
            ctx.lineTo(player.x + player.w - 5, player.y); // קצה ימני עליון (חרטום)
            ctx.lineTo(player.x + 5, player.y); // קצה שמאלי עליון (חרטום)
            ctx.closePath();
            ctx.fill();

            // פס דקורטיבי כחול (הנהר)
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(player.x + 2, player.y + player.h - 5, player.w - 4, 3);
            
            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `נשמות: ${canvasState.soulsCollected} / ${quest.target} | גולגלות: <span style="color: red">${canvasState.badSoulsHit}</span> / ${canvasState.maxBadSouls}`;
            }
        }

        // --- קווסט 3: ארטמיס - אתגר ירי החצים (איסוף בזמן) ---
        function initArtemisFetch() {
            const quest = quests[2];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 12, y: canvas.height / 2 - 12, w: 24, h: 24, color: '#f59e0b', speed: 4.5 }, 
                gems: [],
                gemsCollected: 0,
                totalTime: 15, 
                timeRemaining: 15,
                lastTick: Date.now(),
                update: updateArtemisFetch,
                draw: drawArtemisFetch,
            };

            // יצירת 12 יהלומים
            for(let i = 0; i < quest.target; i++) {
                 canvasState.gems.push({
                    x: Math.random() * (canvas.width - 30) + 15, 
                    y: Math.random() * (canvas.height - 30) + 15, 
                    w: 15,
                    h: 15,
                    color: '#ffffff', 
                    r: 7.5
                });
            }
        }

        function updateArtemisFetch() {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // עדכון טיימר
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // תנועת שחקן
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // בדיקת גבולות (הרוחות המבלבלות - מחזיר את השחקן)
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;


            // בדיקת איסוף יהלומים
            for (let i = canvasState.gems.length - 1; i >= 0; i--) {
                const gem = canvasState.gems[i];
                // בדיקת התנגשות (היהלומים נבדקים כריבועים לצורך collision)
                if (checkCollision(player, {x: gem.x - gem.r, y: gem.y - gem.r, w: gem.w, h: gem.h})) {
                    canvasState.gemsCollected++;
                    canvasState.gems.splice(i, 1);
                    if (canvasState.gemsCollected >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `אספת את כל 12 היהלומים בזמן! ארטמיס מרוצה מהדיוק שלך. ניקוד: 500`, 500);
                        return;
                    }
                }
            }

            // בדיקת זמן
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `הזמן נגמר! לא הספקת לאסוף את כל היהלומים. נסה שוב.`);
            }
        }

        function drawArtemisFetch() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור יהלומים (מעוינים)
            canvasState.gems.forEach(gem => {
                ctx.fillStyle = gem.color;
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 5;
                const r = gem.r;
                const x = gem.x;
                const y = gem.y;


                // ציור מעוין
                ctx.beginPath();
                ctx.moveTo(x, y - r); // Top point
                ctx.lineTo(x + r, y); // Right point
                ctx.lineTo(x, y + r); // Bottom point
                ctx.lineTo(x - r, y); // Left point
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0; // איפוס צל
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                info.innerHTML = `יהלומים: ${canvasState.gemsCollected} / ${quest.target} | זמן: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span> שניות`;
            }
        }

        // --- קווסט 4: הרמס - בריחה מרשת הלייזר (Laser Grid Avoidance) ---
        function initHermesAvoidance() {
            const permanentFastSpeed = 9; // המהירות המהירה הקבועה
            canvasState = {
                isRunning: false,
                // הדמות מתחילה במהירות הגבוהה (9)
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#f59e0b', speed: permanentFastSpeed }, 
                walls: [], // הקירות המכילים פערים (Laser Gates)
                wallsDodged: 0, // תיקון השם
                hits: 0,
                maxHits: 3, 
                lastSpawn: 0,
                spawnRate: 1000, 
                update: updateHermesAvoidance,
                draw: drawHermesAvoidance,
            };
        }

        function updateHermesAvoidance(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / (1000/60); // שינוי: חישוב קצב עדכון לפי פריימים
            canvasState.lastTick = now;

            // תנועת שחקן (המהירות היא קבועה 9)
            const playerMove = player.speed * elapsed / (60/player.speed); // ניסיון לאזן מהירות מול FPS
            
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;


            // יצירת קירות (עם שני פערים)
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const gapWidth = 60 + Math.random() * 20; 
                const minGapDistance = 50; 
                const wallHeight = 15;
                
                // חישוב מיקום שני הפערים (gap1Start < gap2Start)
                const totalSpaceNeeded = 2 * gapWidth + minGapDistance;
                const availableStartSpace = canvas.width - totalSpaceNeeded;

                // מיקום התחלה של הפער הראשון
                let gap1Start = Math.random() * (availableStartSpace);

                // מיקום התחלה של הפער השני
                let gap2Start = gap1Start + gapWidth + minGapDistance + Math.random() * (canvas.width - (gap1Start + gapWidth + minGapDistance) - gapWidth);
                
                // ודא ש-gap2Start לא חורג מהקצה
                gap2Start = Math.min(gap2Start, canvas.width - gapWidth - 5);


                canvasState.walls.push({
                    y: -wallHeight,
                    gap1Start: gap1Start,
                    gap1End: gap1Start + gapWidth,
                    gap2Start: gap2Start,
                    gap2End: gap2Start + gapWidth,
                    h: wallHeight,
                    speed: 4.5 + Math.random() * 2.5,
                    color: '#ef4444', // אדום לייזר
                    passed: false, // האם השחקן עבר מתחתיו (חשוב לספירה)
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(700, canvasState.spawnRate - 30); // קצב עולה
            }

            // עדכון מיקום קירות ובדיקת התנגשות
            for (let i = canvasState.walls.length - 1; i >= 0; i--) {
                const wall = canvasState.walls[i];
                // עדכון מיקום הקיר
                wall.y += wall.speed;

                // בדיקת התנגשות (שחקן נתקע בקיר)
                // בודקים אם יש חפיפה אנכית בין השחקן לקיר
                if (player.y + player.h > wall.y && player.y < wall.y + wall.h) {
                    
                    let collision = false;
                    
                    // 1. Segment 1 (Left): 0 to gap1Start
                    if (player.x < wall.gap1Start && player.x + player.w > 0) {
                        collision = true;
                    }
                    // 2. Segment 2 (Middle): gap1End to gap2Start
                    if (player.x < wall.gap2Start && player.x + player.w > wall.gap1End) {
                        // אם הפער הראשון נגמר לפני תחילת השחקן והשחקן מתחיל לפני הפער השני
                        if (player.x + player.w > wall.gap1End && player.x < wall.gap2Start) {
                           collision = true;
                        }
                    }
                    // 3. Segment 3 (Right): gap2End to canvas.width
                    if (player.x + player.w > wall.gap2End && player.x < canvas.width) {
                        collision = true;
                    }
                    
                    if (collision) {
                        // יש התנגשות: חוטפים פגיעה
                        canvasState.hits++;
                        canvasState.walls.splice(i, 1); 
                        
                        if (canvasState.hits >= canvasState.maxHits) {
                            canvasState.isRunning = false;
                            handleQuestResult(false, `נתקעת יותר מדי! המכונה של הרמס השתגעה. נסה שוב.`);
                            return;
                        }
                        continue;
                    }
                }

                // בדיקת יציאה מהמסך (והצלחה)
                if (wall.y > player.y + player.h && !wall.passed) { // שינוי: אם הקיר עבר את גובה השחקן (למטה)
                    wall.passed = true;
                    canvasState.wallsDodged++;

                    if (canvasState.wallsDodged >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `התחמקת מ-15 גדרות לייזר! הרמס קיבל את המכונה שלו בחזרה. ניקוד: 400`, 400);
                        return;
                    }
                }
                
                // ניקוי קירות שיצאו מהמסך
                if (wall.y > canvas.height) {
                    canvasState.walls.splice(i, 1);
                }
            }
        }

        function drawHermesAvoidance() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור קירות לייזר (Laser Gates)
            canvasState.walls.forEach(wall => {
                ctx.fillStyle = wall.color;
                ctx.shadowColor = wall.color;
                ctx.shadowBlur = 10;
                
                // קיר שמאלי (Segment 1: 0 to gap1Start)
                ctx.fillRect(0, wall.y, wall.gap1Start, wall.h);
                
                // קיר אמצעי (Segment 2: gap1End to gap2Start)
                ctx.fillRect(wall.gap1End, wall.y, wall.gap2Start - wall.gap1End, wall.h);

                // קיר ימני (Segment 3: gap2End to canvas.width)
                ctx.fillRect(wall.gap2End, wall.y, canvas.width - wall.gap2End, wall.h);
                
                ctx.shadowBlur = 0;
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `התחמקות: ${canvasState.wallsDodged} / ${quest.target} | פגיעות: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }


        // --- קווסט 5: אפרודיטה - ניקוי הבלגן הרומנטי ---

        const ITEM_TYPE = { HEART: 'heart', FLOWER: 'flower' };
        
        function initAphroditeClean() {
            const quest = quests[4];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 15, y: canvas.height / 2 - 15, w: 30, h: 30, color: '#ec4899', speed: 4 }, 
                items: [],
                collectedCount: { heart: 0, flower: 0 },
                totalCollected: 0,
                collectingType: ITEM_TYPE.HEART, // מתחיל עם לבבות
                lastTypeSwitch: 0,
                typeSwitchCooldown: 1000, // קושי: 1 שנייה קירור
                totalTime: 20, 
                timeRemaining: 20,
                lastTick: Date.now(),
                update: updateAphroditeClean,
                draw: drawAphroditeClean,
            };

            // יצירת 8 לבבות ו-7 פרחים (סה"כ 15)
            const targets = { heart: 8, flower: 7 };
            for(let type in targets) {
                for(let i = 0; i < targets[type]; i++) {
                    canvasState.items.push({
                        x: Math.random() * (canvas.width - 30) + 15, 
                        y: Math.random() * (canvas.height - 30) + 15, 
                        w: 15,
                        h: 15,
                        type: type,
                        r: 7.5
                    });
                }
            }
        }

        function updateAphroditeClean() {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();

            // עדכון טיימר
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // תנועת שחקן
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // בדיקת גבולות
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;

            // החלפת סוג איסוף (רווח - Space)
            const isOnCooldown = now - canvasState.lastTypeSwitch < canvasState.typeSwitchCooldown;
            if (keys[' '] && !isOnCooldown) {
                canvasState.collectingType = canvasState.collectingType === ITEM_TYPE.HEART ? ITEM_TYPE.FLOWER : ITEM_TYPE.HEART;
                canvasState.lastTypeSwitch = now;
                keys[' '] = false; // למנוע החלפה מיידית נוספת
            }

            // בדיקת איסוף
            for (let i = canvasState.items.length - 1; i >= 0; i--) {
                const item = canvasState.items[i];
                if (checkCollision(player, {x: item.x - item.r, y: item.y - item.r, w: item.w, h: item.h})) {
                    if (item.type === canvasState.collectingType) {
                        // איסוף מוצלח
                        canvasState.collectedCount[item.type]++;
                        canvasState.totalCollected++;
                        canvasState.items.splice(i, 1);
                        if (canvasState.totalCollected >= quest.target) {
                            canvasState.isRunning = false;
                            handleQuestResult(true, `אספת את כל ${quest.target} המרכיבים בזמן! אפרודיטה יכולה להשלים את שיקוי האהבה. ניקוד: 600`, 600);
                            return;
                        }
                    } else {
                        // פגיעה בפריט הלא נכון
                        // אולי קנס קטן? כרגע אין קנס מעבר לאיבוד זמן
                    }
                }
            }

            // בדיקת זמן
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `הזמן נגמר! לא אספת את כל ${quest.target} המרכיבים. נסה שוב.`);
            }
        }

        function drawAphroditeClean() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const now = Date.now();

            // ציור פריטים
            canvasState.items.forEach(item => {
                ctx.shadowBlur = 5;
                if (item.type === ITEM_TYPE.HEART) {
                    // ציור לב (Heart - פונקציית ציור פשוטה)
                    ctx.fillStyle = '#f87171';
                    ctx.shadowColor = '#f87171';
                    const h_x = item.x;
                    const h_y = item.y;
                    const r = item.r;
                    
                    ctx.beginPath();
                    // שימוש בצורה גיאומטרית פשוטה יותר לבטיחות
                    ctx.moveTo(h_x, h_y + r); 
                    ctx.lineTo(h_x + r, h_y - r);
                    ctx.lineTo(h_x + r / 2, h_y - r * 2);
                    ctx.lineTo(h_x, h_y - r * 1.5);
                    ctx.lineTo(h_x - r / 2, h_y - r * 2);
                    ctx.lineTo(h_x - r, h_y - r);
                    ctx.closePath();
                    ctx.fill();

                } else {
                    // ציור פרח (Flower - עיגול + עלי כותרת פשוטים)
                    ctx.fillStyle = '#818cf8';
                    ctx.shadowColor = '#818cf8';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
                ctx.shadowBlur = 0;
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // הדגשת מצב איסוף נוכחי
            const statusColor = canvasState.collectingType === ITEM_TYPE.HEART ? '#f87171' : '#818cf8';
            ctx.fillStyle = statusColor;
            ctx.globalAlpha = 0.2;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            const isOnCooldown = now - canvasState.lastTypeSwitch < canvasState.typeSwitchCooldown;
            const cooldownText = isOnCooldown ? ` (ממתין ${((canvasState.typeSwitchCooldown - (now - canvasState.lastTypeSwitch) + 100) / 1000).toFixed(1)} שנ')` : '';

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                info.innerHTML = `אסוף: <span style="color: ${statusColor}; font-weight: bold">${canvasState.collectingType === ITEM_TYPE.HEART ? 'לבבות' : 'פרחים'}</span>${cooldownText} | סה"כ: ${canvasState.totalCollected} / ${quest.target} | זמן: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span>`;
            }
        }

        // --- קווסט 6: פוסידון - נחשולי האצות הזועמים ---
        function initPoseidonDodge() {
            const quest = quests[5];
            canvasState = {
                isRunning: false, 
                player: { x: 30, y: canvas.height / 2 - 15, w: 30, h: 30, color: '#10b981', speed: 4.5 }, // הדמות נמצאת בצד שמאל
                obstacles: [], // גושי אצות וסלעים
                dodgedCount: 0,
                hits: 0,
                maxHits: 2, 
                lastSpawn: 0,
                spawnRate: 400, // קושי: קצב גבוה
                update: updatePoseidonDodge,
                draw: drawPoseidonDodge,
            };
        }

        function updatePoseidonDodge(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // תנועת שחקן - רק למעלה ולמטה
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // יצירת אובייקטים
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const y = Math.random() * (canvas.height - 20) + 10;
                const h = 15 + Math.random() * 25; // גובה משתנה
                const w = 15 + Math.random() * 20; // רוחב משתנה
                
                canvasState.obstacles.push({
                    x: canvas.width, 
                    y: y - h / 2,
                    w: w, 
                    h: h,
                    speed: 4 + Math.random() * 3, // קושי: מהירות גבוהה
                    color: Math.random() < 0.3 ? '#4b5563' : '#059669' // אצות או סלע אפור
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(100, canvasState.spawnRate - 5); // קושי: קצב הופעה גדל
            }

            // עדכון מיקום מכשולים ובדיקת התנגשות
            for (let i = canvasState.obstacles.length - 1; i >= 0; i--) {
                const obstacle = canvasState.obstacles[i];
                obstacle.x -= obstacle.speed;

                if (checkCollision(player, obstacle)) {
                    // פגיעה
                    canvasState.hits++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.hits >= canvasState.maxHits) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `פוסידון חסם את נתיב המים! חטפת ${canvasState.hits} פגיעות. נסה שוב.`);
                        return;
                    }
                } else if (obstacle.x + obstacle.w < 0) {
                    // מכשול יצא מהמסך
                    canvasState.dodgedCount++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.dodgedCount >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `התחמקת מ-20 גושים! פוסידון הרגיע את הים. ניקוד: 700`, 700);
                    }
                }
            }
        }

        function drawPoseidonDodge() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור מכשולים
            canvasState.obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.w, obstacle.h);
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `התחמקות: ${canvasState.dodgedCount} / ${quest.target} | פגיעות: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }

        // --- קווסט 7: דיוניסוס - מרתון הברמנים הקוסמי (Overcooked Style) ---

        const INGREDIENTS = { GRAPE: 'GRAPE', CLOUD: 'CLOUD', LIGHTNING: 'LIGHTNING' };
        
        function initDionysusCocktail() {
            const quest = quests[6];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#9d174d', speed: 4.5 }, 
                items: [], // מרכיבים פזורים
                required: { GRAPE: 1, CLOUD: 1, LIGHTNING: 1 },
                inventory: { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 },
                cocktailsMade: 0,
                totalTime: 25, 
                timeRemaining: 25,
                lastTick: Date.now(),
                lastSpawn: 0,
                
                // --- לוגיקת סדר הופעה חדשה ---
                spawnInterval: 1000, // 1 שניה בין סוג מרכיב לסוג
                spawnSequence: [INGREDIENTS.GRAPE, INGREDIENTS.LIGHTNING, INGREDIENTS.CLOUD],
                sequenceIndex: 0,

                // --- לוגיקת בישול חדשה ---
                isMixing: false,
                mixingStartTime: 0,
                mixTimeRequired: 2000, // 2 שניות
                
                // --- לוגיקת ארס חדשה ---
                aresAttacks: [], // חרבות של ארס
                lastAresSpawn: 0,
                aresSpawnRate: 1800, // חרב כל 1.8 שניות
                aresSpeed: 4,

                update: updateDionysusCocktail,
                draw: drawDionysusCocktail,
            };
            
            // הגדרת זמן ההופעה הראשונית (מיד אחרי ההתחלה)
            canvasState.lastSpawn = Date.now();
        }
        
        // פונקציה ליצירת מרכיב ספציפי
        function spawnIngredient(type) { 
            // בדיקה שסוג המרכיב תקין
            if (!Object.values(INGREDIENTS).includes(type)) return;

            canvasState.items.push({
                x: Math.random() * (canvas.width - 30) + 15, 
                y: Math.random() * (canvas.height - 30) + 15, 
                w: 20, h: 20, 
                type: type,
                r: 10
            });
        }

        function spawnAresAttack(timestamp) {
            // חרב זזה אופקית (מימין לשמאל או משמאל לימין)
            const isLeftToRight = Math.random() < 0.5;
            const y = Math.random() * (canvas.height - 30) + 15;
            const speed = canvasState.aresSpeed + Math.random() * 1.5;

            canvasState.aresAttacks.push({
                x: isLeftToRight ? -20 : canvas.width,
                y: y,
                w: 30, h: 8, // רוחב וגובה של החרב
                speed: isLeftToRight ? speed : -speed,
                color: '#b91c1c', // אדום של ארס
                isLeftToRight: isLeftToRight,
            });
            canvasState.lastAresSpawn = timestamp;
            canvasState.aresSpawnRate = Math.max(1000, canvasState.aresSpawnRate - 50); // מגביר קצב
        }


        function updateDionysusCocktail(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();

            // עדכון טיימר
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // תנועת שחקן
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // בדיקת גבולות
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;

            // יצירת מרכיבים חדשים לפי סדר קבוע וזמנים (Spawn)
            if (now - canvasState.lastSpawn > canvasState.spawnInterval && canvasState.items.length < 12) {
                
                // 1. קביעת סוג המרכיב הנוכחי לפי האינדקס
                const typeToSpawn = canvasState.spawnSequence[canvasState.sequenceIndex];

                // 2. יצירת המרכיב
                spawnIngredient(typeToSpawn);
                
                // 3. עדכון זמן
                canvasState.lastSpawn = now;

                // 4. קידום לאינדקס הבא (מחזור)
                canvasState.sequenceIndex = (canvasState.sequenceIndex + 1) % canvasState.spawnSequence.length;
            }

            // יצירת התקפת ארס
            if (timestamp - canvasState.lastAresSpawn > canvasState.aresSpawnRate) {
                spawnAresAttack(timestamp);
            }

            // --- לוגיקת התקפות ארס ---
            for (let i = canvasState.aresAttacks.length - 1; i >= 0; i--) {
                const sword = canvasState.aresAttacks[i];
                sword.x += sword.speed;

                if (checkCollision(player, sword)) {
                    // פגיעה מארס: איפוס מלאי וביטול בישול
                    canvasState.inventory = { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 };
                    canvasState.isMixing = false;
                    canvasState.mixingStartTime = 0;
                    canvasState.aresAttacks.splice(i, 1);
                    break; // break מהלולאה הנוכחית (לולאת aresAttacks)
                } else if (sword.x > canvas.width || sword.x + sword.w < 0) {
                    canvasState.aresAttacks.splice(i, 1);
                }
            }


            // בדיקת איסוף
            for (let i = canvasState.items.length - 1; i >= 0; i--) {
                const item = canvasState.items[i];
                if (checkCollision(player, item)) {
                    canvasState.inventory[item.type]++;
                    canvasState.items.splice(i, 1);
                    break; // break מהלולאה הנוכחית (לולאת items)
                }
            }
            
            // בדיקת מיקסר
            const mixer = { x: canvas.width/2 - 50, y: 10, w: 100, h: 50 }; 
            const isCollidingWithMixer = checkCollision(player, mixer);
            
            const hasAllIngredients = 
                canvasState.inventory.GRAPE >= canvasState.required.GRAPE &&
                canvasState.inventory.CLOUD >= canvasState.required.CLOUD &&
                canvasState.inventory.LIGHTNING >= canvasState.required.LIGHTNING;
            
            // לוגיקת בישול
            if (isCollidingWithMixer && hasAllIngredients) {
                if (!canvasState.isMixing) {
                    // התחלת בישול
                    canvasState.isMixing = true;
                    canvasState.mixingStartTime = now;
                } else {
                    // בדיקת סיום בישול
                    if (now - canvasState.mixingStartTime >= canvasState.mixTimeRequired) {
                        // בישול מוצלח!
                        canvasState.cocktailsMade++;
                        canvasState.inventory = { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 }; // איפוס מלאי
                        canvasState.isMixing = false;
                        canvasState.mixingStartTime = 0;

                        if (canvasState.cocktailsMade >= quest.target) {
                            canvasState.isRunning = false;
                            handleQuestResult(true, `הכנת 3 קוקטיילים! דיוניסוס חוזר ליין הרגיל. ניקוד: 800`, 800);
                            return;
                        }
                    }
                }
            } else {
                // אם יצאת מהמיקסר או איבדת מרכיבים, הערבוב מתבטל
                if (canvasState.isMixing) {
                    canvasState.isMixing = false;
                    canvasState.mixingStartTime = 0;
                }
            }
            
            // בדיקת זמן
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `הזמן נגמר! לא הספקת להכין את כל 3 הקוקטיילים. נסה שוב.`);
            }
        }

        function drawDionysusCocktail() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const now = Date.now();
            
            // 1. ציור מיכל הערבוב (Mixer)
            const mixer = { x: canvas.width/2 - 50, y: 10, w: 100, h: 50 };
            ctx.fillStyle = '#6d28d9'; // סגול עמוק ליין
            ctx.fillRect(mixer.x, mixer.y, mixer.w, mixer.h);
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 3;
            ctx.strokeRect(mixer.x, mixer.y, mixer.w, mixer.h);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText("ערבוב (Mix)", canvas.width / 2, 40);
            
            // 1.1. ציור סרגל התקדמות בישול
            if (canvasState.isMixing) {
                const progress = (now - canvasState.mixingStartTime) / canvasState.mixTimeRequired;
                const barWidth = mixer.w * progress;
                ctx.fillStyle = '#FFD700'; // צהוב זהב להתקדמות
                ctx.fillRect(mixer.x, mixer.y + mixer.h - 5, barWidth, 5);
            }


            // 2. ציור מרכיבים
            canvasState.items.forEach(item => {
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                // ציור באמצעות אימוג'י
                if (item.type === INGREDIENTS.GRAPE) {
                    ctx.fillText('🍇', item.x, item.y + 15);
                } else if (item.type === INGREDIENTS.CLOUD) {
                    ctx.fillText('☁️', item.x, item.y + 15);
                } else if (item.type === INGREDIENTS.LIGHTNING) {
                    ctx.fillText('⚡', item.x, item.y + 15);
                }
            });
            
            // 3. ציור התקפות ארס (חרבות)
            canvasState.aresAttacks.forEach(sword => {
                ctx.fillStyle = sword.color;
                ctx.shadowColor = sword.color;
                ctx.shadowBlur = 10;
                
                // ציור להב
                ctx.fillRect(sword.x, sword.y, sword.w, sword.h);
                // ציור ידית (קטנה)
                ctx.fillStyle = '#78350f';
                ctx.fillRect(sword.x + sword.w, sword.y + 2, 5, 4);

                ctx.shadowBlur = 0;
            });


            // 4. ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // 5. עדכון מידע ומלאי (Inventory)
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                let mixingStatus = '';
                if (canvasState.isMixing) {
                    const timeLeft = canvasState.mixTimeRequired - (now - canvasState.mixingStartTime);
                    mixingStatus = ` | מערבב... <span class="text-yellow-600">${(timeLeft / 1000).toFixed(1)}</span> שנ'`;
                }
                
                info.innerHTML = `
                    <div style="direction:rtl; display: flex; justify-content: space-between; width: 100%;">
                        <span>קוקטיילים: <span class="text-green-600">${canvasState.cocktailsMade}</span> / ${quest.target}${mixingStatus}</span>
                        <span>זמן: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span> שנ'</span>
                    </div>
                    <div class="mt-2 text-sm text-gray-700 font-normal">
                        מלאי: 🍇:${canvasState.inventory.GRAPE} / ☁️:${canvasState.inventory.CLOUD} / ⚡:${canvasState.inventory.LIGHTNING}
                    </div>
                `;
            }
        }


        // =========================================================
        // --- קווסט 8: הפיסטוס - הרכבת הרובוט המנצח ---
        // =========================================================

        const ROBOT_PARTS = { 
            HEAD: 'HEAD', 
            BODY: 'BODY', 
            ARM: 'ARM', 
            WHEEL: 'WHEEL' 
        };
        
        // 1. פרטי החלקים (מאפיינים שונים)
        const PART_VARIANTS = [
            // גופים (Body)
            { id: 1, type: ROBOT_PARTS.BODY, name: "גוף מרוץ (קל)", emoji: '🟥', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 3, type: ROBOT_PARTS.BODY, name: "גוף גמיש (מאוזן)", emoji: '🟩', stats: { speed: 3, weight: 3, balance: 5 } },

            // גלגלים (Wheel)
            { id: 4, type: ROBOT_PARTS.WHEEL, name: "גלגלי ספיד", emoji: '🚀', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 6, type: ROBOT_PARTS.WHEEL, name: "גלגלי אחיזה (מאוזן)", emoji: '🛡️', stats: { speed: 3, weight: 3, balance: 5 } },
            
            // זרועות (Arm)
            { id: 7, type: ROBOT_PARTS.ARM, name: "זרועות כוח", emoji: '💪', stats: { speed: 1, weight: 5, balance: 2 } },
            { id: 9, type: ROBOT_PARTS.ARM, name: "זרועות כלי עבודה (מאוזן)", emoji: '🛠️', stats: { speed: 3, weight: 3, balance: 5 } },

            // ראשים (Head)
            { id: 10, type: ROBOT_PARTS.HEAD, name: "ראש חיישן", emoji: '💡', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 12, type: ROBOT_PARTS.HEAD, name: "ראש פיקוד (מאוזן)", emoji: '⚙️', stats: { speed: 3, weight: 3, balance: 5 } },
        ].filter(p => p.id !== 2 && p.id !== 5 && p.id !== 8 && p.id !== 11); // סינון כדי להשאיר 8 חלקים, 2 מכל סוג

        
        // 2. הגדרת מיקומי הרכבה קבועים
        // יש להשתמש במיקומים קבועים כדי לחשב את ההחזרה של החלק למאגר
        const INITIAL_PART_POSITIONS = {}; 
        PART_VARIANTS.forEach((p, index) => {
            // התאמת המיקום לאחר הקיצוץ (4 שורות, 2 עמודות)
            INITIAL_PART_POSITIONS[p.id] = { 
                x: 280 + (index % 2) * 40, // 280, 320
                y: 70 + Math.floor(index / 2) * 55 // 70, 125, 180, 235
            };
        });

        const BUILD_SLOTS = {
            [ROBOT_PARTS.HEAD]: { x: 175, y: 50, radius: 20, assignedPart: null },
            [ROBOT_PARTS.BODY]: { x: 175, y: 120, radius: 25, assignedPart: null },
            [ROBOT_PARTS.ARM]: { x: 175, y: 190, radius: 20, assignedPart: null },
            [ROBOT_PARTS.WHEEL]: { x: 175, y: 260, radius: 25, assignedPart: null },
        };

        // 3. הגדרת מכשולים במסלול
        const OBSTACLES = [
            { type: 'SPEED_CHALLENGE', name: "מכשול 1: מנהרת מהירות", requiredStat: 'speed', threshold: 12, failMessage: "הרובוט שלך היה איטי מדי במנהרת המהירות!" },
            { type: 'FORCE_CHALLENGE', name: "מכשול 2: קיר הריסות כבד", requiredStat: 'weight', threshold: 12, failMessage: "הרובוט לא היה חזק מספיק כדי לשבור את קיר ההריסות!" },
            { type: 'PRECISION_CHALLENGE', name: "מכשול 3: גשר כבלים דק", requiredStat: 'balance', threshold: 18, failMessage: "הרובוט איבד יציבות על גשר הכבלים ונפל!" },
        ];


        function initHephaestusBuild() {
            const quest = quests[7]; // קווסט 8
            
            // יצירת עותק של החלקים והצבתם במיקום ההתחלתי הקבוע
            let currentParts = JSON.parse(JSON.stringify(PART_VARIANTS));
            currentParts.forEach((p) => {
                const pos = INITIAL_PART_POSITIONS[p.id];
                p.x = pos.x; 
                p.y = pos.y;
                p.w = 30; 
                p.h = 30;
                p.isHeld = false; // מצב חדש: האם השחקן מחזיק את החלק
            });

            // איפוס סלוטים
            for (const key in BUILD_SLOTS) {
                BUILD_SLOTS[key].assignedPart = null;
            }

            canvasState = {
                isRunning: false,
                phase: 'BUILD', // 'BUILD' | 'TEST'
                
                lastTick: Date.now(),
                
                // BUILD PHASE
                partsPool: currentParts,
                buildSlots: BUILD_SLOTS,
                
                // --- שינוי: מעבר משליטת עכבר לשליטת מקשים ---
                player: { x: 50, y: canvas.height / 2, w: 30, h: 30, color: '#f59e0b', speed: 4 }, // דמות הגיבור
                heldPart: null, // החלק שהשחקן מחזיק
                
                // TEST PHASE
                robot: null, 
                obstacles: OBSTACLES, 
                obstaclesPassed: 0,
                robotProgress: 0, 
                robotX: 0, 
                robotY: 0,
                robotW: 40, 
                robotH: 40,
                robotSpeed: 2, 
                testStartTime: 0,
                testRunning: false,
                
                update: updateHephaestusBuild,
                draw: drawHephaestusBuild,
            };

            // אין יותר מאזיני עכבר/מגע DND
            // השליטה עברה ל-handleKeyDown/Up הגלובליים והפונקציה updateHephaestusBuild
            canvasState.isRunning = true; // התחלת לולאת המשחק כדי לאפשר תנועה
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
            
            // עדכון המידע הראשוני
            const info = document.getElementById('game-info');
            if (info) info.innerHTML = "נווט עם החצים, אסוף/שחרר חלקים עם **רווח**.";
            
            // הסתרת כפתור הבדיקה עד להשלמת ההרכבה
            const btn = document.getElementById('start-game-btn');
            if (btn) btn.style.display = 'none';
        }
        
        // --- לוגיקת איסוף/שחרור באמצעות מקשים ---
        
        // --- פונקציה גלובלית לבדיקת השלמה והתחלת מירוץ ---
        function checkBuildCompletion() {
            const btn = document.getElementById('start-game-btn');
            const info = document.getElementById('game-info');
            
            // 1. בדוק אם כל הסלוטים מלאים
            const allSlotsFilled = Object.values(canvasState.buildSlots).every(slot => slot.assignedPart !== null);
            
            if (allSlotsFilled) {
                // 2. חשב את נתוני הרובוט הסופיים
                const stats = { speed: 0, weight: 0, balance: 0, totalScore: 0 };
                Object.values(canvasState.buildSlots).forEach(slot => {
                    stats.speed += slot.assignedPart.stats.speed;
                    stats.weight += slot.assignedPart.stats.weight;
                    stats.balance += slot.assignedPart.stats.balance;
                });

                // ציון איזון משוקלל: (מהירות + משקל) * איזון
                stats.totalScore = (stats.speed + stats.weight) * stats.balance; 

                // 3. הגדר את מצב הרובוט לטסט
                canvasState.robot = stats;
                canvasState.phase = 'TEST';
                canvasState.robotX = 0;
                canvasState.robotY = canvas.height / 2 - canvasState.robotH / 2; // ממורכז
                canvasState.obstaclesPassed = 0;
                canvasState.testRunning = true;
                
                // הגדר מהירות רובוט (יחסית למהירות הממוצעת)
                canvasState.robotSpeed = stats.speed / 4; 

                // 4. הצג כפתור והוראות
                if (btn) {
                    btn.textContent = "התחל מירוץ רובוט!";
                    btn.onclick = () => {
                        // מעבר ללולאת משחק רגילה לטסט
                        canvasState.isRunning = true;
                        if (gameLoopId) cancelAnimationFrame(gameLoopId);
                        gameLoopId = requestAnimationFrame(gameLoop);
                        btn.style.display = 'none';
                        info.textContent = `הרובוט מוכן! איזון כולל: ${stats.totalScore.toFixed(1)}`;
                    };
                    btn.style.display = 'block';
                }
                if (info) info.innerHTML = `הרכבה הושלמה! הרובוט מוכן למבחן. **ציון איזון כולל: <span class="text-green-600">${stats.totalScore.toFixed(1)}</span>**`;
                
                // עצור את לולאת ה-BUILD (התנועה)
                canvasState.isRunning = false; 

            } else {
                if (btn) btn.style.display = 'none';
                if (info) info.innerHTML = "נווט עם החצים, אסוף/שחרר חלקים עם **רווח**. חסרים חלקים.";
            }
        }
        
        
        function handleBuildInput() {
            const player = canvasState.player;
            const now = Date.now();
            
            // בדיקה אם נלחץ מקש רווח (Space)
            if (keys[' ']) {
                
                if (canvasState.heldPart) {
                    // --- שלב 2: שחרור חלק ---
                    
                    let dropped = false;
                    
                    // בודק התנגשות מול סלוטים פנויים
                    for (const key in canvasState.buildSlots) {
                        const slot = canvasState.buildSlots[key];
                        
                        // בדיקת התנגשות (מרכז השחקן מול מרכז הסלוט)
                        const distance = Math.sqrt(
                            Math.pow((player.x + player.w/2) - slot.x, 2) + 
                            Math.pow((player.y + player.h/2) - slot.y, 2)
                        );
                        
                        // אם קרוב מספיק לסלוט ואין בו חלק
                        if (distance < slot.radius + 15 && !slot.assignedPart) { 
                            slot.assignedPart = canvasState.heldPart;
                            canvasState.heldPart.isHeld = false;
                            
                            // מיקום החלק בסלוט לצורך ציור
                            canvasState.heldPart.x = slot.x;
                            canvasState.heldPart.y = slot.y;

                            canvasState.heldPart = null;
                            dropped = true;
                            break;
                        }
                    }
                    
                    // אם שוחרר בהצלחה, בודקים השלמה ומציירים מחדש
                    if (dropped) {
                        checkBuildCompletion();
                        canvasState.draw();
                    } else {
                        // אם לא שוחרר בסלוט, מחזירים אותו למאגר (כדי שיהיה אפשר לאסוף אותו שוב)
                         canvasState.heldPart.isHeld = false;
                         const originalPos = INITIAL_PART_POSITIONS[canvasState.heldPart.id];
                         canvasState.heldPart.x = originalPos.x;
                         canvasState.heldPart.y = originalPos.y;
                         canvasState.heldPart = null;
                         canvasState.draw();
                    }
                    
                } else {
                    // --- שלב 1: איסוף חלק ---
                    
                    // בודק התנגשות מול חלקים פנויים במאגר
                    for (let i = canvasState.partsPool.length - 1; i >= 0; i--) {
                        const part = canvasState.partsPool[i];
                        
                        // רק אם החלק לא מוחזק ולא מורכב
                        if (!part.isHeld && 
                            !Object.values(canvasState.buildSlots).some(s => s.assignedPart === part) &&
                            checkCollision(player, part)) {
                            
                            canvasState.heldPart = part;
                            part.isHeld = true;
                            canvasState.draw();
                            break;
                        }
                    }
                }
                
                keys[' '] = false; // איפוס רווח כדי שלא יפעל רצוף
            }
        }


        function updateHephaestusBuild(timestamp) {
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            const player = canvasState.player;

            if (canvasState.phase === 'BUILD') {
                // 1. תנועת שחקן
                const speed = player.speed * elapsed * 60;
                if (keys['ArrowLeft'] && player.x > 0) player.x -= speed;
                if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += speed;
                if (keys['ArrowUp'] && player.y > 0) player.y -= speed;
                if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += speed;

                // 2. עדכון מיקום החלק המוחזק (צמוד לדמות)
                if (canvasState.heldPart) {
                    canvasState.heldPart.x = player.x + player.w / 2;
                    canvasState.heldPart.y = player.y - 10;
                }

                // 3. לוגיקת איסוף/שחרור
                handleBuildInput();

                // 4. ציור מחדש
                canvasState.draw();

            } else if (canvasState.phase === 'TEST' && canvasState.testRunning) {
                
                // 1. תנועת הרובוט
                canvasState.robotX += canvasState.robotSpeed * elapsed * 60; 

                // 2. בדיקת סיום מכשול (לוגיקה זהה לשמירה על טוויסט המסלול)
                const currentObstacleIndex = canvasState.obstaclesPassed;
                
                // רובוט עבר את המסלול
                if (canvasState.obstaclesPassed >= canvasState.obstacles.length) {
                    canvasState.testRunning = false;
                    canvasState.isRunning = false;
                    handleQuestResult(true, `הרובוט עבר בהצלחה את כל 3 המכשולים! הפיסטוס קיבל את המקום הראשון. ניקוד: 900`, 900);
                    return;
                }
                
                const obstacle = canvasState.obstacles[currentObstacleIndex];
                const obstacleX = 100 + currentObstacleIndex * 100; 

                // בדיקת פגיעה במכשול
                if (canvasState.robotX > obstacleX && canvasState.robotX - canvasState.robotSpeed * elapsed * 60 < obstacleX) {
                    
                    const requiredStatValue = canvasState.robot[obstacle.requiredStat];

                    const scoreToCheck = obstacle.requiredStat === 'balance' ? 
                                          canvasState.robot.totalScore : 
                                          requiredStatValue * 4; 

                    if (scoreToCheck < obstacle.threshold) {
                        canvasState.testRunning = false;
                        canvasState.isRunning = false;
                        handleQuestResult(false, `${obstacle.failMessage} (נדרש ציון ${obstacle.requiredStat} של ${obstacle.threshold}, קיבלת ${scoreToCheck.toFixed(1)}). נסה למצוא את הצירוף המאוזן.`);
                        return;
                    } else {
                        canvasState.obstaclesPassed++;
                    }
                }
                
                // עדכון ציור
                canvasState.draw();
            }
        }

        function drawHephaestusBuild() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const info = document.getElementById('game-info');
            const player = canvasState.player;

            if (canvasState.phase === 'BUILD') {
                // --- ציור שלב ההרכבה ---
                
                // קו הפרדה בין אזור הרכבה לאזור חלקי חילוף
                ctx.strokeStyle = '#9ca3af'; 
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 + 30, 0);
                ctx.lineTo(canvas.width / 2 + 30, canvas.height);
                ctx.stroke();

                // 1. ציור סלוטים (מקומות הרכבה)
                ctx.textAlign = 'center';
                for (const key in canvasState.buildSlots) {
                    const slot = canvasState.buildSlots[key];
                    ctx.beginPath();
                    ctx.arc(slot.x, slot.y, slot.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = slot.assignedPart ? '#059669' : '#9ca3af';
                    ctx.font = '10px Inter';
                    
                    // כיתוב סלוט
                    let text;
                    if (key === ROBOT_PARTS.HEAD) text = "ראש (HEAD)";
                    else if (key === ROBOT_PARTS.BODY) text = "גוף (BODY)";
                    else if (key === ROBOT_PARTS.ARM) text = "זרועות (ARM)";
                    else if (key === ROBOT_PARTS.WHEEL) text = "גלגלים (WHEEL)";
                    
                    ctx.fillText(text, slot.x, slot.y + slot.radius + 15);
                    
                    // ציור החלק שהוצמד לסלוט
                    if (slot.assignedPart) {
                        ctx.font = '25px Arial';
                        ctx.fillText(slot.assignedPart.emoji, slot.x, slot.y + 10);
                    }
                }

                // 2. ציור מאגר החלקים (ימין)
                ctx.fillStyle = '#1f2937';
                ctx.font = '12px Inter';
                ctx.textAlign = 'right';
                ctx.fillText("מאגר חלקים:", canvas.width - 20, 30);
                
                // לולאה על כל החלקים
                canvasState.partsPool.forEach(part => {
                    // ציור רק אם החלק לא מוחזק על ידי השחקן ואין לו סלוט
                    let isAssignedToSlot = Object.values(canvasState.buildSlots).some(s => s.assignedPart === part);

                    if (!part.isHeld && !isAssignedToSlot) {
                         // רקע קטן לחלק
                        ctx.fillStyle = '#fcd34d';
                        ctx.fillRect(part.x - part.w/2, part.y - part.h/2, part.w, part.h);
                        
                        // ציור האימוג'י
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(part.emoji, part.x, part.y + 7);

                        // כיתוב מתחת לאימוג'י
                        ctx.font = '10px Inter';
                        ctx.fillStyle = '#1f2937';
                        ctx.fillText(part.name, part.x, part.y + 25);
                    }
                });

                // 3. ציור החלק המוחזק
                if(canvasState.heldPart) {
                    const part = canvasState.heldPart;
                    // רקע לחלק המוחזק
                    ctx.fillStyle = '#f87171'; // צבע אדום להדגשה
                    ctx.fillRect(part.x - part.w/2, part.y - part.h/2, part.w, part.h);
                    
                    // ציור האימוג'י
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(part.emoji, part.x, part.y + 7);

                    // ציור כיתוב קטן
                    ctx.font = '10px Inter';
                    ctx.fillStyle = '#1f2937';
                    ctx.fillText(part.name, part.x, part.y + 25);
                }

                // 4. ציור הדמות השולטת
                drawPlayerFigure(player, canvasState.heldPart !== null);

            } 
            
            else if (canvasState.phase === 'TEST') {
                // --- ציור שלב המירוץ ---
                ctx.textAlign = 'center';
                
                // 1. ציור רובוט (משתמשים באימוג'י רובוט כדי להדגיש את המעבר)
                ctx.fillStyle = '#b91c1c';
                // ציור גוף הרובוט
                ctx.fillRect(canvasState.robotX, canvasState.robotY, canvasState.robotW, canvasState.robotH);
                ctx.font = '30px Arial';
                ctx.fillText('🤖', canvasState.robotX + canvasState.robotW / 2, canvasState.robotY + 30);
                
                // 2. ציור מכשולים
                ctx.lineWidth = 3;
                canvasState.obstacles.forEach((obstacle, index) => {
                    const obstacleX = 100 + index * 100;
                    
                    // צבע אפור לפני ההגעה, צהוב בזמן המכשול, ירוק אחרי מעבר
                    let lineColor = '#9ca3af'; // אפור
                    if (index === canvasState.obstaclesPassed) {
                        lineColor = '#fcd34d'; // צהוב/זהב בזמן המכשול
                    } else if (index < canvasState.obstaclesPassed) {
                        lineColor = '#059669'; // ירוק אחרי מעבר
                    }
                    
                    ctx.strokeStyle = lineColor; 
                    
                    // ציור סימן המכשול
                    ctx.beginPath();
                    ctx.moveTo(obstacleX, 0);
                    ctx.lineTo(obstacleX, canvas.height);
                    ctx.stroke();
                    
                    // כיתוב
                    ctx.fillStyle = '#1f2937';
                    ctx.font = '12px Inter';
                    ctx.fillText(obstacle.name, obstacleX, 20);

                    // סימון הצלחה
                    if (index < canvasState.obstaclesPassed) {
                        ctx.fillStyle = '#059669';
                        ctx.font = '20px Arial';
                        ctx.fillText('✅', obstacleX, canvas.height - 20);
                    }
                });
                
                // 3. עדכון מידע
                if (info) {
                    const obstacleName = canvasState.obstaclesPassed < quest.target ? 
                        canvasState.obstacles[canvasState.obstaclesPassed].name : 
                        "הרובוט במסלול לסיום...";
                    
                    info.innerHTML = `
                        שלב: <span class="text-blue-600">${canvasState.obstaclesPassed + 1} / ${quest.target} (${obstacleName})</span> | 
                        ניקוד כולל (איזון): <span class="text-red-600">${canvasState.robot.totalScore.toFixed(1)}</span>
                    `;
                }
            }
        }

        // טעינת המשחק עם פתיחת הדף + טיפול בשגיאות
        window.onload = function() {
            try {
                // בדיקה אם ה-div הראשי קיים
                if (document.getElementById('game-app')) {
                    renderIntro();
                } else {
                    console.error("Game container #game-app not found.");
                }
            } catch (error) {
                // זה ייתפס רק אם השגיאה היא ב-renderIntro, שגיאות Parse ייתפסו ע"י ה-Global Error Handler
                console.error("Game failed to initialize during onload:", error);
            }
        };
    </script>
</body>
</html>
