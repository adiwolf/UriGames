<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מפקד הממלכה (אנימציית קרב צידית)</title>
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // הגדרת משתני Firebase גלובליים
        window.db = null;
        window.auth = null;
        window.userId = null;
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@400;700&display=swap');
        
        :root {
            --tile-size: 80px; /* Base for tile sizing */
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            /* שינוי: רקע כללי של הגוף לדשא כהה ועמוק */
            background-color: #385138; 
            background-image: linear-gradient(135deg, #4f6e4f 25%, #385138 75%);
            color: #e9e9f4;
            font-family: 'Heebo', sans-serif;
            flex-direction: column;
            padding: 20px;
            text-align: right;
        }

        #game-container {
            /* FIXED: משנה את הכיוון הראשי כדי שהפאנל הסטטי יהיה משמאל לפאנל הדינמי */
            display: flex;
            flex-direction: row-reverse; 
            gap: 20px;
            width: 90vw;
            max-width: 900px;
            background-color: rgba(93, 64, 55, 0.9); /* Medium Brown - outer frame, slightly transparent */
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            flex-wrap: wrap;
            transition: opacity 0.5s; /* Smooth fade for cutscene */
        }

        /* NEW: Container for Board, Unit Stats, and Actions (Dynamic Content) */
        #board-and-actions-panel {
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column; /* Stack board, stats, and actions vertically */
            gap: 15px;
            margin: 0 auto;
        }

        #board-container {
            /* מוגדר כ-aspect-ratio 1/1, כך שהוא נשאר יציב יחסית לגודלו */
            width: 100%;
            aspect-ratio: 1 / 1; 
            border: none;
            box-shadow: none;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            background-color: transparent;
            overflow: hidden;
            position: relative; 
        }

        /* ------------------------------------------- */
        /* FLOATING FORECAST POPUP STYLING (NEW) */
        /* ------------------------------------------- */
        #forecast-popup {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 100;
            background-color: rgba(62, 39, 35, 0.95); /* Dark Brown/Maroon */
            color: #fff;
            padding: 8px;
            border-radius: 6px;
            border: 2px solid #ffc107; /* Gold border */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            pointer-events: none; /* Ignore mouse events for click-through to tile */
            display: none;
            text-align: center;
            font-size: 0.9rem;
            min-width: 120px;
            transition: opacity 0.1s;
            transform: translate(10px, -50%); /* Move slightly away from the tile */
        }
        #forecast-popup h4 {
            margin: 0;
            font-size: 1em;
            color: #ffeb3b;
            border-bottom: 1px solid #795548;
            padding-bottom: 3px;
        }
        #forecast-popup p {
            margin: 3px 0;
            line-height: 1.2;
        }

        .tile {
            border: none; /* הסרת גבול האריח */
            background-color: #558B2F; /* Richer, darker base grass */
            /* UPDATED: Grass texture simulating earth and foliage */
            background-image: linear-gradient(135deg, #689f38 25%, #4caf50 50%, #558b2f 75%); 
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5); /* Inner shadow for depth */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: background-color 0.15s, transform 0.1s;
            position: relative; 
        }
        
        .tile:hover:not(.highlight) {
            background-color: #689f38; /* Brighter green hover */
        }

        /* Unit Icon - Base Styling (No change) */
        .unit-icon {
            font-size: 2.5rem;
            width: 80%;
            height: 80%;
            text-shadow: none;
            position: absolute; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); 
            transition: transform 0.15s ease-out, font-size 0.3s ease-out; 
            z-index: 10;
        }

        .unit-icon svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.5));
        }
        
        /* NEW: Small HP Bar for units on the board */
        .hp-bar {
            position: absolute;
            bottom: 5px; /* מיקום בתחתית האריח */
            width: 80%; /* רוחב הפס */
            height: 6px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            z-index: 10; /* מעל האריח, מתחת לאייקון (האייקון כבר ב-z-index 10) */
            overflow: hidden;
        }
        .hp-fill {
            height: 100%;
            transition: width 0.3s;
            border-radius: 2px;
        }

        /* UPDATED: Player HP is dark green */
        .hp-player { 
            background-color: #388E3C; /* Darker Green for better contrast/theme */
        }
        /* UPDATED: Change enemy HP color to a strong red */
        .hp-enemy {
            background-color: #D32F2F; /* Strong red for enemy contrast */
        }

        /* Battle Overlay (No change) */
        #battle-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #558B2F; 
            background-image: linear-gradient(135deg, #689f38 25%, #4caf50 50%, #558b2f 75%); 
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: row;
            z-index: 1000;
            gap: 10%;
        }

        .overlay-unit-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            position: relative;
            transform: scale(1); 
            transition: transform 0.1s ease-out;
        }
        
        .overlay-unit-icon {
            width: 250px; 
            height: 250px;
            transition: transform 0.1s ease-out;
        }

        .overlay-defender .overlay-unit-icon {
            transform: scaleX(-1); 
        }
        
        .overlay-unit-icon svg {
            width: 100%;
            height: 100%;
            stroke-width: 1px;
            filter: drop-shadow(0 0 8px rgba(0, 0, 0, 0.9));
        }

        /* Animations (No change) */
        @keyframes shake {
            0% { transform: translate(10px, 0); }
            25% { transform: translate(-10px, 0); }
            50% { transform: translate(10px, 0); }
            75% { transform: translate(-10px, 0); }
            100% { transform: translate(0, 0); }
        }
        
        .overlay-hp-bar {
            width: 300px;
            height: 25px;
            border: 2px solid #fff;
            margin-top: 15px;
            border-radius: 5px;
            overflow: hidden;
        }
        .overlay-hp-fill {
            height: 100%;
            transition: width 0.3s;
        }
        /* UPDATED: Player HP is dark green */
        .overlay-hp-player { background-color: #388E3C; } 
        /* UPDATED: Enemy HP is bright red */
        .overlay-hp-enemy { background-color: #D32F2F; }
        
        /* Unit Colors (No change) */
        .player-unit { color: #4CAF50; } 
        .enemy-unit { color: #f44336; } 
        
        /* Highlight States (No change) */
        .highlight-move {
            background-color: rgba(70, 160, 70, 0.8); 
            border: 2px solid #32cd32; 
            animation: pulse-move 1s infinite alternate;
        }
        .highlight-attack {
            background-color: rgba(255, 69, 0, 0.8); 
            border: 2px solid #ff4500; 
            animation: pulse-attack 1s infinite alternate;
        }
        .selected {
            border: 3px solid #ffeb3b;
            transform: scale(0.95);
        }

        @keyframes pulse-move {
            from { box-shadow: 0 0 5px rgba(50, 200, 50, 0.8); }
            to { box-shadow: 0 0 15px rgba(50, 200, 50, 1); }
        }
        @keyframes pulse-attack {
            from { box-shadow: 0 0 5px rgba(255, 69, 0, 0.8); }
            to { box-shadow: 0 0 15px rgba(255, 69, 0, 1); }
        }

        /* Static Info Panel (Side Panel - renamed from #info-panel in HTML) */
        #static-info-panel {
            width: 100%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        /* Main Controls (Only Restart & Story) */
        #main-controls {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            border-bottom: 2px solid #795548;
            flex-wrap: wrap; 
            flex-direction: column; /* Force stack in the side panel for prominence */
        }
        
        .main-control-btn {
            flex-grow: 1;
            min-width: 120px;
            width: 100%; /* Default to full width in stack */
            margin-bottom: 5px;
        }
        
        /* NEW: Styling for END_TURN_BTN to be prominent at the top of the side panel */
        #end-turn-btn {
            order: -1; /* Place it at the top of the flex container */
            background-color: #f44336; 
            color: white;
        }
        #end-turn-btn:hover:not(:disabled) { background-color: #ff7043; }

        #restart-btn {
            background-color: #ff9800 !important;
            flex-grow: 1;
        }
        
        #toggle-story-btn {
            background-color: #5d4037;
            color: white;
            flex-grow: 1;
        }
        #toggle-story-btn:hover { background-color: #795548; }

        /* Game Status (No change) */
        #game-status {
            background-color: #3e2723;
            padding: 15px;
            border-left: 5px solid #ffc107; 
            border-radius: 8px;
        }

        /* Unit Stats and Actions (Now dynamic, moved under the board) */
        #unit-stats {
            background-color: #3e2723;
            padding: 15px;
            border-radius: 8px;
            min-height: 180px; 
            border-right: 5px solid #4CAF50; 
        }

        /* NEW: Style for the unit icon inside the stats panel */
        #selected-unit-details .unit-icon {
            position: relative;
            transform: none;
            top: auto;
            left: auto;
            width: 100%;
            height: 100%;
            font-size: 3rem; /* Make it smaller inside the panel */
        }
        
        /* UPDATED: Action buttons container */
        #action-buttons {
            display: flex; 
            gap: 10px;
            margin-top: -10px;
            flex-wrap: wrap; 
        }

        #upgrade-shop {
            background-color: #5d4037; 
            padding: 15px; 
            border-radius: 8px; 
            border-right: 5px solid #ffc107;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Story Panel (Now dynamic content) */
        #story-panel {
            background-color: #3e2723;
            padding: 15px;
            border-radius: 8px;
            border-bottom: 5px solid #795548;
            display: none; 
            max-height: 400px;
            overflow-y: auto;
        }
        #story-panel h2, #story-panel h3 {
            color: #ffc107;
            margin-top: 5px;
        }
        #story-panel ul {
            padding-right: 20px;
        }

        .action-btn {
            background-color: #ffc107; 
            color: #3e2723;
            border: none;
            padding: 10px 15px;
            font-weight: 700;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            flex-grow: 1; 
        }
        .action-btn:hover:not(:disabled) { background-color: #ffeb3b; }
        .action-btn:disabled { background-color: #795548; cursor: not-allowed; } 
        
        
        /* Mobile Layout */
        @media (max-width: 900px) {
            #game-container {
                flex-direction: column; /* Stack panels vertically */
                align-items: center;
                gap: 15px;
            }
            /* הלוח והפעולות יופיעו קודם, אחריהם המידע הסטטי */
            #board-and-actions-panel {
                order: 1;
            }
            #static-info-panel {
                order: 2;
                max-width: 100%;
            }
            #board-container {
                margin: 0;
            }
            
            /* On mobile, stack all 3 main controls */
            #main-controls {
                flex-direction: column; 
            }
            .main-control-btn {
                width: 100%; 
            }
            #end-turn-btn {
                order: -1; 
                margin-bottom: 5px;
            }
            /* Action buttons under the map still flow inline/wrap */
            #action-buttons {
                margin-top: 5px;
            }
        }
    </style>
</head>
<body>
    <h1>מפקד הממלכה: קרב ימי הביניים</h1>
    <div id="game-container">
        
        <!-- NEW: פאנל ללוח, סטטוס יחידה וכפתורי פעולה (התוכן הדינמי) -->
        <div id="board-and-actions-panel">
            
            <!-- לוח המשחק -->
            <div id="board-container">
                <!-- NEW: Floating Damage Forecast Popup -->
                <div id="forecast-popup" style="display: none;"></div>
                <!-- אריחים ייווצרו כאן -->
            </div>

            <!-- סטטוס יחידה נבחרת -->
            <div id="unit-stats">
                <h2>יחידה נבחרת</h2>
                <!-- NEW: פאנל פנימי שיכיל את הסטטוס והאייקון, ויכול להיות מוסתר -->
                <div id="selected-unit-details" style="display: none;">
                    <p id="selected-unit-info">בחר יחידה מהלוח...</p>
                </div>
            </div>
            
            <!-- כפתורי פעולה (ללא סיום תור) -->
            <div id="action-buttons">
                <!-- יחידות פעולה -->
                <button id="move-btn" class="action-btn" disabled>תזוזה</button>
                <button id="attack-btn" class="action-btn" disabled>התקפה</button>
            </div>
        </div>


        <!-- NEW: פאנל מידע סטטי (סטטוס, חנות, סיפור) -->
        <div id="static-info-panel">
            
            <!-- Main Controls (כולל כעת סיום תור) -->
            <div id="main-controls">
                <!-- END_TURN_BTN is placed here and styled with order:-1 to be first -->
                <button id="end-turn-btn" class="action-btn main-control-btn" disabled>סיום תור &gt;&gt;</button>
                <button id="restart-btn" class="action-btn main-control-btn" disabled>איפוס התקדמות והתחלה מחדש</button>
                <!-- Story Toggle Button -->
                <button id="toggle-story-btn" class="action-btn main-control-btn">סיפור ומדריך</button>
            </div>
            
            <!-- Story Panel - התוכן נוצר כעת על ידי JavaScript -->
            <div id="story-panel">
                <!-- Story content will be dynamically inserted here -->
            </div>


            <div id="game-status">
                <h2>סטטוס המשחק</h2>
                <p id="status-message">טוען נתונים. נא להמתין...</p>
                <p id="gold-display">זהב: 0</p>
                <p id="turn-display">תור: -</p>
            </div>

            
            <!-- Upgrade Shop (Hidden until victory) -->
            <div id="upgrade-shop" style="display: none;">
                <h2>חנות שדרוגי ציוד וגיוס</h2>
                <div id="upgrade-controls" style="display: flex; gap: 10px; flex-direction: column;">
                    
                    <!-- NEW: גיוס יחידות -->
                    <h3 style="color:#FFF;">גיוס יחידות חדשות (רכישה חד פעמית)</h3>
                    <button id="recruit-spearman" class="action-btn upgrade-btn" style="background-color: #64B5F6;">גיוס לוחם מגן (+$2000 | HP גבוה, הגנה 12, טווח תנועה 1)</button>
                    <!-- NEW: Elven Ranger - Available after Battle 2 -->
                    <button id="recruit-elfRanger" class="action-btn upgrade-btn" style="background-color: #8BC34A;">גיוס סייר אלפים (+$2100 | טווח 2, טווח תנועה 4, נחשף בקרב 3+)</button>
                    <button id="recruit-mage" class="action-btn upgrade-btn" style="background-color: #9C27B0;">גיוס מכשף (+$2200 | טווח 2, **התקפה 40**, טווח תנועה 4)</button>
                    <!-- NEW: Demon Archer - Available after Battle 3 -->
                    <button id="recruit-demonArcher" class="action-btn upgrade-btn" style="background-color: #C62828;">גיוס קשת שד (+$2500 | טווח 4, התקפה 40, איטיות 8, נחשף בקרב 4+)</button>


                    <h3 style="color:#FFF; margin-top: 10px;">שדרוגי אביר</h3>
                    <!-- אביר - שדרוג נשק ושריון -->
                    <button id="buy-knight-iron-sword" class="action-btn upgrade-btn">אביר: חרב ברזל (+$1500 | +10 התקפה)</button>
                    <!-- NEW: חרב פלדה -->
                    <button id="buy-knight-steel-sword" class="action-btn upgrade-btn">אביר: חרב פלדה (+$2500 | רמה 3+ | +20 התקפה, +1 טווח)</button>
                    <button id="buy-knight-steel-armor" class="action-btn upgrade-btn">אביר: שריון פלדה (+$2000 | רמה 3+ | +50 חיים, +5 הגנה)</button>
                    
                    <h3 style="color:#FFF; margin-top: 10px;">שדרוגי קשת</h3>
                    <!-- קשת - שדרוג נשק וחפץ מיוחד -->
                    <button id="buy-archer-iron-bow" class="action-btn upgrade-btn">קשת: קשת ברזל (+$1800 | +15 התקפה)</button>
                    <button id="buy-archer-steel-bow" class="action-btn upgrade-btn">קשת: קשת פלדה (+$2500 | רמה 3+ | +20 התקפה, +1 טווח)</button>
                    <button id="buy-archer-move" class="action-btn upgrade-btn">קשת: מגפי עור (+$1500 | +1 טווח תנועה)</button>
                    
                    <!-- NEW: שדרוגי לוחם מגן -->
                    <h3 style="color:#FFF; margin-top: 10px;">שדרוגי לוחם מגן (Spearman)</h3>
                    <button id="buy-spearman-shield" class="action-btn upgrade-btn">לוחם מגן: מגן פלדה (+$1800 | +30 חיים, +10 הגנה)</button>

                    <!-- NEW: שדרוגי מכשף -->
                    <h3 style="color:#FFF; margin-top: 10px;">שדרוגי מכשף (Mage)</h3>
                    <!-- UPDATED: השרביט נותן ATK 15 -->
                    <button id="buy-mage-staff" class="action-btn upgrade-btn">מכשף: שרביט עוצמתי (+$2800 | +15 התקפה, +1 טווח תנועה, +1 טווח תקיפה)</button>
                    <button id="buy-mage-robe" class="action-btn upgrade-btn">מכשף: גלימת ארכאון (+$1600 | +20 חיים, +3 הגנה)</button>
                    
                    <!-- NEW: שדרוגי סייר אלפים -->
                    <h3 style="color:#FFF; margin-top: 10px;">שדרוגי סייר אלפים (Elf Ranger)</h3>
                    <button id="buy-elfRanger-daggers" class="action-btn upgrade-btn">סייר: פגיונות רעל (+$2300 | +15 התקפה)</button>
                    <button id="buy-elfRanger-move" class="action-btn upgrade-btn">סייר: גלימת ציידים (+$1500 | +1 טווח תנועה)</button>
                    
                    <!-- NEW: שדרוגי קשת שד -->
                    <h3 style="color:#FFF; margin-top: 10px;">שדרוגי קשת שד (Demon Archer)</h3>
                    <button id="buy-demonArcher-bow" class="action-btn upgrade-btn">קשת שד: קשת אפלה (+$3500 | +15 התקפה, +1 טווח תקיפה)</button>
                    <button id="buy-demonArcher-amulet" class="action-btn upgrade-btn">קשת שד: תליון השהייה (+$1800 | +20 חיים, +1 טווח תנועה)</button>


                </div>
            </div>

        </div>
    </div>

    <!-- NEW: Battle Overlay Container -->
    <div id="battle-overlay">
        <div id="overlay-attacker" class="overlay-unit-slot">
            <!-- Attacker info goes here -->
        </div>
        <div id="overlay-defender" class="overlay-unit-slot">
            <!-- Defender info goes here -->
        </div>
    </div>

    <script>
        // משתנים גלובליים ואלמנטי DOM
        const GAME_CONTAINER = document.getElementById('game-container');
        const BOARD_CONTAINER = document.getElementById('board-container');
        const FORECAST_POPUP = document.getElementById('forecast-popup'); // NEW
        const STATUS_MESSAGE = document.getElementById('status-message');
        const GOLD_DISPLAY = document.getElementById('gold-display');
        const TURN_DISPLAY = document.getElementById('turn-display');
        
        // NEW: עטיפה לפרטי היחידה
        const SELECTED_UNIT_DETAILS = document.getElementById('selected-unit-details');
        const SELECTED_UNIT_INFO = document.getElementById('selected-unit-info');

        const MOVE_BTN = document.getElementById('move-btn'); 
        const ATTACK_BTN = document.getElementById('attack-btn'); 
        const END_TURN_BTN = document.getElementById('end-turn-btn');
        const RESTART_BTN = document.getElementById('restart-btn');
        const UPGRADE_SHOP = document.getElementById('upgrade-shop'); 
        
        // NEW: Story Panel DOM
        const STORY_PANEL = document.getElementById('story-panel');
        const TOGGLE_STORY_BTN = document.getElementById('toggle-story-btn');
        
        // New Overlay Elements
        const BATTLE_OVERLAY = document.getElementById('battle-overlay');
        const OVERLAY_ATTACKER = document.getElementById('overlay-attacker');
        const OVERLAY_DEFENDER = document.getElementById('overlay-defender');


        // משתני משחק
        const BOARD_SIZE = 5;
        let board = [];
        let units = [];
        let selectedUnit = null; // היחידה שנבחרה לצפייה (יכולה להיות אויב או שחקן)
        let lastPlayerUnit = null; // היחידה האחרונה של השחקן שנבחרה לפעולה (נשמרת עבור תחזית)
        let pendingTarget = null; // היעד הנוכחי להמתנה לאישור תקיפה (NEW)
        let initialMovePosition = null; // NEW: שומר את המיקום ההתחלתי לפני התזוזה
        let gameState = 'loading'; // loading, deployment, ready, playerTurn, enemyTurn, gameOver, animating, upgradePhase
        let currentTurn = 0;
        let isReady = false; // דגל טעינת Firebase
        let gold = 0;
        let goldHighScore = 0;
        // NEW: עוקב אחרי באיזה קרב השחקן נמצא (1, 2, 3...)
        let currentBattleIndex = 1; 
        
        let unitsToDeploy = []; // Queue of player units needing placement
        let deployingUnit = null; // The unit currently selected to be placed
        const DEPLOYMENT_ROWS = [3, 4]; // Rows available for deployment


        // NEW: שמירת שדרוגי ציוד קבועים (Items) - כולל יחידות מגויסות חדשות
        let itemUpgrades = {
            knight: { hp: 0, atk: 0, def: 0, move: 0, range: 0 },
            archer: { hp: 0, atk: 0, def: 0, move: 0, range: 0 },
            spearman: { hp: 0, atk: 0, def: 0, move: 0, range: 0 },
            mage: { hp: 0, atk: 0, def: 0, move: 0, range: 0 },
            elfRanger: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, // NEW
            demonArcher: { hp: 0, atk: 0, def: 0, move: 0, range: 0 } // NEW DEMON ARCHER
        };
        // NEW: שמירת נתוני רמה/XP - כולל סטטוס גיוס (ובהמשך גם מיקום אחרון)
        let unitProgress = {}; // יטען ויאופס ע"י defaultUnitProgress

        // NEW: אובייקט ברירת המחדל המלא לאיפוס
        function createDefaultUnitProgress() {
            return {
                knight: { level: 1, xp: 0, nextLevelXp: 1000, recruited: true, lastPosition: { row: -1, col: -1 } },
                archer: { level: 1, xp: 0, nextLevelXp: 1000, recruited: true, lastPosition: { row: -1, col: -1 } },
                spearman: { level: 1, xp: 0, nextLevelXp: 1000, recruited: false, lastPosition: { row: -1, col: -1 } },
                mage: { level: 1, xp: 0, nextLevelXp: 1000, recruited: false, lastPosition: { row: -1, col: -1 } },
                elfRanger: { level: 1, xp: 0, nextLevelXp: 1000, recruited: false, lastPosition: { row: -1, col: -1 } },
                demonArcher: { level: 1, xp: 0, nextLevelXp: 1000, recruited: false, lastPosition: { row: -1, col: -1 } }
            };
        }


        // קבוע עבור מתקפה כפולה מבוססת מהירות - סף מופחת ל-5
        // UPDATED: הגדרת ספי המתקפות המרובות
        const SPEED_THRESHOLD_DOUBLE = 5; 
        const SPEED_THRESHOLD_TRIPLE = 8;
        const SPEED_THRESHOLD_QUADRUPLE = 10; 

        // מצבי פעולה - כבר לא משתמשים בו בצורה מפורשת עבור ה-UI
        let currentAction = null; 
        
        // ------------------------------------
        // קטעי סיפור ולור - נחשפים לאט לאט
        // ------------------------------------
        const loreSegments = {
            // Stage 1: Before Battle 1 (The Initial Plight)
            1: {
                title: "ההתחלה: קרב הדרור הראשון",
                lore: `<p>ממלכת הדרור, שפעם הייתה נחלת שלווה המוגנת על ידי חומות עתיקות, עומדת כעת בפני מבחן. בעקבות גילוי עורק נדיר של <strong>זהב קסום</strong> בהרי צפון, התעוררו ישויות רעבות ותאבות בצע.</p>
                        <p>אתה, המפקד הצעיר של חיל המצב, נותרת עם שניים בלבד מהלוחמים הנאמנים ביותר: <strong>האביר</strong> ו<strong>הקשת</strong>. זה הקרב הראשון שלכם על הגנת הבסיס. זהו רק משמר קדמי של שודדים, אך היכולות שלהם עלולות להפתיע.</p>`,
                guide: `<h3>מדריך: חוקי בסיס</h3>
                        <ul>
                            <li>כל יחידה שחקן יכולה לבצע <strong>תזוזה אחת</strong> ו<strong>התקפה אחת</strong> בתור.</li>
                            <li><strong>טווח תנועה:</strong> מספר האריחים המקסימלי למהלך (במצטבר).</li>
                            <li><strong>טווח התקפה:</strong> מרחק המטרה מהיחידה.</li>
                            <li><strong>מצב שדרוג:</strong> לאחר ניצחון בקרב, ה-HP מתמלא במלואו, ואתה עובר לחנות (Upgrade Shop) לרכישת ציוד, גיוס או שדרוג רמות.</li>
                            <li><strong>שמירת מיקום:</strong> היחידות שנפרסו ייזכרו את מיקומן לקרב הבא.</li>
                        </ul>`
            },
            // Stage 2: After Battle 1 (New Threat Revealed - Ranged Units)
            2: {
                title: "האויב לומד: איום הקשתים",
                lore: `<p>הדיפתם את גל האורקים הראשון! אך מרחוק, זיהינו קשתים שודדים שמתקרבים דרך העמקים הצדדיים. האויב לומד את הטקטיקה שלך ומנסה לשבור את קו החזית שלך עם יחידות לטווח רחוק.</p>
                        <p><strong>טיפ גיוס:</strong> יש שמועות על <strong>לוחם מגן (Spearman)</strong> שאולי תוכל לגייס. הוא מגן חזק שיכול לשמש כחומה נגד יחידות מליאה, אך דורש עבודה טקטית בגלל טווח התנועה המוגבל שלו.</p>`,
                guide: `<h3>חוקי בסיס</h3>
                        <ul>
                            <li><strong>התקפה:</strong> הנזק מחושב כך: (התקפת תוקף) - (הגנת מגן) = נזק מינימלי של 1.</li>
                            <li><strong>עליית רמה (XP):</strong> השמדת אויב מעניקה XP. עלייה ברמה מגדילה אוטומטית את ה-HP, ההתקפה וההגנה הבסיסיים.</li>
                            <li><strong>התקדמות ברמות:</strong> רמות גבוהות יותר (מדרגה 3) פותחות גישה לציוד **פלדה** חזק בחנות!</li>
                        </ul>`
            },
            // Stage 3: After Battle 2 (The Growing Horde - Magic Threat)
            3: {
                title: "חומות הברזל: כוח חדש?",
                lore: `<p>ניצחון קשה נגד תגבורת האויב. המפקדים המנוסים יותר של האורקים מגיעים לשטח, והם נעים בצורה מתוכננת יותר. ההגנות שלך חזקות, אבל כוח אש חזק יותר ידרש בקרוב. </p>
                        <p><strong>טיפ גיוס:</strong> בדרכים נתקלנו ב<strong>מכשף נודד (Mage)</strong> בעל כוח אש מדהים, אך הוא שביר כמו קליפת ביצה. הוא יקר לגיוס, אבל הנזק שלו עשוי להפוך את הקרב הבא לפשוט יותר.</p>
                        <p><strong>גיוס חדש:</strong> שמענו על יחידת <strong>סייר אלפים</strong> המתמחה בתנועה מהירה ויכולה לסייע בהגנה על האגפים. גיוס יחידות נוספות נפתח עכשו! </p>`,
                guide: `<h3>חוקי בסיס: טקטיקה מתקדמת</h3>
                        <ul>
                            <li><strong>מתקפה כפולה:</strong> הפרש של <strong>5</strong> מהירות = 2 התקפות. <strong>8</strong> מהירות = 3 התקפות. <strong>10</strong> מהירות = 4 התקפות.</li>
                            <li><strong>התקפת מטווח:</strong> קשתות ומכשפים יכולים לתקוף יחידות ממרחק. <strong>אביר</strong> יכול לשמש כהגנה על יחידות שבריריות יותר.</li>
                            <li><strong>מיקום:</strong> השתמשו בלוח בצורה חכמה. יחידות קשת נמצאות בטוחות יותר בשורה האחורית (4) בזמן שהאבירים מחפים עליהן בשורה הקדמית.</li>
                        </ul>`
            },
            // Stage 4: After Battle 3 (The Long War)
            4: {
                title: "המערכה המתארכת: כוחות העומק והשדים",
                lore: `<p>ניצחתם את גל התקיפה הגדול ביותר עד כה, אבל נראה שהאויב אינו נגמר. נתקלנו ביחידת <strong>קשת שד (Demon Archer)</strong> איטית אך קטלנית בעלת טווח תקיפה עצום. נדרשת הגנה מיידית על היחידות הרכות.</p>
                        <p><strong>גיוס חדש:</strong> אם הצלחתם לשרוד את הגל השלישי, ייתכן שתוכלו לגייס את קשת השד עצמה! כוח האש שלה חיוני נגד האויבים המתבצרים. כל קרב עולה בדרגת הקושי, והרמה הממוצעת של האויבים תמשיך לעלות. המשך לאגור זהב, המפקד!</p>`,
                guide: `<h3>חוקי בסיס: תזכורת</h3>
                        <ul>
                            <li><strong>שמירה:</strong> כל ההתקדמות (זהב, רמות, גיוסים, מיקומי יחידות) נשמרת אוטומטית ב-Firestore.</li>
                            <li><strong>מטרה:</strong> השמד את כל יחידות האויב כדי להתקדם לחנות השדרוג ולקרב הבא.</li>
                        </ul>`
            }
        };

        function generateStoryContent() {
            // הצגת כל הסיפורים שנחשפו עד כה
            const battlesWon = Math.max(0, currentBattleIndex - 1);
            const segmentsToShow = battlesWon + 1;
            
            let fullHtml = '<h2>סיפור רקע ומדריך: מפקד הממלכה</h2>';
            
            for (let i = 1; i <= segmentsToShow; i++) {
                const segment = loreSegments[i] || loreSegments[4]; // השתמש בסיפור 4 כברירת מחדל להמשך
                
                fullHtml += `<div style="margin-bottom: 20px; border-bottom: 1px solid #795548; padding-bottom: 10px;">
                                <h3>${i}. ${segment.title}</h3>
                                ${segment.lore}
                                ${i === segmentsToShow ? segment.guide : ''} <!-- הצג מדריך רק עבור הסיפור האחרון שנפתח -->
                            </div>`;
            }
            
            STORY_PANEL.innerHTML = fullHtml;
        }


        // ------------------------------------
        // פונקציות עזר (Utility)
        // ------------------------------------
        function getUnitName(type) {
             switch(type) {
                case 'knight': return 'אביר';
                case 'archer': return 'קשת';
                case 'spearman': return 'לוחם מגן';
                case 'mage': return 'מכשף';
                case 'elfRanger': return 'סייר אלפים';
                case 'demonArcher': return 'קשת שד';
                // Enemies
                case 'orc': return 'אורק';
                case 'bandit': return 'שודד';
                case 'banditArcher': return 'קשת שודד';
                case 'goblin': return 'גובלין';
                default: return 'יחידה לא ידועה';
            }
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // NEW: פונקציה לחישוב בונוס סטטוס לפי רמה
        function calculateLevelBonus(unitType, level) {
            // סטטיסטיקות בסיס (Level 1)
            let baseHp, baseAtk, baseDef, baseMove, baseRange, baseSpeed;
            
            switch (unitType) {
                case 'knight':
                    // גזע: אדם (מאוזן). יתרון: יכולת צמיחה חזקה.
                    baseHp = 120; baseAtk = 30; baseDef = 10; baseMove = 2; baseRange = 1; baseSpeed = 10; break; 
                case 'archer':
                    // גזע: אדם (צייד). יתרון: טווח תנועה טוב ומהירות גבוהה.
                    baseHp = 80; baseAtk = 20; baseDef = 5; baseMove = 3; baseRange = 3; baseSpeed = 15; break; 
                case 'spearman': 
                    // גזע: אדם (מגן כבד). יתרון: הגנה וחיים גבוהים. חיסרון: תנועה איטית והתקפה חלשה.
                    baseHp = 140; baseAtk = 15; baseDef = 12; baseMove = 1; baseRange = 1; baseSpeed = 5; break; // UPDATED ATK
                case 'mage': 
                    // גזע: מיסטיקן (תותח זכוכית). יתרון: התקפה אדירה. חיסרון: 0 הגנה וחיים נמוכים.
                    baseHp = 60; baseAtk = 40; baseDef = 0; baseMove = 4; baseRange = 2; baseSpeed = 15; break; 
                case 'elfRanger':
                    // גזע: אלף (סייר זריז). יתרון: מהירות ותנועה קיצונית. חיסרון: שברירי (HP/DEF נמוכים).
                    baseHp = 60; baseAtk = 25; baseDef = 3; baseMove = 4; baseRange = 2; baseSpeed = 18; break; // UPDATED HP & DEF
                case 'demonArcher':
                    // גזע: שד (קשת כבד). יתרון: טווח תקיפה גבוה, כוח אש. חיסרון: איטיות קיצונית וטווח תנועה מוגבל.
                    baseHp = 90; baseAtk = 40; baseDef = 5; baseMove = 1; baseRange = 4; baseSpeed = 8; break; // UPDATED ATK
                
                // Enemy units (Orc, Bandit, Goblin) remain as is, they get their flavor through leader bonuses
                case 'orc': 
                    // גזע: אורק. חיסרון: איטי יחסית.
                    baseHp = 100; baseAtk = 25; baseDef = 8; baseMove = 2; baseRange = 1; baseSpeed = 10; break;
                case 'bandit':
                    // גזע: שודד. יתרון: מהירות בינונית-גבוהה.
                    baseHp = 80; baseAtk = 20; baseDef = 5; baseMove = 2; baseRange = 1; baseSpeed = 12; break; 
                case 'banditArcher': 
                    // גזע: קשת שודד. יתרון: טווח.
                    baseHp = 60; baseAtk = 18; baseDef = 3; baseMove = 3; baseRange = 3; baseSpeed = 12; break;
                case 'goblin': 
                    // גזע: גובלין. יתרון: מהירות קיצונית. חיסרון: שבריריות מוחלטת.
                    baseHp = 40; baseAtk = 15; baseDef = 0; baseMove = 4; baseRange = 1; baseSpeed = 22; break;
                default:
                    baseHp = 80; baseAtk = 20; baseDef = 5; baseMove = 2; baseRange = 1; baseSpeed = 10; break;
            }
            
            // פקטור צמיחה (לכל רמה נוספת מעבר ל-1)
            const levelFactor = level - 1;
            
            const totalHp = baseHp + (levelFactor * 10); // צמיחת חיים מהירה יותר
            const totalAtk = baseAtk + (levelFactor * 3);  // צמיחת התקפה
            const totalDef = baseDef + (levelFactor * 1);
            
            // Speed (baseSpeed) is constant by unit type, not affected by level or moveRange upgrades
            let totalSpeed = baseSpeed;
            
            // NEW: Speed increases with level only for Player units (every 3 levels)
            if (unitType === 'knight' || unitType === 'archer' || unitType === 'spearman' || unitType === 'mage' || unitType === 'elfRanger' || unitType === 'demonArcher') {
                // מקבל +1 מהירות על כל 3 רמות
                const speedBonus = Math.floor(levelFactor / 3);
                totalSpeed = baseSpeed + speedBonus;
            }


            return { totalHp, totalAtk, totalDef, baseMove, baseRange, totalSpeed };
        }
        
        // ------------------------------------
        // הגדרת אייקוני SVG (במקום אימוג'י) - פיקסל ארט משופר
        // ------------------------------------
        // UPDATED: הוספת isLeader ל-SVG לסימון חזותי
        function getUnitSVG(type, isLeader = false) {
            
            const SILVER = '#B0B0B0';
            const WHITE = '#FFFFFF';
            const DARK_STEEL = '#606060';
            const WOOD = '#795548';
            const LIGHT_WOOD = '#A1887F';
            const SKIN = '#F0D4A8';
            const ORC_SKIN = '#558B2F';
            const ORC_TEETH = '#FFFFFF';
            const RED = '#F44336';
            const BLACK_GARB = '#1a1a1a'; 
            const MAROON_ACCENT = '#5C3333'; 
            const BRONZE_LIGHT = '#D4A017'; // Lighter Bronze for highlights
            const MAGE_ROBE = '#9C27B0'; // Purple for Mage robe
            const MAGE_ACCENT = '#FFEB3B'; // Gold/Yellow for Mage trim
            const DEMON_COLOR = '#880E4F'; // Deep Maroon/Demon Red
            const DEMON_HORN = '#FFD54F'; // Yellow/Gold Horns
            
            let svgContent = '';
            
            switch (type) {
                case 'knight':
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Armor (Silver base) -->
                            <rect x="3" y="4" width="4" height="6" fill="${SILVER}"/>
                            <!-- Chest Accent is now Bronze highlight -->
                            <rect x="3.5" y="4" width="3" height="1" fill="${BRONZE_LIGHT}"/> 
                            
                            <!-- Right Arm/Shoulder - REMOVED the extra silver block to clean up the outline -->
                            <rect x="7.5" y="5.5" width="0.5" height="0.5" fill="${SKIN}"/> <!-- Exposed Hand/Skin -->
                            
                            <!-- Helmet (Dark Steel) -->
                            <rect x="3" y="1.5" width="4" height="3" fill="${DARK_STEEL}"/>
                            
                            <!-- Exposed Face (SKIN) -->
                            <rect x="4" y="3.5" width="2" height="1" fill="${SKIN}"/> 
                            
                            <rect x="4.5" y="2.5" width="1" height="1" fill="${SILVER}"/> <!-- Visor/Light reflection -->
                            <!-- Sword (Silver) -->
                            <rect x="7" y="2" width="1" height="4" fill="${SILVER}"/>
                            <rect x="6.5" y="5" width="2" height="1" fill="${DARK_STEEL}"/> <!-- Guard -->
                            <!-- Shield (Silver) -->
                            <rect x="2" y="4" width="1" height="4" fill="${SILVER}"/>
                        </svg>`;
                    break;
                case 'spearman':
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Armor (Silver base) -->
                            <rect x="3" y="4" width="4" height="6" fill="${SILVER}"/>
                            <!-- Helmet (Dark Steel) -->
                            <rect x="3" y="1.5" width="4" height="3" fill="${DARK_STEEL}"/>
                            <!-- Face peek (Skin) -->
                            <rect x="4" y="3.5" width="2" height="1" fill="${SKIN}"/> 
                            
                            <!-- LARGE Shield (Dominant feature, covering front) -->
                            <rect x="1" y="3.5" width="2.5" height="5" fill="#4CAF50"/> <!-- Green Shield -->
                            <rect x="1.5" y="5.5" width="1.5" height="1" fill="${BRONZE_LIGHT}"/> <!-- Central Boss -->

                            <!-- Melee Weapon (Mace/Club on side) -->
                            <rect x="7" y="5" width="1" height="4" fill="${WOOD}"/>
                            <circle cx="7.5" cy="4.5" r="0.5" fill="${DARK_STEEL}"/> <!-- Mace Head -->
                        </svg>`;
                    break;
                case 'mage':
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Robe (Purple) -->
                            <rect x="3.5" y="3.5" width="3" height="6.5" fill="${MAGE_ROBE}"/>
                            <!-- Hood/Head (Purple) -->
                            <rect x="3" y="1.5" width="4" height="2" fill="${MAGE_ROBE}"/>
                            <!-- Face peek (Skin) -->
                            <rect x="4.5" y="2.5" width="1" height="1" fill="${SKIN}"/>
                            
                            <!-- Gold Trim/Accent -->
                            <rect x="3.5" y="3.5" width="3" height="0.5" fill="${MAGE_ACCENT}"/>
                            
                            <!-- Staff (Held high) -->
                            <rect x="7" y="1" width="0.5" height="8" fill="${WOOD}"/>
                            <!-- Staff Tip/Orb (Yellow) -->
                            <circle cx="7.25" cy="1" r="0.75" fill="${MAGE_ACCENT}"/>
                            
                            <!-- Exposed Hand (Skin) -->
                            <rect x="6" y="4" width="1" height="1" fill="${SKIN}"/>
                        </svg>`;
                    break;
                case 'elfRanger':
                    const ELF_GREEN = '#8BC34A'; // Light Green/Elven color
                    const ELF_BROWN = '#795548'; // Wood color
                    const ELF_SKIN = '#F0D4A8';
                    const ELF_BOW = '#607D8B'; // Slate Blue/Gray bow
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Garb (Elven Green) -->
                            <rect x="4" y="4" width="2" height="6" fill="${ELF_GREEN}"/>
                            <!-- Hood/Head (Elven Green/Brown) -->
                            <rect x="4" y="2.5" width="2" height="2" fill="${ELF_BROWN}"/>
                            <!-- Face peek (Skin) -->
                            <rect x="4.5" y="3" width="1" height="1" fill="${ELF_SKIN}"/>
                            
                            <!-- Swift Bow (Vertical Stance) -->
                            <rect x="2" y="1.5" width="0.5" height="7" fill="${ELF_BOW}"/>
                            <!-- Arrow (Pulled back, held by hand) -->
                            <line x1="2.5" y1="5.5" x2="6.5" y2="5.5" stroke="${WHITE}" stroke-width="0.3"/> 
                            
                            <!-- Hand (Skin) - holding the bow string/arrow -->
                            <rect x="5.5" y="5" width="1" height="1" fill="${SKIN}"/> 
                            
                            <!-- Shoulder pads/Accent -->
                            <rect x="3.5" y="4" width="3" height="0.5" fill="${ELF_BROWN}"/> 
                        </svg>`;
                    break;
                case 'demonArcher':
                    // UPDATED: Demon Archer now uses the standard horizontal bow for consistency, but with Demon colors
                    const DEMON_BOW = '#424242'; // Dark steel/Black bow
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Robe (Demon Maroon) -->
                            <rect x="3.5" y="4" width="3" height="6" fill="${DEMON_COLOR}"/>
                            <!-- Head/Hood (Demon Maroon) -->
                            <rect x="3" y="1.5" width="4" height="3" fill="${DEMON_COLOR}"/>
                            <!-- Horns (Yellow/Gold) -->
                            <polygon points="3,1.5 3.5,0.5 4,1.5" fill="${DEMON_HORN}"/> 
                            <polygon points="7,1.5 6.5,0.5 6,1.5" fill="${DEMON_HORN}"/>
                            <!-- Eyes (Red) -->
                            <rect x="4" y="3" width="2" height="1" fill="${RED}"/>
                            
                            <!-- Bow (Horizontal - consistent with Archer) -->
                            <path d="M 1 5 Q 3.5 3.5, 6 5" fill="none" stroke="${DEMON_BOW}" stroke-width="0.5"/>
                            
                            <!-- String (White) - Longer, horizontal line drawn back - Y set to 5.3 to create space from the bow -->
                            <line x1="1" y1="5.3" x2="5.5" y2="5.3" stroke="${WHITE}" stroke-width="0.5"/> 

                            <!-- Hand (Demon Maroon) - holding the bow string/arrow -->
                            <rect x="5.5" y="4.8" width="1" height="1" fill="${DEMON_COLOR}"/> 
                        </svg>`;
                    break;
                case 'archer':
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Garb (Light Wood/Brown) -->
                            <rect x="4" y="4" width="2" height="6" fill="${LIGHT_WOOD}"/>
                            <!-- Hood/Head (Darker Brown) -->
                            <rect x="4" y="2.5" width="2" height="2" fill="${WOOD}"/>
                            <!-- Face peek (Skin) -->
                            <rect x="4.5" y="3" width="1" height="1" fill="${SKIN}"/>
                            
                            <!-- FIX 1: Wide, horizontal half-ellipse bow (brown/wood) - MODIFIED: Y control point changed to 3.5 (More Curved) -->
                            <path d="M 1 5 Q 3.5 3.5, 6 5" fill="none" stroke="${WOOD}" stroke-width="0.5"/>
                            
                            <!-- FIX 2: String (White) - Longer, horizontal line drawn back - Y set to 5.3 to create space from the bow -->
                            <line x1="1" y1="5.3" x2="5.5" y2="5.3" stroke="${WHITE}" stroke-width="0.5"/> 

                            <!-- Hand (Skin) - holding the bow string/arrow (Positioned at the end of the drawn string) - Y set to 4.8 to hold the string) -->
                            <rect x="5.5" y="4.8" width="1" height="1" fill="${SKIN}"/> 
                        </svg>`;
                    break;
                case 'banditArcher': 
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Garb (Black Garb) -->
                            <rect x="4" y="4" width="2" height="6" fill="${BLACK_GARB}"/>
                            <!-- Hood/Head (Dark Garb) -->
                            <rect x="4" y="2.5" width="2" height="2" fill="${BLACK_GARB}"/>
                            <!-- Face peek (Skin) -->
                            <rect x="4.5" y="3" width="1" height="1" fill="${SKIN}"/>
                            
                            <!-- FIX 1: Wide, horizontal half-ellipse bow (Dark Steel) -->
                            <path d="M 1 5 Q 3.5 3.5, 6 5" fill="none" stroke="${DARK_STEEL}" stroke-width="0.5"/>
                            
                            <!-- FIX 2: String (White) - Longer, horizontal line drawn back - Y set to 5.3 to create space from the bow -->
                            <line x1="1" y1="5.3" x2="5.5" y2="5.3" stroke="${WHITE}" stroke-width="0.5"/> 

                            <!-- Hand (Skin) - holding the bow string/arrow (Positioned at the end of the drawn string) - Y set to 4.8 to hold the string) -->
                            <rect x="5.5" y="4.8" width="1" height="1" fill="${SKIN}"/> 
                        </svg>`;
                    break;
                case 'orc':
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body (Orc Green, Bulky) -->
                            <rect x="2.5" y="5" width="5.5" height="5" fill="${ORC_SKIN}"/>
                            <!-- Head (Orc Green, wide) -->
                            <rect x="2" y="1.5" width="6" height="4" fill="${ORC_SKIN}"/>
                            <!-- Eyes (Red) -->
                            <rect x="3.5" y="2.5" width="1" height="1" fill="${RED}"/>
                            <rect x="5.5" y="2.5" width="1" height="1" fill="${RED}"/>
                            <!-- Tusks (White, pronounced) -->
                            <rect x="2" y="4.5" width="1" height="1" fill="${ORC_TEETH}"/>
                            <rect x="7" y="4.5" width="1" height="1" fill="${ORC_TEETH}"/>
                            <!-- Weapon (Axe Head - Silver) -->
                            <rect x="7" y="5" width="2" height="1" fill="${SILVER}"/>
                            <rect x="8" y="6" width="1" height="1" fill="${SILVER}"/>
                            <!-- Handle (Dark Steel) -->
                            <rect x="7.5" y="6" width="0.5" height="3" fill="${DARK_STEEL}"/>
                        </svg>`;
                    break;
                case 'goblin':
                    const GOBLIN_SKIN = '#689F38'; // Light Green
                    const GOBLIN_EYE = '#FFEB3B'; // Yellow eye
                    const GOBLIN_WEAPON = '#A9A9A9'; // Dark silver knife/dart
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Head (Light Green) -->
                            <rect x="3.5" y="4" width="3" height="5" fill="${GOBLIN_SKIN}"/>
                            <rect x="3" y="2.5" width="4" height="2" fill="${GOBLIN_SKIN}"/>
                            <!-- Eyes (Yellow) -->
                            <rect x="4.5" y="3" width="1" height="1" fill="${GOBLIN_EYE}"/>
                            <!-- Weapon (Small Dagger/Dart) -->
                            <rect x="6.5" y="5" width="1" height="2.5" fill="${GOBLIN_WEAPON}"/>
                            <rect x="7.5" y="4.5" width="0.5" height="1" fill="${GOBLIN_WEAPON}"/> <!-- Blade tip -->
                        </svg>`;
                    break;
                case 'bandit':
                    svgContent = `
                        <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
                            <!-- Body/Cloak (New Darker Garb) -->
                            <rect x="4" y="4" width="2" height="6" fill="${BLACK_GARB}"/>
                            <!-- Maroon Accent/Belt -->
                            <rect x="3.5" y="6" width="3" height="0.5" fill="${MAROON_ACCENT}"/>
                            <!-- Hood/Head (Dark Garb) -->
                            <rect x="3" y="2.5" width="4" height="2" fill="${BLACK_GARB}"/>
                            <!-- Face peek (Skin) -->
                            <rect x="4.5" y="3" width="1" height="1" fill="${SKIN}"/>
                            
                            <!-- Exposed Hand/Arm (Skin) -->
                            <rect x="5.5" y="4" width="1" height="1" fill="${SKIN}"/> 
                            
                            <!-- Dagger (Silver) -->
                            <rect x="6" y="3" width="1" height="3" fill="${SILVER}"/>
                            <rect x="5.5" y="5" width="2" height="0.5" fill="${DARK_STEEL}"/> <!-- Hilt -->
                        </svg>`;
                    break;
                default:
                    return `?`;
            }

            // UPDATED: הוספת סימון מנהיג (קרניים או כתר ברונזה)
            if (isLeader) {
                if (type === 'orc' || type === 'demonArcher') { // ADDED demonArcher to Orc style leader
                    // הוספת קרניים לבנות לאורק/שד
                    const headColor = type === 'orc' ? ORC_SKIN : DEMON_COLOR;
                    const orcHeadMatch = svgContent.match(new RegExp(`<rect x="2" y="1.5" width="6" height="4" fill="${headColor}"\/>`));

                    if (orcHeadMatch) {
                        svgContent = svgContent.replace(orcHeadMatch[0], `
                            <!-- LEADER: Horns (White/Gold) -->
                            <polygon points="2,1.5 3,0.5 4,1.5" fill="${type === 'orc' ? WHITE : DEMON_HORN}"/> 
                            <polygon points="8,1.5 7,0.5 6,1.5" fill="${type === 'orc' ? WHITE : DEMON_HORN}"/>
                            <rect x="2" y="1.5" width="6" height="4" fill="${headColor}"/>
                        `);
                    }
                } else if (type === 'bandit' || type === 'banditArcher') {
                    // הוספת כתר ברונזה בולט
                     const banditHeadMatch = svgContent.match(/<rect x="3" y="2.5" width="4" height="2" fill="#1a1a1a"\/>/);
                     if (banditHeadMatch) {
                         svgContent = svgContent.replace(banditHeadMatch[0], `
                             <!-- LEADER: Bandit Crown -->
                             <polygon points="3,2.5 7,2.5 5,1" fill="${BRONZE_LIGHT}"/>
                             <rect x="3" y="2.5" width="4" height="2" fill="${BLACK_GARB}"/>
                         `);
                     }
                }
            }

            return svgContent;
        }
        // ------------------------------------
        // מחלקת יחידה
        // ------------------------------------
        class Unit {
            // Units now receive base stats and apply item upgrades and level bonuses on creation
            // UPDATED: הוספת isLeader ל-Constructor
            constructor(type, team, row, col, name, xp, level, initialHpRatio = 1.0, isLeader = false) {
                this.type = type; // 'knight', 'archer', 'orc', 'bandit', 'banditArcher', 'goblin', 'elfRanger', 'demonArcher'
                this.team = team; // 'player', 'enemy'
                this.row = row;
                this.col = col;
                this.name = name;
                
                // NEW: Leader Flag
                this.isLeader = isLeader;

                // NEW: XP and Level tracking (only for player units)
                // If it's an enemy unit (type is not 'knight' or 'archer'), these default to 0/1, which is fine.
                this.level = level;
                this.xp = xp;
                this.xpToNextLevel = level * 1000;
                
                // 1. Calculate stats based on Level
                const levelStats = calculateLevelBonus(type, level);
                
                // 2. Apply permanent Item Upgrades (stored in itemUpgrades global)
                // Ensure we only try to apply item upgrades to units that actually have them (knight/archer/spearman/mage/elfRanger/demonArcher)
                let itemUpgradesForType = { hp: 0, atk: 0, def: 0, move: 0, range: 0 };
                if (itemUpgrades[type]) {
                    itemUpgradesForType = itemUpgrades[type];
                }
                
                // Final Stats - Base from Level
                this.maxHp = levelStats.totalHp + itemUpgradesForType.hp; 
                this.atk = levelStats.totalAtk + itemUpgradesForType.atk;
                this.def = levelStats.totalDef + itemUpgradesForType.def;
                
                // 3. NEW: Apply Leader Bonus (Scales with level) - UPDATED BALANCE
                if (this.isLeader && this.team === 'enemy') {
                    // בונוס מנהיגות (לכל רמה L): L*7 HP, L*3 ATK, L*3 DEF - NEW SCALING
                    const leaderBonusHp = 7 * this.level; 
                    const leaderBonusAtk = 3 * this.level;
                    const leaderBonusDef = 3 * this.level;
                    this.maxHp += leaderBonusHp;
                    this.atk += leaderBonusAtk; 
                    this.def += leaderBonusDef;
                }

                // Movement/Range stats get a bonus if items were bought
                this.moveRange = levelStats.baseMove + itemUpgradesForType.move;
                this.attackRange = levelStats.baseRange + itemUpgradesForType.range;
                // Speed (used for double attack logic) - כעת משלב בסיס + בונוס רמה
                this.speed = levelStats.totalSpeed; 
                
                // NEW: Keep current HP ratio unless it's a new game (or full heal is intended)
                this.hp = Math.floor(this.maxHp * initialHpRatio);
                
                this.icon = type;
                this.hasMoved = false;
                this.hasAttacked = false;
            }

            get isAlive() {
                return this.hp > 0;
            }
            
            // NEW: פונקציה לטיפול בעליית רמה
            checkLevelUp() {
                if (this.team !== 'player') return false;
                
                let leveledUp = false;
                while (this.xp >= this.xpToNextLevel) {
                    const currentHpRatio = this.hp / this.maxHp;
                    
                    this.level++;
                    this.xp -= this.xpToNextLevel; // נשאר עודף XP
                    this.xpToNextLevel = this.level * 1000; // הגדלת הדרישה לרמה הבאה
                    
                    // חישוב מחדש של הסטטיסטיקות (Level + Item)
                    const levelStats = calculateLevelBonus(this.type, this.level);
                    const itemUpgradesForType = itemUpgrades[this.type];
                    
                    this.maxHp = levelStats.totalHp + itemUpgradesForType.hp;
                    this.atk = levelStats.totalAtk + itemUpgradesForType.atk;
                    this.def = levelStats.totalDef + itemUpgradesForType.def;
                    this.speed = levelStats.totalSpeed; // עדכון המהירות מרמת הבסיס החדשה
                    
                    // NEW LOGIC: HP מתעדכן באופן פרופורציונלי (לא ריפוי מלא)
                    this.hp = Math.min(this.maxHp, Math.floor(this.maxHp * currentHpRatio));
                    
                    STATUS_MESSAGE.innerHTML = `<span style="color:#32cd32; font-weight:700;">היחידה ${this.name} עלתה לרמה ${this.level}!</span>`;
                    leveledUp = true;
                }
                return leveledUp;
            }

            // תצוגת HP כאלמנט HTML (מופעלת תמיד)
            renderHpBar(tile) {
                let hpBar = tile.querySelector('.hp-bar');
                if (!hpBar) {
                    hpBar = document.createElement('div');
                    hpBar.className = 'hp-bar';
                    tile.appendChild(hpBar);
                }

                let hpFill = hpBar.querySelector('.hp-fill');
                if (!hpFill) {
                    hpFill = document.createElement('div');
                    // FIXED: מחלקה של פס החיים
                    hpFill.className = `hp-fill ${this.team === 'player' ? 'hp-player' : 'hp-enemy'}`; 
                    hpBar.appendChild(hpFill);
                }
                
                const hpPercent = (this.hp / this.maxHp) * 100;
                hpFill.style.width = `${hpPercent}%`;
            }

            // עדכון חזותי
            draw(tile) {
                // הסרת תוכן קיים (אם יש) וציור מחדש
                tile.innerHTML = ''; 
                const iconSpan = document.createElement('span');
                iconSpan.className = `unit-icon ${this.team}-unit ${this.type}`;
                // UPDATED: שימוש ב-isLeader ב-SVG
                iconSpan.innerHTML = getUnitSVG(this.type, this.isLeader);
                tile.appendChild(iconSpan);
                // FIXED: קריאה ל-renderHpBar כאן כדי שהפס יהיה גלוי תמיד
                this.renderHpBar(tile);
            }
            
            // לקיחת נזק
            takeDamage(damage) {
                // UPDATED: אם ההגנה גדולה או שווה להתקפה, הנזק הוא 0
                const effectiveDamage = Math.max(0, damage - this.def); 
                // FIXED: מוודאים שהאריח קיים ב-board
                const tile = (this.row >= 0 && this.row < BOARD_SIZE && this.col >= 0 && this.col < BOARD_SIZE) ? board[this.row][this.col] : null;

                this.hp = Math.max(0, this.hp - effectiveDamage);
                
                // NEW: עדכון פס החיים המיידי על הלוח
                if (tile) {
                    this.renderHpBar(tile);
                }

                if (this.hp === 0) {
                    // NEW: יחידה מתה נעלמת מהלוח באופן מיידי
                    if(tile) tile.innerHTML = '';
                    
                    return true; // היחידה מתה
                }
                return false;
            }
        }

        // ------------------------------------
        // פונקציות עזר ללוח
        // ------------------------------------

        function getUnitAt(row, col) {
            // אם יחידה מתה, היא לא נחשבת כיחידה "בשטח"
            return units.find(u => u.row === row && u.col === col && u.isAlive);
        }

        function renderBoard() {
            BOARD_CONTAINER.innerHTML = '';
            // שמירת קופץ התחזית והצבה מחדש בראש הקונטיינר
            const currentPopup = FORECAST_POPUP;
            BOARD_CONTAINER.appendChild(currentPopup);
            
            board = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                board[r] = [];
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    tile.dataset.row = r;
                    tile.dataset.col = c;
                    // קריאה לפונקציית לחיצה
                    tile.onclick = () => handleTileClick(r, c); 
                    
                    const unit = getUnitAt(r, c);
                    if (unit && unit.row !== -1) { // רק יחידות שנפרסו או אויבים מוצגים
                        unit.draw(tile);
                    }
                    
                    board[r][c] = tile;
                    BOARD_CONTAINER.appendChild(tile);
                }
            }
            // ודא שהתחזית מוסתרת
            hideFloatingForecast();
        }

        function clearHighlights() {
            board.flat().forEach(tile => {
                tile.classList.remove('highlight-move', 'highlight-attack', 'selected');
            });
            currentAction = null;
            // lastPlayerUnit = null; // Don't clear lastPlayerUnit here, only on deselect/turn end
            updateActionButtons();
        }
        
        // NEW: פונקציה כללית לעדכון תצוגה
        function updateUI() {
            GOLD_DISPLAY.textContent = `זהב: ${gold} (שיא: ${goldHighScore})`;
            
            // עדכון כפתורי קנייה
            const costIronSword = 1500;
            const costSteelSword = 2500;
            const costSteelArmor = 2000;
            const costIronBow = 1800;
            const costSteelBow = 2500;
            const costMove = 1500;
            const costSpearman = 2000;
            const costMage = 2200; // UPDATED COST FOR MAGE
            const costElfRanger = 2100; // NEW COST
            const costDemonArcher = 2500; // UPDATED COST FOR DEMON ARCHER
            const costSpearmanShield = 1800; // NEW COST
            const costMageStaff = 2800; // NEW COST
            const costMageRobe = 1600; // NEW COST
            const costElfRangerDaggers = 2300; // NEW COST
            const costElfRangerMove = 1500; // NEW COST
            const costDemonArcherBow = 3500; // NEW COST DEMON ARCHER ITEM
            const costDemonArcherAmulet = 1800; // NEW COST DEMON ARCHER ITEM


            const knightLevel = unitProgress.knight.level;
            const archerLevel = unitProgress.archer.level;
            const spearmanRecruited = unitProgress.spearman.recruited;
            const mageRecruited = unitProgress.mage.recruited;
            const elfRangerRecruited = unitProgress.elfRanger.recruited;
            const demonArcherRecruited = unitProgress.demonArcher.recruited; // NEW

            // Item Upgrade Buttons
            const buyKnightIronSwordBtn = document.getElementById('buy-knight-iron-sword');
            const buyKnightSteelSwordBtn = document.getElementById('buy-knight-steel-sword');
            const buyKnightSteelArmorBtn = document.getElementById('buy-knight-steel-armor');
            const buyArcherIronBowBtn = document.getElementById('buy-archer-iron-bow');
            const buyArcherSteelBowBtn = document.getElementById('buy-archer-steel-bow');
            const buyArcherMoveBtn = document.getElementById('buy-archer-move');
            
            // New Unit Item Buttons
            const buySpearmanShieldBtn = document.getElementById('buy-spearman-shield');
            const buyMageStaffBtn = document.getElementById('buy-mage-staff');
            const buyMageRobeBtn = document.getElementById('buy-mage-robe');
            const buyElfRangerDaggersBtn = document.getElementById('buy-elfRanger-daggers');
            const buyElfRangerMoveBtn = document.getElementById('buy-elfRanger-move');
            const buyDemonArcherBowBtn = document.getElementById('buy-demonArcher-bow'); // NEW
            const buyDemonArcherAmuletBtn = document.getElementById('buy-demonArcher-amulet'); // NEW
            
            // Unit Recruit Buttons
            const recruitSpearmanBtn = document.getElementById('recruit-spearman');
            const recruitMageBtn = document.getElementById('recruit-mage'); 
            const recruitElfRangerBtn = document.getElementById('recruit-elfRanger'); // NEW BUTTON
            const recruitDemonArcherBtn = document.getElementById('recruit-demonArcher'); // NEW BUTTON

            // עדכון כפתורי הקנייה: בדיקת זהב ורמה
            if (buyKnightIronSwordBtn) buyKnightIronSwordBtn.disabled = gold < costIronSword || itemUpgrades.knight.atk >= 10;
            if (buyKnightSteelSwordBtn) buyKnightSteelSwordBtn.disabled = gold < costSteelSword || knightLevel < 3 || itemUpgrades.knight.atk >= 20;
            if (buyKnightSteelArmorBtn) buyKnightSteelArmorBtn.disabled = gold < costSteelArmor || knightLevel < 3 || itemUpgrades.knight.def >= 5;
            if (buyArcherIronBowBtn) buyArcherIronBowBtn.disabled = gold < costIronBow || itemUpgrades.archer.atk >= 15;
            if (buyArcherSteelBowBtn) buyArcherSteelBowBtn.disabled = gold < costSteelBow || archerLevel < 3 || itemUpgrades.archer.atk >= 20;
            
            // עדכון כפתור מגפי עור: שינוי טקסט אם כבר בבעלות
            if (buyArcherMoveBtn) {
                const isBootsActive = itemUpgrades.archer.move > 0;
                // ניתן לבטל גם אם אין זהב
                buyArcherMoveBtn.disabled = gold < costMove && !isBootsActive; 
                buyArcherMoveBtn.textContent = isBootsActive 
                    ? `קשת: מגפי עור (פעיל - לחץ לביטול!)`
                    : `קשת: מגפי עור (+$${costMove} | +1 טווח תנועה)`;
            }

            // NEW: עדכון כפתורי גיוס
            if (recruitSpearmanBtn) {
                recruitSpearmanBtn.disabled = gold < costSpearman || spearmanRecruited;
                if (spearmanRecruited) {
                    recruitSpearmanBtn.textContent = "לוחם מגן גויס (ברשותך)";
                }
            }
            if (recruitMageBtn) { 
                recruitMageBtn.disabled = gold < costMage || mageRecruited; 
                if (mageRecruited) { 
                    recruitMageBtn.textContent = "מכשף גויס (ברשותך)";
                }
            }
            // NEW: Elven Ranger - Available from Battle 3 onwards
            if (recruitElfRangerBtn) {
                if (currentBattleIndex < 3) {
                    recruitElfRangerBtn.disabled = true;
                    recruitElfRangerBtn.style.display = 'block'; // Ensure it's visible but disabled
                    recruitElfRangerBtn.textContent = `גיוס סייר אלפים (נפתח לאחר קרב 2)`;
                } else {
                    recruitElfRangerBtn.disabled = gold < costElfRanger || elfRangerRecruited;
                    if (elfRangerRecruited) {
                        recruitElfRangerBtn.textContent = "סייר אלפים גויס (ברשותך)";
                    } else {
                        recruitElfRangerBtn.textContent = `גיוס סייר אלפים (+$${costElfRanger} | טווח 2, טווח תנועה 4)`;
                    }
                }
            }
            // NEW: Demon Archer - Available from Battle 4 onwards
            if (recruitDemonArcherBtn) {
                 if (currentBattleIndex < 4) {
                    recruitDemonArcherBtn.disabled = true;
                    recruitDemonArcherBtn.style.display = 'block';
                    recruitDemonArcherBtn.textContent = `קשת שד (נפתח לאחר קרב 3)`;
                   } else {
                    recruitDemonArcherBtn.disabled = gold < costDemonArcher || demonArcherRecruited;
                    if (demonArcherRecruited) {
                        recruitDemonArcherBtn.textContent = "קשת שד גויס (ברשותך)";
                    } else {
                        recruitDemonArcherBtn.textContent = `גיוס קשת שד (+$${costDemonArcher} | טווח 4, התקפה 40, איטיות 8)`;
                    }
                   }
            }
            
            // NEW: עדכון כפתורי ציוד ייעודיים (מוסתרים אם היחידה לא גויסה)
            if (buySpearmanShieldBtn) {
                buySpearmanShieldBtn.style.display = spearmanRecruited ? 'block' : 'none';
                buySpearmanShieldBtn.disabled = gold < costSpearmanShield || itemUpgrades.spearman.def >= 10;
            }
            if (buyMageStaffBtn) {
                buyMageStaffBtn.style.display = mageRecruited ? 'block' : 'none';
                // UPDATED: Mage staff now gives ATK 15
                const currentMageStaffAtk = itemUpgrades.mage.atk;
                buyMageStaffBtn.disabled = gold < costMageStaff || currentMageStaffAtk >= 15;
            }
            if (buyMageRobeBtn) {
                buyMageRobeBtn.style.display = mageRecruited ? 'block' : 'none';
                buyMageRobeBtn.disabled = gold < costMageRobe || itemUpgrades.mage.def >= 3;
            }
            if (buyElfRangerDaggersBtn) {
                buyElfRangerDaggersBtn.style.display = elfRangerRecruited ? 'block' : 'none';
                buyElfRangerDaggersBtn.disabled = gold < costElfRangerDaggers || itemUpgrades.elfRanger.atk >= 15;
            }
            if (buyElfRangerMoveBtn) {
                buyElfRangerMoveBtn.style.display = elfRangerRecruited ? 'block' : 'none';
                const isElfMoveActive = itemUpgrades.elfRanger.move > 0;
                buyElfRangerMoveBtn.disabled = gold < costElfRangerMove && !isElfMoveActive;
                buyElfRangerMoveBtn.textContent = isElfMoveActive 
                    ? `סייר: גלימת ציידים (פעיל - לחץ לביטול!)`
                    : `סייר: גלימת ציידים (+$${costElfRangerMove} | +1 טווח תנועה)`;
            }
            if (buyDemonArcherBowBtn) { // NEW DEMON ARCHER ITEM
                buyDemonArcherBowBtn.style.display = demonArcherRecruited ? 'block' : 'none';
                // נשק (ATK/RANGE)
                const currentDemonBowAtk = itemUpgrades.demonArcher.atk;
                buyDemonArcherBowBtn.disabled = gold < costDemonArcherBow || currentDemonBowAtk >= 15; 
            }
            if (buyDemonArcherAmuletBtn) { // NEW DEMON ARCHER AMULET
                buyDemonArcherAmuletBtn.style.display = demonArcherRecruited ? 'block' : 'none';
                // שריון/חפץ (HP/MOVE)
                const isAmuletActive = itemUpgrades.demonArcher.move > 0;
                // הפריט נותן HP ו-MOVE, אבל רק ה-MOVE הוא Toggle. HP לא צריך להשתנות כאן כי הוא נשמר רק כבונוס קבוע.
                buyDemonArcherAmuletBtn.disabled = gold < costDemonArcherAmulet && !isAmuletActive;
            }


            // עדכון תצוגת חנות
            UPGRADE_SHOP.style.display = (gameState === 'upgradePhase') ? 'flex' : 'none';

             // עדכון כפתור סיום תור
            if (gameState === 'upgradePhase') {
                END_TURN_BTN.textContent = `התחל קרב הבא (${currentBattleIndex})`;
                END_TURN_BTN.disabled = false;
            } else if (gameState === 'deployment') { // NEW DEPLOYMENT STATE CHECK
                 const playerUnitsAlive = units.filter(u => u.team === 'player' && u.isAlive).length;
                 const deployedUnitsCount = units.filter(u => u.team === 'player' && u.row !== -1).length;
                 
                 // Enable "Start Turn" only when all units are placed
                 if (deployedUnitsCount === playerUnitsAlive) {
                      END_TURN_BTN.textContent = "התחל קרב >>";
                      END_TURN_BTN.disabled = false;
                 } else {
                      END_TURN_BTN.textContent = `נא לסיים פריסה (${deployedUnitsCount}/${playerUnitsAlive})`;
                      END_TURN_BTN.disabled = true;
                 }

            } else if (gameState !== 'gameOver') {
                END_TURN_BTN.textContent = "סיום תור >>";
            }
            
            // עדכון כותרת הסטטוס (קרב נוכחי)
            document.querySelector('#game-status h2').textContent = `סטטוס המשחק (קרב ${currentBattleIndex})`;
        }

        // ------------------------------------
        // אנימציה ופעולת התקפה (Cutscene)
        // ------------------------------------
        
        function setupOverlayUnit(unit, slot, isAttacker = false) {
            const teamClass = unit.team === 'player' ? 'hp-player' : 'hp-enemy';
            const iconClass = unit.team === 'player' ? 'player-unit' : 'enemy-unit';
            
            // For defender, we flip the icon in CSS
            const slotClass = isAttacker ? 'overlay-attacker' : 'overlay-defender';
            
            // HP Percentage
            const hpPercent = (unit.hp / unit.maxHp) * 100;

            slot.className = `overlay-unit-slot ${slotClass}`;

            slot.innerHTML = `
                <h3 style="margin-bottom: 5px;">${unit.name}</h3>
                <div class="overlay-hp-bar">
                    <div id="${unit.team}-hp-fill" class="overlay-hp-fill ${teamClass}" style="width: ${hpPercent}%"></div>
                </div>
                <!-- שימוש ב-SVG ב-Overlay -->
                <span id="${unit.team}-icon" class="overlay-unit-icon ${iconClass} ${unit.type}">${getUnitSVG(unit.type, unit.isLeader)}</span>
                <p>HP: <span id="${unit.team}-hp-text">${Math.floor(unit.hp)}</span>/${unit.maxHp}</p>
            `;
            return {
                icon: slot.querySelector(`#${unit.team}-icon`),
                hpFill: slot.querySelector(`#${unit.team}-hp-fill`),
                hpText: slot.querySelector(`#${unit.team}-hp-text`),
            };
        }
        
        // NEW: פונקציה ליצירת סצנת הקרב (כניסה אחת)
        async function startBattleCutscene(attacker, defender) {
            const ZOOM_IN_TIME = 500;
            GAME_CONTAINER.style.opacity = '0';
            BATTLE_OVERLAY.style.display = 'flex';
            
            await sleep(ZOOM_IN_TIME); // Pause for the fade transition

            // 2. הכנת יחידות האוברליי
            const attackerElements = setupOverlayUnit(attacker, OVERLAY_ATTACKER, true);
            const defenderElements = setupOverlayUnit(defender, OVERLAY_DEFENDER, false);

            await sleep(300); // Pause for unit display to settle
            
            // Return elements needed for animation
            return { attackerElements, defenderElements };
        }

        // NEW: פונקציה לסיום סצנת הקרב (יציאה אחת)
        async function endBattleCutscene() {
            OVERLAY_ATTACKER.innerHTML = '';
            OVERLAY_DEFENDER.innerHTML = '';
            BATTLE_OVERLAY.style.display = 'none';
            GAME_CONTAINER.style.opacity = '1';
            // Small delay to allow the fade back in
            await sleep(200); 
        }

        // UPDATED: פונקציית האנימציה בפועל - מקבלת את אלמנטי ה-DOM ישירות
        async function animateAttack(attacker, defender, attackerElements, defenderElements, attackIndex = 0) {
            const ATTACK_LUNGE_TIME = 150;
            const SHAKE_TIME = 300;
            
            // 1. תקיפה (זינוק קדימה)
            const lungeDistance = 30; // פיקסלים
            // Ensure transition is set for the lunge
            attackerElements.icon.style.transition = `transform ${ATTACK_LUNGE_TIME}ms ease-out`; 
            
            // זינוק של התוקף לעבר המגן
            attackerElements.icon.style.transform = `translateX(${attacker.team === 'player' ? lungeDistance : -lungeDistance}px)`; 
            
            await sleep(ATTACK_LUNGE_TIME); 

            // 2. יישום נזק
            // Damage is recalculated here just to be safe, though Unit.takeDamage does the calculation
            const isDead = defender.takeDamage(attacker.atk); 
            
            // אנימציית רעד קלה על המגן
            defenderElements.icon.style.animation = `shake ${SHAKE_TIME}ms`;
            
            // עדכון חזותי של HP באוברליי
            const hpPercent = (defender.hp / defender.maxHp) * 100;
            defenderElements.hpFill.style.width = `${hpPercent}%`;
            defenderElements.hpText.textContent = Math.floor(defender.hp);
            
            // הדגשה של פגיעה כפולה/משולשת/מרובעת
            if (attackIndex > 0) {
                 defenderElements.hpText.style.color = '#FFFFFF';
                 attackerElements.hpText.style.color = '#FFFFFF';
                 await sleep(50);
            }
            
            await sleep(SHAKE_TIME); // מחכים שהרעד יסתיים

            // 3. חזרה למיקום
            attackerElements.icon.style.transform = 'translateX(0)'; 
            defenderElements.icon.style.animation = 'none'; 
            
            // החזרת צבע הטקסט
            if (attackIndex > 0) {
                 defenderElements.hpText.style.color = '';
                 attackerElements.hpText.style.color = '';
            }

            await sleep(ATTACK_LUNGE_TIME);

            // 4. עדכון XP ו-HP אם מת
            if (isDead && attacker.team === 'player') {
                attacker.xp += 500; 
                attacker.checkLevelUp(); 
                await saveGold(); 
            }

            return isDead;
        }

        // UPDATED: פונקציה לחישוב מספר ההתקפות על בסיס הפרש מהירות
        function calculateAttackCount(attacker, defender) {
            const speedDiff = attacker.speed - defender.speed;
            
            if (speedDiff >= SPEED_THRESHOLD_QUADRUPLE) {
                return 4;
            } else if (speedDiff >= SPEED_THRESHOLD_TRIPLE) {
                return 3;
            } else if (speedDiff >= SPEED_THRESHOLD_DOUBLE) {
                return 2;
            }
            return 1;
        }

        // NEW HELPER FUNCTION: חישוב הנזק הצפוי הכולל (לוקח בחשבון מהירות והגנה)
        function calculateTotalExpectedDamage(attacker, defender) {
            // אם ההגנה גדולה או שווה להתקפה, הנזק ליחידה הוא 0 (לפי הכלל החדש)
            const damagePerHit = Math.max(0, attacker.atk - defender.def); 
            
            if (damagePerHit === 0) return 0; // לא ניתן לגרום נזק
            
            const attackCount = calculateAttackCount(attacker, defender);
            
            // סה"כ נזק צפוי (כדי שה-AI יבחר את היעד שמייצר הכי הרבה נזק)
            return damagePerHit * attackCount;
        }


        // UPDATED: פונקציה עוטפת שמבצעת את כל רצף ההתקפה
        async function performAttackAction(attacker, defender) {
            // נעילת המשחק
            gameState = 'animating'; 
            
            // 1. כניסה למסך הקרב (פעם אחת)
            const { attackerElements, defenderElements } = await startBattleCutscene(attacker, defender);

            // 2. חישוב מספר ההתקפות
            const attackCount = calculateAttackCount(attacker, defender);
            let defenderWasDead = false;

            // 3. לולאה לכל ההתקפות (1 עד 4)
            for (let i = 0; i < attackCount; i++) {
                if (!defender.isAlive) {
                    defenderWasDead = true;
                    break; 
                }

                // העבר את האינדקס כדי לדעת אם זו מתקפה כפולה/משולשת/מרובעת
                const isKilledThisHit = await animateAttack(attacker, defender, attackerElements, defenderElements, i);
                
                if (isKilledThisHit) {
                    defenderWasDead = true;
                    break; 
                }
                
                // השהיה קלה בין התקפות אם יש יותר מאחת
                if (attackCount > 1 && i < attackCount - 1) await sleep(500); 
            }
            
            // 4. יציאה ממסך הקרב (פעם אחת)
            await endBattleCutscene();
            
            // 5. לוגיקה לאחר האנימציה
            if (defenderWasDead) {
                // עדכן סטטוס
                let pluralMessage = `במכה אחת`;
                if (attackCount === 2) pluralMessage = `במתקפה כפולה`;
                if (attackCount === 3) pluralMessage = `במתקפה משולשת`;
                if (attackCount === 4) pluralMessage = `במתקפה מרובעת`;

                STATUS_MESSAGE.textContent = `${attacker.name} השמיד את ${defender.name} ${pluralMessage}!`;
                checkWinCondition(); 
            } else {
                STATUS_MESSAGE.textContent = `${attacker.name} תקף (${attackCount} מכות). ל-${defender.name} נותרו ${Math.floor(defender.hp)} חיים.`;
            }
            
            // עדכון הלוח לאחר הקרב (כדי לוודא שהיחידה המתה נעלמת והפסים מתעדכנים סופית)
            renderBoard();

            // שחרור נעילת המשחק (אם המשחק לא הסתיים)
            if (gameState !== 'gameOver' && gameState !== 'upgradePhase') {
                 gameState = 'playerTurn';
            }
            
            return defenderWasDead; // Return status for enemy AI
        }

        // ------------------------------------
        // לוגיקת משחק עיקרית
        // ------------------------------------
        
        // NEW: הגדרת אויבים לפי שלב הקרב
        function spawnEnemiesForBattle(battleIndex) {
            let enemies = [];
            
            // קרב 1: קרב מבוא קל (3 אויבים)
            if (battleIndex === 1) {
                // מנהיג רמה 1 (עם בונוס מנהיגות)
                enemies.push(new Unit('orc', 'enemy', 0, 2, 'מפקד אורק', 0, 1, 1.0, true)); 
                // יחידות רגילות
                enemies.push(new Unit('bandit', 'enemy', 1, 1, 'שודד', 0, 1, 1.0));
                enemies.push(new Unit('bandit', 'enemy', 1, 3, 'שודד', 0, 1, 1.0));
            } 
            
            // קרב 2: תגבורת אורקים וקשתים חדשים (4 אויבים)
            else if (battleIndex === 2) {
                // מנהיג רמה 2
                enemies.push(new Unit('orc', 'enemy', 0, 1, 'מפקד אורק מנוסה', 0, 2, 1.0, true)); 
                // יחידות רגילות
                enemies.push(new Unit('orc', 'enemy', 0, 3, 'אורק לוחם', 0, 1, 1.0)); 
                // NEW ENEMY TYPE: קשת שודד (טווח 3) - מנהיג רמה 1
                enemies.push(new Unit('banditArcher', 'enemy', 1, 0, 'קשת מפקד', 0, 1, 1.0, true)); 
                enemies.push(new Unit('banditArcher', 'enemy', 1, 4, 'קשת שודד', 0, 1, 1.0)); 
            }
            
            // UPDATED: קרב 3: התקפה קלה יותר עם גובלינים חלשים
            else if (battleIndex === 3) {
                 // **MODIFIED SCENARIO (EASIER, 6 units - lower level enemies and Goblins)**
                 enemies.push(new Unit('orc', 'enemy', 0, 2, 'מפקד קרב', 0, 2, 1.0, true)); 	// L2 Orc Leader
                 enemies.push(new Unit('bandit', 'enemy', 0, 4, 'שודד מובחר', 0, 2, 1.0)); 	// L2 Bandit 
                 enemies.push(new Unit('banditArcher', 'enemy', 1, 0, 'קשת שודד (אגף)', 0, 1, 1.0)); // L1 Archer 
                 enemies.push(new Unit('banditArcher', 'enemy', 1, 3, 'קשת שודד (אגף)', 0, 1, 1.0)); // L1 Archer 
                 enemies.push(new Unit('goblin', 'enemy', 2, 1, 'גובלין צופה', 0, 1, 1.0)); 	// NEW! L1 Goblin
                 enemies.push(new Unit('goblin', 'enemy', 2, 4, 'גובלין צופה', 0, 1, 1.0)); 	// NEW! L1 Goblin
            }
            
            // UPDATED: קרב 4: מנהיגים חזקים וקשת שד מסוכן
            else if (battleIndex === 4) {
                 const baseLevel = 2; // רמה בסיסית גבוהה יותר
                 // מנהיג חזק
                 enemies.push(new Unit('orc', 'enemy', 0, 2, `גנרל מלחמה`, 0, baseLevel + 1, 1.0, true)); 
                 // קשת שד חדש ומאיים
                 enemies.push(new Unit('demonArcher', 'enemy', 0, 4, 'קשת שד קדמי', 0, baseLevel, 1.0, true)); // NEW ENEMY TYPE
                 // יחידות אגף
                 enemies.push(new Unit('bandit', 'enemy', 1, 1, 'שודד מנוסה', 0, baseLevel, 1.0));
                 enemies.push(new Unit('banditArcher', 'enemy', 1, 3, 'קשת שודד', 0, baseLevel, 1.0));
                 enemies.push(new Unit('goblin', 'enemy', 2, 0, 'גובלין צופה', 0, 1, 1.0)); // גובלין לבזבוז תור
            }
            
            // קרב 5+: קשה יותר ומתגבר
            else {
                 const baseLevel = battleIndex - 3; // מתחיל מ-2 בקרב 5
                 // מנהיג חזק
                 enemies.push(new Unit('orc', 'enemy', 0, 2, `גנרל קרב ${battleIndex}`, 0, Math.min(6, baseLevel + 1), 1.0, true)); 
                 enemies.push(new Unit('bandit', 'enemy', 1, 1, 'שודד', 0, baseLevel, 1.0));
                 enemies.push(new Unit('bandit', 'enemy', 1, 3, 'שודד', 0, baseLevel, 1.0));
                 // קשת שד
                 enemies.push(new Unit('demonArcher', 'enemy', 0, 4, 'קשת שד מאגף', 0, baseLevel, 1.0, true));
                 enemies.push(new Unit('orc', 'enemy', 1, 2, 'אורק משוריין', 0, baseLevel + 1, 1.0));
            }
            
            // ודא שלכל יחידות האויב מוגדר טווח התקפה הגיוני
            enemies.forEach(e => {
                // ADD 'goblin' to melee units
                if (e.type === 'orc' || e.type === 'bandit' || e.type === 'spearman' || e.type === 'goblin') { 
                    e.attackRange = 1; // יחידות מליאה
                } else if (e.type === 'banditArcher' || e.type === 'archer' || e.type === 'elfRanger') { // archer/elfRanger is range
                    e.attackRange = 3; 
                } else if (e.type === 'mage') { // mage has long range
                    e.attackRange = 2; // UPDATED RANGE
                } else if (e.type === 'demonArcher') {
                    e.attackRange = 4; // Demon Archer has max range
                }
            });
            
            return enemies;
        }
        
        function initGame() {
            // 1. יצירת יחידות השחקן עם סטטיסטיקות מעודכנות ו-HP מלא
            const playerUnits = [];
            // קבלת כל סוגי יחידות השחקן, כולל המגויסות (שהסטטוס recruited שלהן הוא true)
            const playerUnitTypes = Object.keys(unitProgress).filter(type => 
                unitProgress[type].recruited
            );

            playerUnitTypes.forEach(type => {
                const progress = unitProgress[type];
                const unitName = getUnitName(type);
                const lastPos = progress.lastPosition || { row: -1, col: -1 };
                
                // Units start at last known good position, or (-1, -1) if new/reset
                // אם lastPos.row הוא -1, היחידה תיחשב ככזו שצריך לפרוס
                playerUnits.push(new Unit(
                    type, 
                    'player', 
                    lastPos.row, 
                    lastPos.col, 
                    unitName,
                    progress.xp, 
                    progress.level, 
                    1.0 // HP מלא
                ));
            });
            
            // 2. יצירת אויבים
            const enemyUnits = spawnEnemiesForBattle(currentBattleIndex);
            
            // שילוב יחידות
            units = playerUnits.concat(enemyUnits);
            // יחידות לפריסה: רק אלה שעדיין לא מוקמו על הלוח
            unitsToDeploy = playerUnits.filter(u => u.isAlive && u.row === -1); 
            
            selectedUnit = null;
            lastPlayerUnit = null; // Resetting last player unit
            pendingTarget = null; // NEW: Reset pending target
            initialMovePosition = null; // Reset initial move position
            currentTurn = 0;

            // NEW: הסתרת פאנל הסטטוס בהתחלת שלב חדש
            SELECTED_UNIT_DETAILS.style.display = 'none';
            
            // 3. התחלת שלב הפריסה או מעבר מידי לקרב
            if (unitsToDeploy.length === 0) {
                 // אם אין יחידות לפריסה, מתחילים את הקרב מיד
                 gameState = 'ready'; 
                 startGameTurn();
            } else {
                 // אחרת, מתחילים שלב הפריסה
                 startDeploymentPhase();
            }
            
            RESTART_BTN.disabled = false;
            
            generateStoryContent(); 
            updateUI(); 
        }
        
        // NEW DEPLOYMENT PHASE FUNCTIONS
        function startDeploymentPhase() {
            gameState = 'deployment';
            TURN_DISPLAY.textContent = `תור: - (פריסה)`;
            END_TURN_BTN.disabled = true; // Disabled until all units are placed
            
            deployingUnit = unitsToDeploy[0] || null; // Unit currently selected for placement
            
            if (!deployingUnit && unitsToDeploy.length === 0) {
                // If there are no units to deploy (all were loaded with positions), start turn
                gameState = 'ready';
                startGameTurn();
                return;
            }

            if(deployingUnit) {
                 STATUS_MESSAGE.textContent = `נא לבחור מיקום עבור: ${deployingUnit.name}.`;
                 selectedUnit = deployingUnit;
                 updateSelectedUnitInfo(selectedUnit); // Show stats of unit to deploy
            } else {
                SELECTED_UNIT_DETAILS.style.display = 'none';
            }
            
            renderBoard(); // Renders board with units already placed
            highlightDeploymentZone();
            
            updateUI(); 
        }
        
        function highlightDeploymentZone() {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const tile = board[r][c];
                    // Highlight only if it's a valid deployment row
                    if (DEPLOYMENT_ROWS.includes(r)) {
                        // ודא שהאריח לא מכיל יחידת אויב
                        const unitAtPos = getUnitAt(r, c);
                        if (!unitAtPos || unitAtPos.team === 'player') {
                             tile.classList.add('highlight-move'); 
                        }
                    }
                    
                    // NEW: סימון היחידה הנוכחית לפריסה
                    if (deployingUnit && deployingUnit.row === r && deployingUnit.col === c) {
                        tile.classList.add('selected');
                    }
                }
            }
        }
        
        function startGameTurn() {
            currentTurn++;
            clearHighlights();
            selectedUnit = null;
            lastPlayerUnit = null;
            pendingTarget = null; // NEW: Reset pending target
            initialMovePosition = null; // Reset initial move position
            hideFloatingForecast(); // NEW: Hide any lingering forecast
            
            // NEW: הסתרת פאנל הסטטוס
            SELECTED_UNIT_DETAILS.style.display = 'none';

            // איפוס פעולות ליחידות השחקן
            units.filter(u => u.team === 'player' && u.isAlive).forEach(u => {
                u.hasMoved = false;
                u.hasAttacked = false;
                // בודק אם האריח קיים לפני הסרת המחלקה
                const tile = board[u.row] ? board[u.row][u.col] : null;
                if (tile) {
                    tile.classList.remove('selected');
                }
            });
            
            if (currentTurn === 1) { // התור הראשון הוא תמיד של השחקן
                startPlayerTurn();
            } else if (currentTurn % 2 !== 0) {
                 startPlayerTurn();
            } else {
                startEnemyTurn();
            }
            updateUI();
        }
        
        function startPlayerTurn() {
            gameState = 'playerTurn';
            TURN_DISPLAY.textContent = `תור: ${currentTurn} (שחקן)`;
            STATUS_MESSAGE.textContent = "בחר יחידה כדי להזיז או לתקוף.";
            END_TURN_BTN.textContent = "סיום תור >>";
            END_TURN_BTN.disabled = false;
            updateActionButtons();
        }
        
        function startEnemyTurn() {
            gameState = 'enemyTurn';
            TURN_DISPLAY.textContent = `תור: ${currentTurn} (אויב)`;
            STATUS_MESSAGE.textContent = "תור האויב... נא להמתין.";
            END_TURN_BTN.disabled = true;
            updateActionButtons();
            
            // NEW: הסתרת פאנל הסטטוס
            SELECTED_UNIT_DETAILS.style.display = 'none';

            // התחלת תהליך תור האויב האסינכרוני
            setTimeout(processEnemyTurn, 1000); 
        }
        
        // UPDATED: פונקציה לבחירת המהלך האופטימלי ביותר עבור האויב - כעת מכוון לטווח התקפה של המטרה
        function findBestEnemyMove(enemy, target) {
            let bestR = enemy.row;
            let bestC = enemy.col;
            let minDistanceToAttackPos = Infinity; // המרחק הקצר ביותר שנמצא לאריח תקיפה פוטנציאלי
            let initialDistance = Math.abs(enemy.row - target.row) + Math.abs(enemy.col - target.col);

            // 1. מציאת כל האריחים מהם ניתן לתקוף את המטרה (אריחי יעד אסטרטגיים)
            let attackPositions = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (isAttackable(r, c, target.row, target.col, enemy.attackRange)) {
                        // ודא שהמיקום לא תפוס על ידי יחידה אחרת (שכמובן אינה האויב עצמו)
                        const unitAtPos = getUnitAt(r, c);
                        if (!unitAtPos || unitAtPos === enemy) {
                            attackPositions.push({ r, c });
                        }
                    }
                }
            }
            
            // אם האויב כבר נמצא בעמדת תקיפה, אין צורך לזוז
            // UPDATED: בדיקה זו נשענת על findBestTarget שמשתמשת בחישוב הנזק
            if (findBestTarget(enemy, [target])) {
                 return null;
            }
            
            // 2. מציאת המהלך בטווח תנועה של האויב שמביא אותו קרוב ביותר לאחד מ'אריחי התקיפה'
            // המהלך הטוב ביותר הוא המהלך בטווח התנועה של האויב שממזער את המרחק לאחד מ-attackPositions.
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    // ודא שזהו מהלך חוקי (בטווח תנועה ואינו תפוס)
                    if (isValidMove(enemy.row, enemy.col, r, c, enemy)) {
                        const moveDistFromStart = Math.abs(enemy.row - r) + Math.abs(enemy.col - c);
                        
                        let distToAttackPosition = Infinity;
                        
                        // מצא את המרחק הקצר ביותר בין נקודת התנועה הנוכחית (r,c) לכל אריח תקיפה
                        for (const pos of attackPositions) {
                            const dist = Math.abs(r - pos.r) + Math.abs(c - pos.c);
                            distToAttackPosition = Math.min(distToAttackPosition, dist);
                        }

                        // **הקריטריון לבחירה:**
                        // א. למזער את המרחק הנותר כדי להגיע לעמדת תקיפה (minDistanceToAttackPos)
                        if (distToAttackPosition < minDistanceToAttackPos) {
                            minDistanceToAttackPos = distToAttackPosition;
                            bestR = r;
                            bestC = c;
                        } 
                        // ב. שובר שוויון: אם המרחק הנותר זהה, בחר את המהלך שמקרב אותנו הכי הרבה ליעד (יותר קדימה).
                        else if (distToAttackPosition === minDistanceToAttackPos) {
                            // שובר שוויון משני: בחר את המהלך שמקרב יותר ליעד עצמו (מרחק מנהטן)
                            const distToTargetNew = Math.abs(r - target.row) + Math.abs(c - target.col);
                            const distToTargetBest = Math.abs(bestR - target.row) + Math.abs(bestC - target.col);
                            
                            if (distToTargetNew < distToTargetBest) {
                                bestR = r;
                                bestC = c;
                            }
                        }
                    }
                }
            }
            
            // אם המיקום הטוב ביותר שנמצא הוא עדיין המיקום הנוכחי של האויב (וזה לא מהלך תקיפה), אין תנועה.
            if (bestR === enemy.row && bestC === enemy.col) {
                return null;
            }

            return { row: bestR, col: bestC };
        }

        // UPDATED: פונקציה לבחירת היעד הטוב ביותר של האויב (מבוסס נזק כולל, לא רק הגנה)
        function findBestTarget(attacker, potentialTargets) {
            let bestTarget = null;
            let maxDamage = -1; // מחפשים את הנזק הגדול ביותר
            
            for (const target of potentialTargets) {
                if (target.team === attacker.team) continue; // ודא שלא תוקפים חברים
                
                if (isAttackable(attacker.row, attacker.col, target.row, target.col, attacker.attackRange)) {
                    
                    // 1. חשב את הנזק הצפוי הכולל (לוקח בחשבון מהירות והגנה)
                    const damage = calculateTotalExpectedDamage(attacker, target); 
                    
                    // 2. תעדוף יעד עם נזק כולל מקסימלי
                    if (damage > maxDamage) {
                        maxDamage = damage;
                        bestTarget = target;
                    }
                    // שובר שוויון: אם הנזק שווה, בחר את היחידה עם ה-HP הנמוך ביותר (לחיסול קל)
                    else if (damage === maxDamage && target.hp < bestTarget?.hp) {
                         bestTarget = target;
                    }
                }
            }
            // מחזיר יעד רק אם הנזק הצפוי הוא לפחות 1
            return maxDamage > 0 ? bestTarget : null; 
        }


        // UPDATED: לוגיקת תור האויב המשלבת תזוזה והתקפה
        async function processEnemyTurn() {
            const playerUnits = units.filter(u => u.team === 'player' && u.isAlive);
            const enemyUnits = units.filter(u => u.team === 'enemy' && u.isAlive);
            
            for (const enemy of enemyUnits) {
                if (gameState === 'gameOver' || gameState === 'upgradePhase' || playerUnits.length === 0) break;
                
                // 1. נסה לתקוף מהמיקום הנוכחי: תעדוף את היחידה עם הנזק הצפוי הגבוה ביותר
                let target = findBestTarget(enemy, playerUnits);

                if (target) {
                    // יש יעד מיידי בטווח התקפה - תוקפים וגמרנו את התור
                    await performAttackAction(enemy, target);
                    if (checkWinCondition()) return; 
                    continue; 
                }

                // 2. אם אין יעד מיידי, מצא את המטרה האסטרטגית (היחידה עם ה-DEF הנמוך ביותר **שניתן לפגוע בה**)
                let strategicMoveTarget = playerUnits
                    .filter(u => calculateTotalExpectedDamage(enemy, u) > 0) // רק יחידות שהאויב יכול לפגוע בהן (לפחות 1 נזק)
                    .reduce((weakest, current) => {
                    
                    const weakestDef = weakest.def !== undefined ? weakest.def : Infinity;
                    const weakestHp = weakest.hp !== undefined ? weakest.hp : Infinity;

                    if (current.def < weakestDef) {
                        return current;
                    }
                    if (current.def === weakestDef && current.hp < weakestHp) {
                         return current;
                    }
                    return weakest;
                }, { def: Infinity, hp: Infinity, name: 'NO TARGET' }); 

                // רק אם מצאנו יעד שאפשר לפגוע בו אסטרטגית
                if (strategicMoveTarget.def !== Infinity) { 
                    
                    // 3. מצא את המהלך הטוב ביותר להגיע לעמדת תקיפה של המטרה האסטרטגית
                    const moveCoords = findBestEnemyMove(enemy, strategicMoveTarget); 

                    if (moveCoords) {
                        // ב. בצע את התנועה
                        moveUnit(enemy, moveCoords.row, moveCoords.col);
                        renderBoard();
                        await sleep(500); // השהיה קלה לאחר תזוזת האויב

                        // 4. בדוק שוב לתקיפה לאחר התזוזה: עכשיו יבחר אוטומטית את הנזק המקסימלי (אפילו אם זה לא היעד האסטרטגי)
                        let postMoveTarget = findBestTarget(enemy, playerUnits);

                        if (postMoveTarget) {
                            await performAttackAction(enemy, postMoveTarget);
                            if (checkWinCondition()) return;
                        }
                    }
                }
                // האויב סיים את תורו (או עבר/או עבר ותקף)
            }
            
            // לאחר שכל האויבים סיימו
            if (gameState !== 'gameOver' && gameState !== 'upgradePhase') {
                 startGameTurn();
            }
        }

        function checkWinCondition() {
            // רק יחידות חיות נספרות
            const playerAlive = units.some(u => u.team === 'player' && u.isAlive);
            const enemyAlive = units.some(u => u.team === 'enemy' && u.isAlive);

            if (!playerAlive) {
                handleLoss(); // טיפול בהפסד
                return true;
            }
            if (!enemyAlive) {
                postVictoryState(); // NEW: טיפול בניצחון ושדרוג
                return true;
            }
            return false;
        }

        // NEW: פונקציה לטיפול במעבר למצב שדרוג
        async function postVictoryState() {
            gameState = 'upgradePhase';
            clearHighlights();
            selectedUnit = null;
            pendingTarget = null; // NEW: Reset pending target
            initialMovePosition = null; // Reset initial move position
            hideFloatingForecast(); // NEW: Hide any lingering forecast
            
            // UPDATED: קרב 2 נותן 1500 זהב בסיסי
            const baseGold = currentBattleIndex === 3 ? 1500 : 1000;
            const goldEarned = baseGold + (currentTurn * 100);
            gold += goldEarned;
            
            // NEW: שמירת נתוני הרמה/XP **והמיקום** של היחידות החיות
            units.filter(u => u.team === 'player' && u.isAlive).forEach(u => {
                // 1. Update XP/Level
                unitProgress[u.type].level = u.level;
                unitProgress[u.type].xp = u.xp;
                unitProgress[u.type].nextLevelXp = u.xpToNextLevel;
                
                // 2. NEW: Save current deployed position
                unitProgress[u.type].lastPosition = { row: u.row, col: u.col };
            });
            
            currentBattleIndex++; // **קידום מספר הקרב לפני שמירת הנתונים ועדכון הסיפור**
            
            // הוספת עלילה ספציפית לכל ניצחון
            let battleStory = '';
            if (currentBattleIndex === 2) { // ניצחון בקרב 1
                battleStory = "הדיפתם את גל האורקים הראשון! אך מרחוק, זיהינו קשתים שודדים שמתקרבים דרך העמקים הצדדיים. התכונן לתגבורת מהירה יותר, המפקד. ";
            } else if (currentBattleIndex === 3) { // ניצחון בקרב 2
                 battleStory = "האזור נקי לעת עתה. ניצחון קשה נגד תגבורת האויב. עליך להתחזק במהירות, המאבק רק החל. ";
            } else if (currentBattleIndex === 4) { // ניצחון בקרב 3
                 battleStory = "התקיפה המתואמת של גל האויבים השלישי נכשלה בזכות הלוחמים החדשים והנשקים המשופרים שלכם. נראה שהמלחמה רק החלה להתחמם.";
            } else {
                battleStory = "ניצחון נוסף! אויבי הממלכה ממשיכים להפסיד קרב אחר קרב.";
            }

            STATUS_MESSAGE.innerHTML = `<span style="color:#ffc107;">ניצחון בקרב ${currentBattleIndex - 1}!</span> ${battleStory} זכית ב-${goldEarned} זהב. שדרג את יחידותיך בחנות לפני הקרב הבא.`;
            
            await saveGold(); // שמירת הכל
            generateStoryContent(); // **NEW: עדכון הסיפור כדי להציג את הפרק החדש**
            updateUI();

            RESTART_BTN.disabled = false;
            END_TURN_BTN.disabled = false; // כפתור הופך ל"התחל קרב הבא"
            TURN_DISPLAY.textContent = `תור: - (שדרוג)`;
        }

        // RENAMED: פונקציה לטיפול בהפסד
        function handleLoss() {
            gameState = 'gameOver';
            clearHighlights();
            selectedUnit = null;
            pendingTarget = null; // NEW: Reset pending target
            initialMovePosition = null; // Reset initial move position
            hideFloatingForecast(); // NEW: Hide any lingering forecast
            updateActionButtons();
            
            STATUS_MESSAGE.innerHTML = `<span style="color:#f44336;">הפסד!</span> כל היחידות הושמדו.`;
            
            saveGold();
            updateUI(); // יעדכן את הזהב (אם במקרה נצבר)

            RESTART_BTN.disabled = false;
            END_TURN_BTN.disabled = true;
            TURN_DISPLAY.textContent = `תור: - (הסתיים)`;
        }

        // --- NEW: Confirmation and Cancellation Handlers ---
        // Helper to execute attack (called by the popup's 'Attack' button)
        function confirmPendingAttackExecution() {
             if (!lastPlayerUnit || !pendingTarget) return;

             // Execute the attack logic (copied from previous ATTACK_BTN handler)
             (async () => {
                 const attacker = lastPlayerUnit;
                 const target = pendingTarget;

                 await performAttackAction(attacker, target);
                 
                 // Cleanup state after attack
                 attacker.hasAttacked = true;
                 
                 // Revert state back to selection mode, keeping the attacker selected
                 selectedUnit = attacker;
                 lastPlayerUnit = attacker; 
                 
                 // IMPORTANT: DO NOT CALL hideFloatingForecast() here, only cancelPendingAttack does
                 FORECAST_POPUP.style.display = 'none'; // Hide the popup immediately
                 FORECAST_POPUP.style.pointerEvents = 'none';
                 pendingTarget = null;
                 initialMovePosition = null; // תזוזה אושרה, אז המיקום ההתחלתי נמחק
                 
                 clearHighlights();
                 if(selectedUnit.isAlive) {
                      board[selectedUnit.row][selectedUnit.col].classList.add('selected');
                      updateSelectedUnitInfo(selectedUnit); 
                 } else {
                      selectedUnit = null;
                      lastPlayerUnit = null;
                      SELECTED_UNIT_INFO.innerHTML = "בחר יחידה מהלוח...";
                      SELECTED_UNIT_DETAILS.style.display = 'none'; // HIDE if unit died
                 }
             })();
        }

        // Helper to cancel the pending attack (called by the popup's 'Cancel' button)
        function cancelPendingAttack() {
             // 1. איפוס התזוזה והחזרת היחידה למקום ההתחלתי
             if (lastPlayerUnit && lastPlayerUnit.hasMoved && initialMovePosition) {
                 
                 // **FIXED: Move unit back to initial position**
                 // צריך להסיר את היחידה מהאריח הנוכחי, לעדכן קואורדינטות, לצייר מחדש
                 board[lastPlayerUnit.row][lastPlayerUnit.col].innerHTML = '';
                 
                 lastPlayerUnit.row = initialMovePosition.row;
                 lastPlayerUnit.col = initialMovePosition.col;
                 
                 // ציור הדמות במיקום הקודם
                 lastPlayerUnit.draw(board[lastPlayerUnit.row][lastPlayerUnit.col]);
                 
                 // **איפוס סטטוס**
                 lastPlayerUnit.hasMoved = false; 
                 initialMovePosition = null; // מיקום התחלה נמחק
                 
                 STATUS_MESSAGE.textContent = `${lastPlayerUnit.name}: הפעולה בוטלה. הוחזר למיקום התחלתי.`;
             } else {
                 STATUS_MESSAGE.textContent = `${lastPlayerUnit.name}: תקיפה בוטלה.`;
             }
             
             // 2. הסתרת הפופאפ ואיפוס ה-pendingTarget
             FORECAST_POPUP.style.display = 'none';
             FORECAST_POPUP.style.pointerEvents = 'none';
             pendingTarget = null;
             
             // 3. עדכון UI והדגשה מחדש
             if (lastPlayerUnit) {
                  selectedUnit = lastPlayerUnit;
                  clearHighlights(); // Clear highlights first
                  showAvailableActions(); // Re-highlight actions based on existing state (including now possible movement)
                  updateSelectedUnitInfo(selectedUnit);
             } else {
                 SELECTED_UNIT_DETAILS.style.display = 'none'; // HIDE if lastPlayerUnit is null
             }
             updateActionButtons();
             // אין צורך ב-renderBoard, מכיוון שה-draw בתוך cancelPendingAttack כבר עדכן את האריחים הרלוונטיים.
        }

        // --- NEW: Floating Forecast Logic ---
        function showFloatingForecast(attacker, defender) {
            if (!attacker || !defender) return hideFloatingForecast();

            const damage = calculateTotalExpectedDamage(attacker, defender);
            const attackCount = calculateAttackCount(attacker, defender);
            const damagePerHit = Math.max(0, attacker.atk - defender.def);
            const remainingHP = Math.max(0, defender.hp - damage);
            const kills = remainingHP === 0 ? `<span style="color: #f44336; font-weight: 700;">(חיסול!)</span>` : '';
            const attackType = attackCount === 1 ? 'רגילה' : (attackCount === 2 ? 'כפולה' : (attackCount === 3 ? 'משולשת' : 'מרובעת'));

            const tile = board[defender.row][defender.col];
            const tileRect = tile.getBoundingClientRect();
            const boardRect = BOARD_CONTAINER.getBoundingClientRect();

            // 1. הגדרת התוכן (כולל כפתורים)
            FORECAST_POPUP.innerHTML = `
                 <h4>תחזית: ${defender.name}</h4>
                 <p>HP: ${defender.hp.toFixed(0)} -> ${remainingHP.toFixed(0)}</p>
                 <p>נזק נטו: <strong>${damagePerHit}</strong> x ${attackCount}</p>
                 <p style="color: #ff4500;">סה"כ נזק: <strong>${damage}</strong> ${kills}</p>
                 
                 <div style="margin-top: 8px; display: flex; gap: 8px; justify-content: center;">
                     <button id="forecast-attack-btn" class="action-btn" style="background-color: #388E3C; color: white; padding: 5px 10px; pointer-events: auto;">תקוף</button>
                     <button id="forecast-cancel-btn" class="action-btn" style="background-color: #5d4037; color: white; padding: 5px 10px; pointer-events: auto;">בטל פעולה</button>
                 </div>
            `;

            // 2. מיקום - ממוקם מעל האריח של המגן
            const popupWidth = FORECAST_POPUP.offsetWidth;
            const popupHeight = FORECAST_POPUP.offsetHeight;

            // חישוב מיקום יחסי ללוח (בפיקסלים)
            FORECAST_POPUP.style.top = `${tileRect.top - boardRect.top - popupHeight - 10}px`;
            FORECAST_POPUP.style.right = `${boardRect.width - (tileRect.right - boardRect.left)}px`;
            
            // 3. הצגה והגדרת פוינטר
            FORECAST_POPUP.style.display = 'block';
            FORECAST_POPUP.style.pointerEvents = 'auto';

            // 4. הגדרת היעד הממתין והאזנה לאירועים
            pendingTarget = defender;
            document.getElementById('forecast-attack-btn').onclick = confirmPendingAttackExecution;
            document.getElementById('forecast-cancel-btn').onclick = cancelPendingAttack;
            
            updateActionButtons();
        }

        function hideFloatingForecast() {
            // אם אנחנו מסתירים את התחזית, זה רק מסתיר אותה
            FORECAST_POPUP.style.display = 'none';
            FORECAST_POPUP.style.pointerEvents = 'none'; // Reset pointer events
            pendingTarget = null;
            updateActionButtons();
            
            // לאחר ביטול התחזית, נרצה לעדכן את המידע על הדמות הנבחרת כדי לשקף את הסטטוס החדש (אם ה-hasMoved השתנה)
            if (selectedUnit) {
                 updateSelectedUnitInfo(selectedUnit);
            }
        }

        // ------------------------------------
        // טיפול בקליקים ופעולות (כעת מבוסס אריחים)
        // ------------------------------------

        function handleTileClick(r, c) {
            if (gameState === 'animating') return; // לא מאפשר קליקים במהלך אנימציה
            
            const clickedUnit = getUnitAt(r, c);
            const tile = board[r][c];

            clearHighlights(); 
            hideFloatingForecast();
            
            // --- DEPLOYMENT PHASE LOGIC (NEW) ---
            if (gameState === 'deployment') {
                const isDeploymentZone = DEPLOYMENT_ROWS.includes(r);
                
                // 1. Clicked on an existing deployed unit (to move it)
                if (clickedUnit && clickedUnit.team === 'player' && isDeploymentZone) {
                    // Clicks on an existing deployed unit (or one currently selected for deploy)
                    deployingUnit = clickedUnit;
                    STATUS_MESSAGE.textContent = `נא לבחור מיקום חדש עבור: ${deployingUnit.name}.`;
                    clearHighlights();
                    highlightDeploymentZone();
                    tile.classList.add('selected');
                    selectedUnit = deployingUnit;
                    updateSelectedUnitInfo(selectedUnit);
                    return;
                }
                
                // 2. Clicked on an empty, valid deployment tile (to place/move the deploying unit)
                if (!clickedUnit && isDeploymentZone && deployingUnit) {
                    
                    // Remove unit from its old spot if it was moved (old spot had a unit)
                    if (deployingUnit.row !== -1 && deployingUnit.row < BOARD_SIZE && deployingUnit.col < BOARD_SIZE) {
                        board[deployingUnit.row][deployingUnit.col].innerHTML = '';
                    }
                    
                    // Update position
                    deployingUnit.row = r;
                    deployingUnit.col = c;
                    deployingUnit.draw(tile);
                    
                    // If the unit was in the deployment queue, remove it
                    const indexInQueue = unitsToDeploy.indexOf(deployingUnit);
                    if (indexInQueue !== -1) {
                        unitsToDeploy.splice(indexInQueue, 1);
                    }
                    
                    clearHighlights(); // Remove highlighting/selection
                    
                    if (unitsToDeploy.length === 0) {
                        // Deployment complete!
                        deployingUnit = null;
                        STATUS_MESSAGE.textContent = "פריסה הושלמה. לחץ 'התחל קרב' כדי להתחיל.";
                        selectedUnit = null;
                        SELECTED_UNIT_DETAILS.style.display = 'none';
                        gameState = 'ready'; // Move to ready state
                    } else {
                        // Move to next unit in queue
                        deployingUnit = unitsToDeploy[0];
                        STATUS_MESSAGE.textContent = `נא לבחור מיקום עבור: ${deployingUnit.name}.`;
                        highlightDeploymentZone(); // Re-highlight zones
                        selectedUnit = deployingUnit;
                        updateSelectedUnitInfo(selectedUnit); // Show next unit to be deployed
                    }
                    
                    updateUI(); // Check end turn button
                    return;
                }
                
                // 3. Ignore clicks on enemy units or invalid tiles during deployment
                return;
            }

            
            // --- Normal Player Turn / Inspection Logic ---
            
            // --- Determine new selection status ---
            let newSelectedUnit = null;
            let clearLastPlayer = false; // Flag to indicate if we need to clear lastPlayerUnit
            
            const isMoveAttempt = tile.classList.contains('highlight-move');
            const isAttackTarget = tile.classList.contains('highlight-attack');

            if (gameState === 'playerTurn' && lastPlayerUnit) {
                 // **A1: Perform Move**
                 if (isMoveAttempt && !lastPlayerUnit.hasMoved && !clickedUnit) { // Must be empty tile
                     
                     if (!initialMovePosition) {
                         initialMovePosition = { row: lastPlayerUnit.row, col: lastPlayerUnit.col };
                     }

                     moveUnit(lastPlayerUnit, r, c);
                     lastPlayerUnit.hasMoved = true;
                     selectedUnit = lastPlayerUnit; 
                     clearHighlights();
                     showAvailableActions(); 
                     updateSelectedUnitInfo(selectedUnit);
                     renderBoard();
                     return;
                 }
                 
                 // **A2: Preview Attack (Opens Forecast Popup)**
                 if (isAttackTarget && clickedUnit && clickedUnit.team === 'enemy' && !lastPlayerUnit.hasAttacked) {
                     if (pendingTarget === clickedUnit) {
                         hideFloatingForecast(); // Click same target closes it
                         return;
                     }
                     showFloatingForecast(lastPlayerUnit, clickedUnit);
                     // selectedUnit is the defender here temporarily for info panel, but lastPlayerUnit remains the active unit
                     selectedUnit = clickedUnit; 
                     updateSelectedUnitInfo(selectedUnit);
                     return; 
                 }
            }


            // --- Default Selection/Inspection ---
            
            if (clickedUnit) {
                const isExhausted = clickedUnit.team === 'player' && clickedUnit.hasMoved && clickedUnit.hasAttacked;
                
                if (isExhausted) {
                    newSelectedUnit = null; 
                    clearLastPlayer = true;
                    STATUS_MESSAGE.textContent = `${clickedUnit.name}: תור היחידה הסתיים!`;
                } else if (clickedUnit.team === 'player' && gameState === 'playerTurn') {
                    // Active Player Unit: Select it and show actions
                    newSelectedUnit = clickedUnit;
                    lastPlayerUnit = clickedUnit;
                    if (!lastPlayerUnit.hasMoved) {
                          initialMovePosition = { row: lastPlayerUnit.row, col: lastPlayerUnit.col };
                    }
                    showAvailableActions();
                } else {
                    // Enemy Unit or Player unit out of turn (Inspection mode)
                    newSelectedUnit = clickedUnit;
                    if (lastPlayerUnit && lastPlayerUnit.isAlive && gameState === 'playerTurn') {
                         board[lastPlayerUnit.row][lastPlayerUnit.col].classList.add('selected');
                         showAvailableActions(); 
                    } else {
                         clearLastPlayer = true;
                    }
                }
            } else {
                // Clicked empty tile: Deselect everything
                clearLastPlayer = true;
            }

            // --- Apply changes ---
            selectedUnit = newSelectedUnit;
            if (clearLastPlayer) {
                lastPlayerUnit = null;
                initialMovePosition = null;
            }
            
            // Set UI visibility based on final selected unit
            if (selectedUnit) {
                board[selectedUnit.row][selectedUnit.col].classList.add('selected');
                updateSelectedUnitInfo(selectedUnit); // This sets display: block
            } else {
                SELECTED_UNIT_DETAILS.style.display = 'none'; // **FIXED: Hide panel if nothing is selected**
                SELECTED_UNIT_INFO.innerHTML = "בחר יחידה מהלוח..."; // Clear info content
            }
            
            updateActionButtons();
        }
        
        // --- פונקציות עזר לפעולות ---

        function updateActionButtons() {
            // אם אין יחידה פעילה של השחקן (lastPlayerUnit), הלחצנים מושבתים
            const unit = lastPlayerUnit; 
            const target = pendingTarget; // משתמש ב-pendingTarget לאישור
            
            // כפתור התזוזה משמש רק לתזוזה, ומציג סטטוס
            if (MOVE_BTN) {
                MOVE_BTN.textContent = "תזוזה";
                MOVE_BTN.disabled = !unit || unit.hasMoved || gameState !== 'playerTurn';
                MOVE_BTN.style.backgroundColor = unit && !unit.hasMoved && gameState === 'playerTurn' ? '#ffc107' : '#795548';
            }

            // כפתור ההתקפה הצידי מושבת אם אין יחידה פעילה או אם היא תקפה, ומופעל רק כדי להדגיח
            if (ATTACK_BTN) {
                ATTACK_BTN.textContent = "התקפה";
                ATTACK_BTN.disabled = !unit || unit.hasAttacked || pendingTarget !== null || gameState !== 'playerTurn'; // מושבת כאשר יש תחזית פתוחה
                ATTACK_BTN.style.backgroundColor = unit && !unit.hasAttacked && gameState === 'playerTurn' ? '#ffc107' : '#795548';
            }
            // הערה: כפתור האישור מופיע רק בתוך הפופאפ עצמו.
        }

        // UPDATED: הוספת האייקון לסטטיסטיקות + לוגיקה להסתרה לאחר סיום תור
        function updateSelectedUnitInfo(unit) {
             
             // 1. אם אין יחידה (נלחץ אריח ריק או יחידה מותשת), מסתירים את הפאנל
             if (!unit) {
                SELECTED_UNIT_DETAILS.style.display = 'none';
                return;
             }
             
             // **מצב 2: תור פעיל / בדיקת אויב - הצגת כל הפרטים והאייקון**
             
             // NEW: הוספת האייקון לסטטיסטיקות
             let unitIconHtml = `<div style="width: 50px; height: 50px; margin-right: 10px; display: inline-block; vertical-align: top;" class="unit-icon ${unit.team}-unit">${getUnitSVG(unit.type, unit.isLeader)}</div>`;
             
             // בונוס כולל (רמה + חפץ)
             const itemUpgradesForType = itemUpgrades[unit.type] || { hp: 0, atk: 0, def: 0, move: 0, range: 0 };
             const totalHp = unit.maxHp;
             const totalAtk = unit.atk;
             const totalDef = unit.def;
             const totalMove = unit.moveRange;
             const totalRange = unit.attackRange;
             const totalSpeed = unit.speed;
             
             // בונוס חפץ מוצג בסוגריים
             const hpBonus = itemUpgradesForType.hp > 0 ? ` (+${itemUpgradesForType.hp})` : '';
             const atkBonus = itemUpgradesForType.atk > 0 ? ` (+${itemUpgradesForType.atk})` : '';
             const moveBonus = itemUpgradesForType.move > 0 ? ` (+${itemUpgradesForType.move})` : '';
             const rangeBonus = itemUpgradesForType.range > 0 ? ` (+${itemUpgradesForType.range})` : '';
             
             // NEW: הצגת בונוס מנהיגות
             let leaderInfo = '';
             if (unit.isLeader && unit.team === 'enemy') {
                 const levelFactor = unit.level;
                 const leaderBonusHp = 7 * levelFactor; 
                 const leaderBonusAtk = 3 * levelFactor;
                 const leaderBonusDef = 3 * levelFactor;
                 leaderInfo = `<p style="color:#ff9800; font-weight:700;">מנהיג (בונוס: +${leaderBonusHp} HP, +${leaderBonusAtk} ATK, +${leaderBonusDef} DEF)</p>`;
             }
             
             let progressInfo = '';
             let statusInfo = '';
             let attackInfo = 'רגילה';
             
             if (unit.team === 'player') {
                 const percent = (unit.xp / unit.xpToNextLevel) * 100;
                 progressInfo = `
                      <p>רמה: <strong>${unit.level}</strong></p>
                      <p>XP: ${unit.xp}/${unit.xpToNextLevel} (${Math.floor(percent)}%)</p>
                    `;
                 if (gameState === 'playerTurn') {
                     statusInfo = `
                         <p style="color:${unit.hasMoved ? '#f44336' : '#4CAF50'}">הוזז: ${unit.hasMoved ? 'כן' : 'לא'}</p>
                         <p style="color:${unit.hasAttacked ? '#f44336' : '#4CAF50'}">תקף: ${unit.hasAttacked ? 'כן' : 'לא'}</p>
                     `;
                 }
             }
             
             // חישוב יכולת התקפה כללית
             const targets = units.filter(u => u.team !== unit.team && u.isAlive);
             if (targets.length > 0) {
                  const weakestTargetSpeed = targets.reduce((min, t) => Math.min(min, t.speed), Infinity);
                  const speedDiff = unit.speed - weakestTargetSpeed;
                  
                  if (speedDiff >= SPEED_THRESHOLD_QUADRUPLE) {
                       attackInfo = 'מרובעת';
                  } else if (speedDiff >= SPEED_THRESHOLD_TRIPLE) {
                       attackInfo = 'משולשת';
                  } else if (speedDiff >= SPEED_THRESHOLD_DOUBLE) {
                       attackInfo = 'כפולה';
                  }
             }

             SELECTED_UNIT_INFO.innerHTML = `
                 <div style="display: flex; align-items: center; justify-content: space-between; margin-top:0; border-bottom: 1px solid #795548; padding-bottom: 5px; margin-bottom: 10px;">
                     <h2 style="margin: 0; font-size: 1.5em; flex-grow: 1;">${unit.name}</h2>
                     <div style="width: 50px; height: 50px;" class="unit-icon ${unit.team}-unit">${getUnitSVG(unit.type, unit.isLeader)}</div>
                 </div>
                 <p>HP נוכחי: <strong>${Math.floor(unit.hp)}</strong>/${totalHp}</p>
                 ${leaderInfo}
                 ${progressInfo}
                 <p>התקפה: ${totalAtk} ${atkBonus} | הגנה: ${totalDef}</p>
                 <p><strong>טווח תנועה: ${totalMove} ${moveBonus}</strong> | טווח תקיפה: ${totalRange} ${rangeBonus}</p>
                 <p><strong>מהירות: ${totalSpeed}</strong> (יכולת תקיפה: ${attackInfo})</p>
                 ${statusInfo}
             `;
             SELECTED_UNIT_DETAILS.style.display = 'block';
        }
        
        // הפונקציה החדשה שמציגה טווח תנועה והתקפה אוטומטית
        function showAvailableActions() {
            // UPDATED: משתמשת ב-lastPlayerUnit במקום selectedUnit
            if (!lastPlayerUnit || lastPlayerUnit.team === 'enemy') return;
            
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const tile = board[r][c];
                    const targetUnit = getUnitAt(r, c);
                    
                    // הדגשת תזוזה
                    if (!lastPlayerUnit.hasMoved && isValidMove(lastPlayerUnit.row, lastPlayerUnit.col, r, c, lastPlayerUnit)) {
                        tile.classList.add('highlight-move');
                    }
                    
                    // הדגשת התקפה
                    if (!lastPlayerUnit.hasAttacked && 
                        targetUnit && 
                        targetUnit.team !== lastPlayerUnit.team && 
                        isAttackable(lastPlayerUnit.row, lastPlayerUnit.col, r, c, lastPlayerUnit.attackRange)) {
                             // NEW: הדגש רק אם ניתן לגרום נזק
                             if (calculateTotalExpectedDamage(lastPlayerUnit, targetUnit) > 0) {
                                 tile.classList.add('highlight-attack');
                             }
                    }
                }
            }
            // שמור על היחידה הפעילה מסומנת
            board[lastPlayerUnit.row][lastPlayerUnit.col].classList.add('selected');
        }


        function moveUnit(unit, newR, newC) {
            // הסרת יחידה מהאריח הישן
            board[unit.row][unit.col].innerHTML = '';
            
            // עדכון המיקום
            unit.row = newR;
            unit.col = newC;
            
            // ציור מחדש במיקום החדש
            unit.draw(board[newR][newC]);
            
            // הדגשה חזותית של תנועה
            board[newR][newC].style.transform = 'scale(1.1)';
            setTimeout(() => {
                board[newR][newC].style.transform = 'scale(1)';
            }, 150);
        }

        
        // --- פונקציות בדיקת טווח ---

        // פונקציה משודרגת - מקבלת את היחידה הנבחרת כדי לקבל את טווח התנועה
        function isValidMove(startR, startC, endR, endC, unit) {
            // FIXED: בדיקה אם האריח תפוס, אבל מאפשר תזוזה למקום של האויב אם הוא אינו קיים יותר
            const unitAtEnd = getUnitAt(endR, endC);
            if (unitAtEnd && unitAtEnd !== unit) {
                return false; // אריח תפוס
            }
            
            // בדיקה שרק היחידה עצמה יכולה לבדוק את טווח התנועה שלה
            if (!unit) return false;

            const dist = Math.abs(startR - endR) + Math.abs(startC - endC);
            return dist > 0 && dist <= unit.moveRange;
        }

        function isAttackable(startR, startC, endR, endC, range) {
            const dist = Math.abs(startR - endR) + Math.abs(startC - endC);
            return dist > 0 && dist <= range;
        }
        
        // ------------------------------------
        // לוגיקת חנות וציוד
        // ------------------------------------
        
        async function recruitUnit(unitType, cost, itemName) {
            if (gameState !== 'upgradePhase') {
                STATUS_MESSAGE.textContent = "ניתן לגייס יחידות רק אחרי ניצחון בקרב.";
                return;
            }
            // UPDATED: Check for 'mage' or 'spearman' status
            if (unitProgress[unitType].recruited) {
                STATUS_MESSAGE.textContent = `היחידה ${itemName} כבר גויסה ונמצאת ברשותך!`;
                return;
            }
            if (gold < cost) {
                STATUS_MESSAGE.textContent = `אין מספיק זהב לגיוס! נדרש $${cost}. יש לך $${gold}.`;
                return;
            }

            // NEW: תנאי רכישת יחידות לפי קרב
            if (unitType === 'elfRanger' && currentBattleIndex < 3) {
                STATUS_MESSAGE.textContent = "גיוס סייר אלפים נפתח רק אחרי קרב 2.";
                return;
            }
            if (unitType === 'demonArcher' && currentBattleIndex < 4) {
                 STATUS_MESSAGE.textContent = "גיוס קשת שד נפתח רק אחרי קרב 3.";
                 return;
            }

            gold -= cost;
            unitProgress[unitType].recruited = true;
            
            await saveGold();
            
            STATUS_MESSAGE.innerHTML = `<span style="color:#64B5F6;">גיוס מוצלח!</span> היחידה: ${itemName} הצטרפה לכוחותיך. היא תופיע בקרב הבא.`;
            updateUI();
        }

        async function buyItem(unitType, cost, updates, itemName, requiredLevel = 1) {
            if (gameState !== 'upgradePhase') {
                STATUS_MESSAGE.textContent = "ניתן לקנות חפצים רק אחרי ניצחון בקרב.";
                return;
            }
            
            // NEW: ודא שניתן לקנות ציוד רק ליחידות קיימות/מגויסות
            if (!unitProgress[unitType] || !unitProgress[unitType].recruited) {
                 STATUS_MESSAGE.textContent = `לא ניתן לקנות ציוד. גייס את ${getUnitName(unitType)} תחילה!`;
                 return;
            }
            
            // 1. **Toggle Logic for MOVE items (Leather Boots / Hunter's Cloak / Demon Amulet)**
            const isMoveItem = (itemName === 'מגפי עור' || itemName === 'גלימת ציידים' || itemName === 'תליון השהייה') && updates.move !== undefined;
            
            if (isMoveItem) {
                
                // הבונוס המנוטרל הוא בדיוק גובה הבונוס שניתן
                const isItemActive = itemUpgrades[unitType].move === updates.move;
                
                // NEW: אם זה תליון השהייה, הבונוס הוא גם HP
                const isAmulet = itemName === 'תליון השהייה';
                
                if (isItemActive) {
                    // אם כבר בבעלותם -> בטל את ההשפעה (Toggle Off)
                    itemUpgrades[unitType].move = 0; // הסרת הבונוס
                    if (isAmulet) itemUpgrades[unitType].hp -= 20; // הסרת בונוס HP
                    
                    STATUS_MESSAGE.innerHTML = `<span style="color:#f44336;">בוטלה ההשפעה!</span> ${itemName} הוסר מ${getUnitName(unitType)}.`;
                    await saveGold();
                    updateUI();
                    return; // יציאה ללא גביית מחיר
                } 
                // אם אינו פעיל, המשך לבדיקת הזהב והרכישה
            }

            // בדיקת דרישות רכישה (זהב ורמה)
            if (gold < cost) {
                STATUS_MESSAGE.textContent = `אין מספיק זהב! נדרש $${cost}. יש לך $${gold}.`;
                return;
            }
            
            const currentLevel = unitProgress[unitType].level;
            if (currentLevel < requiredLevel) {
                 STATUS_MESSAGE.textContent = `דרושה רמה ${requiredLevel} כדי לקנות את ${itemName}! הרמה הנוכחית היא ${currentLevel}.`;
                 return;
            }

            // 2. **Stronger Item Only Check (ATK/DEF/HP/RANGE)**
            
            // בדיקת שריון (HP/DEF) - קניית שריון חדש מבטלת ישן
            if ((updates.hp !== undefined && !isMoveItem) || updates.def !== undefined) {
                 // רק אם יש כבר שריון פעיל וחזק יותר
                 if (itemUpgrades[unitType].hp >= (updates.hp || 0) && itemUpgrades[unitType].def >= (updates.def || 0) && (itemUpgrades[unitType].hp > 0 || itemUpgrades[unitType].def > 0) ) {
                      STATUS_MESSAGE.textContent = `השריון הנוכחי שלך (${itemUpgrades[unitType].hp} HP, ${itemUpgrades[unitType].def} DEF) חזק יותר או שווה ל-${itemName}.`;
                      return;
                 }
                 // איפוס בונוסי שריון ישנים
                 itemUpgrades[unitType].hp = 0;
                 itemUpgrades[unitType].def = 0;
            }

            // בדיקת נשק (ATK/RANGE) - קניית נשק חדש מבטלת ישן
            if (updates.atk !== undefined || updates.range !== undefined) {
                const currentAtkBonus = itemUpgrades[unitType].atk;
                const newAtk = updates.atk || 0; 
                
                // אם הבונוס החדש שווה לבונוס הישן, זה לא שדרוג (למעט אם הבונוס הוא 0)
                if (newAtk < currentAtkBonus) {
                    STATUS_MESSAGE.textContent = `לא שודרג! ${itemName} (+${newAtk} התקפה) אינו חזק מהנשק הפעיל (+${currentAtkBonus} התקפה).`;
                    return;
                }
                if (newAtk === currentAtkBonus && currentAtkBonus !== 0) {
                     STATUS_MESSAGE.textContent = `כבר ברשותך נשק בעל בונוס זהה (+${currentAtkBonus} התקפה).`;
                     return;
                }
                 // איפוס בונוסי נשק ישנים
                 itemUpgrades[unitType].atk = 0;
                 itemUpgrades[unitType].range = 0;
            }
            
            // **תיקון קריטי**: גביית מחיר
            gold -= cost;
            
            // החלת הבונוסים החדשים
            Object.keys(updates).forEach(stat => {
                 itemUpgrades[unitType][stat] += updates[stat];
            });
            
            // אם קנינו תליון השהייה (פריט Toggle), צריך להוסיף את ה-HP שלו
            if (isAmulet && !isItemActive) {
                 itemUpgrades[unitType].hp += 20;
            }

            await saveGold();
            
            STATUS_MESSAGE.innerHTML = `<span style="color:#ffc107;">קנייה מוצלחת!</span> נרכש: ${itemName}.`;
            updateUI();
        }


        // ------------------------------------
        // לוגיקת Firebase ושמירת זהב
        // ------------------------------------
        
        async function setupFirebase() {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                let firebaseConfig;
                
                // FIXED: טיפול ב-config חסר או לא תקין
                try {
                    const configString = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
                    firebaseConfig = JSON.parse(configString);
                } catch (e) {
                    firebaseConfig = {};
                }


                if (!firebaseConfig || !firebaseConfig.apiKey) {
                    // אם הקונפיגורציה חסרה, מציגים את השגיאה
                    STATUS_MESSAGE.textContent = 'שגיאת Firebase: חסר קונפיגורציה. משחק ללא שמירה.';
                    console.error("Firebase config is missing or invalid. Running without persistence.");
                    
                    // NEW: מאפשרים משחק ללא שמירה אם הקונפיגורציה חסרה
                    isReady = true;
                    RESTART_BTN.disabled = false;
                    unitProgress = createDefaultUnitProgress(); // NEW: אתחול עם ברירת מחדל
                    initGame(); // התחלת המשחק מיד (יכנס לפריסה)
                    return; 
                }

                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                if (typeof __initial_auth_token !== 'undefined') {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                userId = auth.currentUser?.uid || 'anonymous-user';

                await loadGold();
                
                // FIXED: הודעת סטטוס שמנחה את המשתמש
                STATUS_MESSAGE.textContent = "טעינת נתונים הסתיימה. לחץ 'התחל קרב חדש' כדי להתחיל, או המשך מהקרב השמור."; 
                isReady = true;
                RESTART_BTN.disabled = false;
                initGame(); // **NEW: טעינת המשחק מהנתונים השמורים**
                
            } catch (error) {
                console.error("Firebase setup failed:", error);
                STATUS_MESSAGE.textContent = `שגיאת חיבור: ${error.message.substring(0, 30)}...`;
            }
        }

        async function loadGold() {
            // אם db הוא null, אנחנו במצב ללא שמירה
            if (!db || !userId) return;

            const docRef = doc(db, 'artifacts', typeof __app_id !== 'undefined' ? __app_id : 'default-app-id', 'users', userId, 'progress', 'goldData');
            try {
                const docSnap = await getDoc(docRef);
                
                // NEW: הגדרת ברירות המחדל
                const defaultItemUpgrades = { knight: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, archer: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, spearman: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, mage: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, elfRanger: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, demonArcher: { hp: 0, atk: 0, def: 0, move: 0, range: 0 } };
                const defaultUnitProgress = createDefaultUnitProgress();

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    gold = data.gold || 0;
                    goldHighScore = data.highScore || 0;
                    // FIXED: ודא שהקרב ההתחלתי הוא 1 אם אין נתונים
                    currentBattleIndex = data.currentBattleIndex || 1; 
                    
                    // NEW: טעינת שדרוגי ציוד ונתוני גיוס
                    itemUpgrades = { ...defaultItemUpgrades, ...data.itemUpgrades };
                    unitProgress = { ...defaultUnitProgress, ...data.unitProgress };

                    // FIX: אם היחידה הישנה 'scout' קיימת, מעביר אותה ל-'mage' (לשמירה על התקדמות קודמת)
                    if (data.unitProgress && data.unitProgress.scout && data.unitProgress.scout.recruited) {
                         unitProgress.mage = { ...defaultUnitProgress.mage, ...data.unitProgress.scout };
                         unitProgress.mage.recruited = true;
                         itemUpgrades.mage = data.itemUpgrades.scout || itemUpgrades.mage;
                    }
                    // ודא של-knight/archer יש recruited: true
                    unitProgress.knight.recruited = true;
                    unitProgress.archer.recruited = true;


                } else {
                    // שמור נתוני ברירת מחדל אם אין
                    unitProgress = defaultUnitProgress; // NEW: הגדרה ל-default לפני שמירה
                    await saveGold(); 
                }
            } catch (e) {
                console.error("Error loading document:", e);
                // גם אם נכשל בטעינה, השתמש בברירת מחדל
                unitProgress = createDefaultUnitProgress();
            }
        }

        async function saveGold() {
            // אם db הוא null, אנחנו במצב ללא שמירה
            if (!db || !userId) return;
            
            if (gold > goldHighScore) {
                goldHighScore = gold;
            }

            // NEW: נרמול הנתונים לפני שמירה (כדי למנוע שמירת 'scout' בטעות)
            const savedItemUpgrades = {
                knight: itemUpgrades.knight,
                archer: itemUpgrades.archer,
                spearman: itemUpgrades.spearman,
                mage: itemUpgrades.mage,
                elfRanger: itemUpgrades.elfRanger, // NEW
                demonArcher: itemUpgrades.demonArcher // NEW
            };
            const savedUnitProgress = {
                knight: unitProgress.knight,
                archer: unitProgress.archer,
                spearman: unitProgress.spearman,
                mage: unitProgress.mage,
                elfRanger: unitProgress.elfRanger, // NEW
                demonArcher: unitProgress.demonArcher // NEW
            };

            const docRef = doc(db, 'artifacts', typeof __app_id !== 'undefined' ? __app_id : 'default-app-id', 'users', userId, 'progress', 'goldData');
            try {
                await setDoc(docRef, {
                    gold: Math.floor(gold),
                    highScore: Math.floor(goldHighScore),
                    currentBattleIndex: currentBattleIndex, // NEW: שמירת אינדקס הקרב
                    itemUpgrades: savedItemUpgrades, // NEW: שמירת שדרוגי ציוד
                    unitProgress: savedUnitProgress // NEW: שמירת XP/רמה ומיקום
                }, { merge: true });
            } catch (e) {
                console.error("Error saving document:", e);
            }
        }

        // ------------------------------------
        // האזנה לאירועים
        // ------------------------------------
        
        // פונקציית האתחול הראשית
        window.onload = () => {
            renderBoard(); // ציור הלוח הריק
            setupFirebase();
            RESTART_BTN.onclick = () => {
                if (isReady) {
                     // NEW: איפוס מלא כולל התקדמות
                     currentBattleIndex = 1; 
                     // איפוס מלא של כל הנתונים כולל הגיוס והמיקום
                     itemUpgrades = { knight: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, archer: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, spearman: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, mage: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, elfRanger: { hp: 0, atk: 0, def: 0, move: 0, range: 0 }, demonArcher: { hp: 0, atk: 0, def: 0, move: 0, range: 0 } };
                     
                     // **FIXED: איפוס כל המיקומים של יחידות השחקן ל-(-1, -1)**
                     unitProgress = createDefaultUnitProgress(); 
                     Object.keys(unitProgress).forEach(type => {
                        unitProgress[type].lastPosition = { row: -1, col: -1 };
                     });
                     
                     gold = 0;
                     // שמירה רק אם יש db
                     if(db) saveGold();
                     initGame();
                } else {
                     // אם Firebase לא מוכן, נסה להפעיל את ה-setup שוב, אבל הכפתור אמור להיות כבוי
                     STATUS_MESSAGE.textContent = "טוען נתונים. המתן רגע...";
                     setupFirebase();
                }
            };

            // NEW: לוגיקת קליק של כפתור הסיפור
            if (TOGGLE_STORY_BTN) {
                TOGGLE_STORY_BTN.onclick = () => {
                    if (STORY_PANEL.style.display === 'none' || STORY_PANEL.style.display === '') {
                        STORY_PANEL.style.display = 'block';
                        TOGGLE_STORY_BTN.textContent = "סגור סיפור ומדריך";
                    } else {
                        STORY_PANEL.style.display = 'none';
                        TOGGLE_STORY_BTN.textContent = "סיפור ומדריך";
                    }
                };
            }


            // NEW: הגדרת קליקים של חנות חפצים - דרישת רמה מיושמת כאן
            
            // Items
            const buyKnightIronSwordBtn = document.getElementById('buy-knight-iron-sword');
            const buyKnightSteelSwordBtn = document.getElementById('buy-knight-steel-sword');
            const buyKnightSteelArmorBtn = document.getElementById('buy-knight-steel-armor');
            const buyArcherIronBowBtn = document.getElementById('buy-archer-iron-bow');
            const buyArcherSteelBowBtn = document.getElementById('buy-archer-steel-bow');
            const buyArcherMoveBtn = document.getElementById('buy-archer-move');
            
            // Recruits
            const recruitSpearmanBtn = document.getElementById('recruit-spearman');
            const recruitMageBtn = document.getElementById('recruit-mage');
            const recruitElfRangerBtn = document.getElementById('recruit-elfRanger'); // NEW HANDLER
            const recruitDemonArcherBtn = document.getElementById('recruit-demonArcher'); // NEW HANDLER
            
            // New Unit Item Handlers
            const buySpearmanShieldBtn = document.getElementById('buy-spearman-shield');
            const buyMageStaffBtn = document.getElementById('buy-mage-staff');
            const buyMageRobeBtn = document.getElementById('buy-mage-robe');
            const buyElfRangerDaggersBtn = document.getElementById('buy-elfRanger-daggers');
            const buyElfRangerMoveBtn = document.getElementById('buy-elfRanger-move');
            const buyDemonArcherBowBtn = document.getElementById('buy-demonArcher-bow'); // NEW HANDLER
            const buyDemonArcherAmuletBtn = document.getElementById('buy-demonArcher-amulet'); // NEW HANDLER


            if (buyKnightIronSwordBtn) {
                 // אביר: חרב ברזל (רמה 1, +10 התקפה)
                 buyKnightIronSwordBtn.onclick = () => buyItem('knight', 1500, { atk: 10 }, 'חרב ברזל', 1);
            }
            if (buyKnightSteelSwordBtn) {
                 // אביר: חרב פלדה (רמה 3, +20 התקפה, +1 טווח)
                 buyKnightSteelSwordBtn.onclick = () => buyItem('knight', 2500, { atk: 20, range: 1 }, 'חרב פלדה', 3);
            }
            if (buyKnightSteelArmorBtn) {
                 // אביר: שריון פלדה (רמה 3, +50 חיים, +5 הגנה) - שריון חדש מחליף ישן
                 buyKnightSteelArmorBtn.onclick = () => buyItem('knight', 2000, { hp: 50, def: 5 }, 'שריון פלדה', 3);
            }
            if (buyArcherIronBowBtn) {
                 // קשת: קשת ברזל (רמה 1, +15 התקפה)
                 buyArcherIronBowBtn.onclick = () => buyItem('archer', 1800, { atk: 15 }, 'קשת ברזל', 1);
            }
            if (buyArcherSteelBowBtn) {
                 // קשת: קשת פלדה (רמה 3, +20 התקפה, +1 טווח)
                 buyArcherSteelBowBtn.onclick = () => buyItem('archer', 2500, { atk: 20, range: 1 }, 'קשת פלדה', 3);
            }
            if (buyArcherMoveBtn) {
                 // קשת: מגפי עור (רמה 1, +1 תנועה) - פריט Toggle
                 buyArcherMoveBtn.onclick = () => buyItem('archer', 1500, { move: 1 }, 'מגפי עור', 1);
            }
            
            // NEW: לוחם מגן
            if (buySpearmanShieldBtn) {
                 buySpearmanShieldBtn.onclick = () => buyItem('spearman', 1800, { hp: 30, def: 10 }, 'מגן פלדה', 1);
            }

            // NEW: מכשף - UPDATED ITEM LOGIC
            if (buyMageStaffBtn) {
                 // שרביט עוצמתי (נותן רק טווח תנועה ותקיפה)
                 buyMageStaffBtn.onclick = () => buyItem('mage', 2800, { atk: 15, range: 1, move: 1 }, 'שרביט עוצמתי', 1);
            }
            if (buyMageRobeBtn) {
                 buyMageRobeBtn.onclick = () => buyItem('mage', 1600, { hp: 20, def: 3 }, 'גלימת ארכאון', 1);
            }

            // NEW: סייר אלפים
            if (buyElfRangerDaggersBtn) {
                 buyElfRangerDaggersBtn.onclick = () => buyItem('elfRanger', 2300, { atk: 15 }, 'פגיונות רעל', 1);
            }
            if (buyElfRangerMoveBtn) {
                 // פריט Toggle לטווח תנועה
                 buyElfRangerMoveBtn.onclick = () => buyItem('elfRanger', 1500, { move: 1 }, 'גלימת ציידים', 1);
            }
            
            // NEW: קשת שד
            if (buyDemonArcherBowBtn) {
                 // קשת שד: קשת אפלה (+10 ATK, +1 טווח)
                 buyDemonArcherBowBtn.onclick = () => buyItem('demonArcher', 3500, { atk: 15, range: 1 }, 'קשת אפלה', 1);
            }
            if (buyDemonArcherAmuletBtn) {
                 // קשת שד: תליון השהייה (+20 HP, +1 Move) - פריט Toggle
                 buyDemonArcherAmuletBtn.onclick = () => buyItem('demonArcher', 1800, { move: 1 }, 'תליון השהייה', 1);
            }


            // NEW: גיוס יחידות
            if (recruitSpearmanBtn) {
                recruitSpearmanBtn.onclick = () => recruitUnit('spearman', 2000, 'לוחם מגן');
            }
            // UPDATED: Recruit Mage
            if (recruitMageBtn) {
                recruitMageBtn.onclick = () => recruitUnit('mage', 2200, 'מכשף');
            }
            // NEW: Recruit Elven Ranger
            if (recruitElfRangerBtn) {
                recruitElfRangerBtn.onclick = () => recruitUnit('elfRanger', 2100, 'סייר אלפים');
            }
            // NEW: Recruit Demon Archer
            if (recruitDemonArcherBtn) {
                recruitDemonArcherBtn.onclick = () => recruitUnit('demonArcher', 2500, 'קשת שד');
            }


            // הלחצנים לא מבצעים פעולה ישירה יותר, אלא רק מציגים את הסטטוס
            if(MOVE_BTN) MOVE_BTN.onclick = () => { 
                hideFloatingForecast(); // ביטול תחזית אם קיימת
                if (lastPlayerUnit) showAvailableActions(); 
            };
            
            // **UPDATED**: לוגיקת כפתור ההתקפה/אישור
            if(ATTACK_BTN) ATTACK_BTN.onclick = () => { 
                if (gameState !== 'playerTurn') return; // Only allow clicks during player turn

                const unit = lastPlayerUnit;

                // Normal click action: highlight attack targets
                if (unit && !unit.hasAttacked) {
                     showAvailableActions();
                }
            };
            
            // הגדרת לוגיקה לכפתור סיום תור
            END_TURN_BTN.onclick = () => {
                if (gameState === 'upgradePhase') {
                    initGame(); // התחל קרב חדש עם שדרוגים חדשים ומיקומים שמורים
                } else if (gameState === 'deployment') { // NEW LOGIC
                     // אם אנחנו בשלב הפריסה וכל היחידות הוצבו, התחל את התור הראשון
                     const playerUnitsAlive = units.filter(u => u.team === 'player' && u.isAlive).length;
                     const deployedUnitsCount = units.filter(u => u.team === 'player' && u.row !== -1).length;
                     if (deployedUnitsCount === playerUnitsAlive) {
                          gameState = 'ready';
                          startGameTurn();
                     }
                } else {
                    startGameTurn();
                }
            };
        };

    </script>
</body>
</html>
