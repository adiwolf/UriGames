<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>×”×‘×œ×’×Ÿ ×”××•×œ×™××¤×™ - ×§×•×•×¡×˜ ×”××œ×™×</title>
    <!-- ×˜×¢×™× ×ª Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* ×”×’×“×¨×•×ª ×›×œ×œ×™×•×ª ×•×’×•×¤×Ÿ */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #064e3b 100%); /* ×¨×§×¢ ××•×œ×™××¤×•×¡ */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .game-container {
            max-width: 600px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            text-align: center;
            direction: rtl;
        }
        .quest-title {
            color: #b91c1c; 
            font-size: 1.875rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        .quest-description {
            color: #1f2937;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }
        /* ×¡×’× ×•×Ÿ ×›×¤×ª×•×¨×™ ×¤×¢×•×œ×” */
        .action-btn {
            background-color: #059669;
            color: white;
            border-radius: 9999px;
            padding: 0.75rem 2rem;
            font-size: 1.125rem;
            transition: all 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .action-btn:hover {
            background-color: #047857;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        }
        /* ×¡×’× ×•×Ÿ ×§× ×‘×¡ */
        #gameCanvas {
            border: 4px solid #1f2937;
            background-color: #e5e7eb;
            touch-action: none; /* ×œ×× ×™×¢×ª ×’×œ×™×œ×” ×‘××¡×š ××’×¢ */
        }
        /* ×¡×’× ×•×Ÿ ×›×¤×ª×•×¨×™ ×©×œ×™×˜×” ×‘××’×¢ (×œ××•×‘×™×™×œ) */
        .touch-controls button {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
            transition: background-color 0.1s;
        }
        .touch-controls button:active {
            background-color: #1d4ed8;
        }
        /* ×¡×’× ×•×Ÿ ×¡×¨×’×œ ×¡×˜×˜×•×¡ ×¡×¤×¦×™×¤×™ ×œ×”×¤×™×¡×˜×•×¡ */
        .hephaestus-status {
            padding: 0.5rem;
            margin-top: 1rem;
            border-radius: 8px;
            background-color: #fef3c7; /* ×¦×”×•×‘ ×‘×”×™×¨ */
            border: 1px solid #fcd34d;
            font-size: 0.875rem;
            text-align: right;
        }
    </style>
</head>
<body>

    <div id="game-app" class="game-container">
        <!-- ×ª×•×›×Ÿ ×”××©×—×§ ×™×™×˜×¢×Ÿ ×œ×›××Ÿ -->
    </div>

    <script>
        // --- ×× ×’× ×•×Ÿ ×’×œ×•×‘×œ×™ ×œ×˜×™×¤×•×œ ×‘×©×’×™××•×ª ×§×¨×™×˜×™×•×ª ---
        window.addEventListener('error', function(e) {
            const appElement = document.getElementById('game-app');
            if (appElement) {
                // ×”×¦×’×ª ×”×•×“×¢×ª ×©×’×™××” ×•×™×–×•××œ×™×ª ×¢×œ ×”××¡×š
                appElement.innerHTML = `
                    <div style="color: #991b1b; padding: 20px; text-align: center; background-color: #fee2e2; border: 2px solid #ef4444; border-radius: 8px;">
                        <h1 style="font-size: 24px; font-weight: bold;">×©×’×™××ª ×˜×¢×™× ×” ×§×¨×™×˜×™×ª! ğŸš¨</h1>
                        <p>×”××©×—×§ × ×›×©×œ ×‘×˜×¢×™× ×”. ×× × ×“×•×•×— ×¢×œ ×”×©×’×™××” ×”×‘××”:</p>
                        <p style="font-family: monospace; background: #fecaca; padding: 10px; border-radius: 4px; margin-top: 10px; overflow-wrap: break-word; color: #7f1d1d;">
                            ${e.message}
                        </p>
                        <p style="margin-top: 10px;">×‘×“×•×§ ××ª ×§×•× ×¡×•×œ×ª ×”××¤×ª×—×™× (F12) ×œ×¤×¨×˜×™× × ×•×¡×¤×™×.</p>
                    </div>
                `;
            }
            // ××•× ×¢ ××ª ×”×˜×™×¤×•×œ ×”××•×‘× ×” ×©×œ ×”×“×¤×“×¤×Ÿ ×‘×©×’×™××”
            e.preventDefault(); 
        });

        // ×”×’×“×¨×•×ª ×‘×¡×™×¡×™×•×ª
        const app = document.getElementById('game-app');
        let gameState = {
            currentQuest: 0,
            score: 0,
            inProgress: false,
        };

        // --- ××©×ª× ×™ ×§× ×‘×¡ ×’×œ×•×‘×œ×™×™× ---
        let canvas = null, ctx = null; // ××ª×—×•×œ ×›-null ×œ×× ×™×¢×ª ×©×’×™××•×ª ××•×§×“××•×ª
        let canvasState = {}; // ××¦×‘ ×”××©×—×§ ×”× ×•×›×—×™
        let keys = {}; // ××¢×§×‘ ××—×¨ ××§×©×™× ×œ×—×•×¦×™×
        let gameLoopId = null; // ××–×”×” ×œ×•×œ××ª ×”××©×—×§

        // ××©×ª× ×™ ×¢×–×¨ ×œ× ×™×§×•×™ ×××–×™× ×™ ×¢×›×‘×¨ ×•××’×¢
        let mouseHandlersAdded = false;

        // --- ×”×’×“×¨×•×ª ×§×•×•×¡×˜×™× ---
        const quests = [
            {
                id: 1,
                name: "×–××•×¡: ××¨×•×¥ ×”×‘×¨×§×™×",
                god: "×–××•×¡",
                icon: "âš¡ğŸƒ",
                description: "×–××•×¡, ×ª×•×š ×›×“×™ × ×™×¡×™×•×Ÿ ×œ×©×¤×¨ ××ª ×™×›×•×œ×•×ª×™×• ×‘×¨×©×ª×•×ª ×—×‘×¨×ª×™×•×ª, ×”×ª×¢×¦×‘×Ÿ ××˜×¨×•×œ ×•×©×œ×— ×¡×˜×•×¨× ×–×¢× ×“×™×’×™×˜×œ×™. ×”×‘×¨×§×™× ×™×¦××• ××©×œ×™×˜×”! ×¢×œ×™×š ×œ× ×•×•×˜ ×‘××”×™×¨×•×ª ×‘×™×Ÿ ×”×‘×¨×§×™× ×”×¤×¨××™×™× ×›×“×™ ×œ× ×§×– ××ª ×”×× ×¨×’×™×” ×”×¢×•×“×¤×ª ×•×œ×™×™×¦×‘ ××ª ×©××™ ×”××•×œ×™××¤×•×¡ ×œ×¤× ×™ ×©×”×›×•×œ ×™×™×©×¨×£. ×§×•×©×™ ×’×‘×•×”! ×¢×œ×™×š ×œ×”×ª×—××§ ×-15 ×‘×¨×§×™×! ××•×ª×¨×•×ª ×¨×§ 2 ×¤×’×™×¢×•×ª. ×§×¦×‘ ×”×‘×¨×§×™× ×’×“×œ ×‘××”×™×¨×•×ª.",
                type: "canvas_game",
                gameName: "zeus_dodge",
                target: 15 
            },
            {
                id: 2,
                name: "×”××“×¡: ××™×¡×•×£ × ×©××•×ª ×¢×œ ×¡×™×¨×ª ×¡×˜×™×§×¡",
                god: "×”××“×¡",
                icon: "ğŸ‘»ğŸ›¶",
                description: "×”××“×¡ ×¢×¨×š ×˜×•×¨× ×™×¨ ×¤×•×§×¨ ×œ×™×œ×™ ×•×”×¤×¡×™×“ ×‘×”×ª×¢×¨×‘×•×ª ××ª ×¡×“×¨ ××™×•×Ÿ ×”× ×©××•×ª. ×›×ª×•×¦××” ××›×š, ×’×™×‘×•×¨×™× ××’×“×™×™× (×©×¦×¨×™×›×™× ×œ×œ×›×ª ×œ×©×“×•×ª ××œ×™×¡×™×•×) × ×›× ×¡×™× ×‘×˜×¢×•×ª ×œ××¡×œ×•×œ ×©×œ ×”× ×©××•×ª ×”×¨×¢×•×ª (×”×’×•×œ×’×œ×•×ª ×”××“×•××•×ª). ×¢×œ×™×š ×œ×©×œ×•×˜ ×‘×¡×™×¨×” ×•×œ×”×—×–×™×¨ ××ª × ×©××•×ª ×”×’×™×‘×•×¨×™× (×¢×™×’×•×œ×™× ×™×¨×•×§×™×) ×œ××¡×œ×•×œ ×”× ×›×•×Ÿ, ×ª×•×š ×”×™×× ×¢×•×ª ××”×’×•×œ×’×œ×•×ª ×”×–×•×¢××•×ª! ×§×•×©×™ ×’×‘×•×”! ××¡×•×£ 8 × ×©××•×ª ×˜×•×‘×•×ª. ×”×¡×™×›×•×™ ×œ×”×™×ª×§×œ ×‘×’×•×œ×’×œ×•×ª ×¨×¢×•×ª ×”×•× 50/50. ×”××•×‘×™×™×§×˜×™× × ×¢×™× ××”×¨ ×™×•×ª×¨.",
                type: "canvas_game",
                gameName: "hades_collect",
                target: 8 
            },
            {
                id: 3,
                name: "××¨×˜××™×¡: ××ª×’×¨ ×™×¨×™ ×”×—×¦×™×",
                god: "××¨×˜××™×¡",
                icon: "ğŸ¹ğŸ¯",
                description: "××¨×˜××™×¡ ×¢×¨×›×” ×ª×—×¨×•×ª ×§×œ×™×¢×” ×›×•×©×œ×ª ×¢× ××¤×•×œ×• ×•×”×©×ª××©×” ×‘×™×”×œ×•××™ ×›×•×— ×›××˜×¨×•×ª × ×¢×•×ª. ×›××•×‘×Ÿ ×©×”× ×¤×¡×¤×¡×• ×”×›×œ ×•×”×™×”×œ×•××™× ×”×ª×¤×–×¨×• ×‘×©×“×” ××˜××•×¨×™× ××¡×•×›×Ÿ. ×¢×œ×™×š ×œ× ×•×¢ ×‘××”×™×¨×•×ª ×›×“×™ ×œ××¡×•×£ ××ª ×›×œ 12 ×”×™×”×œ×•××™× ×œ×¤× ×™ ×©×”× ×××‘×“×™× ××ª ×”×× ×¨×’×™×” ×©×œ×”×, ××• ×©××¤×•×œ×• ×™×›×¨×™×– ×¢×œ × ×™×¦×—×•×Ÿ ××˜×•×¤×©! ×§×•×©×™ ×’×‘×•×”! ××¡×•×£ 12 ×™×”×œ×•××™× × ×•×¦×¦×™× ×‘×ª×•×š 15 ×©× ×™×•×ª ×‘×œ×‘×“. ×”×“××•×ª ××¢×˜ ×§×˜× ×” ×™×•×ª×¨.",
                type: "canvas_game",
                gameName: "artemis_fetch",
                target: 12 
            },
             {
                id: 4,
                name: "×”×¨××¡: ×‘×¨×™×—×” ××¨×©×ª ×”×œ×™×™×–×¨",
                god: "×”×¨××¡",
                icon: "ğŸš€âš¡",
                description: "×”×¨××¡ ×’× ×‘ ××›×•× ×” ×œ×‘× ×™×™×ª ×©×‘×™×œ×™× ××™×™×“×™×™× ××”×¤×™×¡×˜×•×¡ ×•×”×¤×¢×™×œ ××•×ª×” ×‘×˜×¢×•×ª ×¢×œ ××¦×‘ '××‘×˜×—×” ×¢×•×™× ×ª'. ×”××›×•× ×” ××–×”×” ××•×ª×š ×›×¤×•×œ×© ×•××¤×¢×™×œ×” ×’×“×¨×•×ª ×œ×™×™×–×¨ ×× ×¨×’×˜×™×•×ª ×™×•×¨×“×•×ª! **×”×¨××¡ ×”×¤×¢×™×œ ×‘×š ×§××¢ ××”×™×¨×•×ª ×§×‘×•×¢, ×›×š ×©××ª×” ××”×™×¨ ×‘××™×•×—×“ ×œ××•×¨×š ×›×œ ×”××©×™××”! ×›×œ ×’×“×¨ ×œ×™×™×–×¨ ××›×™×œ×” ×©× ×™ ×¤×¢×¨×™× ×©×“×¨×›× × ×™×ª×Ÿ ×œ×¢×‘×•×¨.** ×¢×œ×™×š ×œ× ×•×•×˜ ×‘××”×™×¨×•×ª ×“×¨×š ×”×¤×¢×¨×™× ×”×¦×¤×•×¤×™× ×•×œ×”×ª×—××§ ×-15 ×’×“×¨×•×ª ×œ×™×™×–×¨ ×›×“×™ ×œ×”×©×‘×™×ª ××ª ×”××›×•× ×”. ××•×ª×¨×•×ª ×¨×§ 3 ×¤×’×™×¢×•×ª! ×§×¦×‘ ×”×’×“×¨×•×ª ×”×œ×™×™×–×¨ ×’×“×œ ×‘××”×™×¨×•×ª.",
                type: "canvas_game",
                gameName: "hermes_avoidance",
                target: 15 
            },
            {
                id: 5,
                name: "××¤×¨×•×“×™×˜×”: × ×™×§×•×™ ×”×‘×œ×’×Ÿ ×”×¨×•×× ×˜×™",
                god: "××¤×¨×•×“×™×˜×”",
                icon: "ğŸ’–ğŸŒ¹",
                description: "××¤×¨×•×“×™×˜×” × ×™×¡×ª×” ×œ×”×›×™×Ÿ ×©×™×§×•×™ ××”×‘×” ×¨×‘ ×¢×•×¦××”, ××‘×œ × ×¨×“××” ×•×”×—×•××¨×™× ×”×ª×¤×–×¨×• ×‘×¨×•×—. ×¢×œ×™×š ×œ× ×•×•×˜ ×‘××”×™×¨×•×ª ×•×œ××¡×•×£ 15 ××¨×›×™×‘×™×: 8 ×œ×‘×‘×•×ª ×•-7 ×¤×¨×—×™×. ××ª×” ×™×›×•×œ ×œ××¡×•×£ ×¨×§ ×¡×•×’ ××—×“ ×‘×›×œ ×¤×¢×, ×•×”×—×œ×¤×” ×‘×™×Ÿ ×¡×•×’×™ ×”××™×¡×•×£ (××§×© ×¨×•×•×—) ×œ×•×§×—×ª ×©× ×™×™×” ×™×§×¨×”! ×¡×™×™× ×‘-20 ×©× ×™×•×ª. ×§×•×©×™: ×’×‘×•×” ×××•×“.",
                type: "canvas_game",
                gameName: "aphrodite_clean",
                target: 15 
            },
            {
                id: 6,
                name: "×¤×•×¡×™×“×•×Ÿ: × ×—×©×•×œ×™ ×”××¦×•×ª ×”×–×•×¢××™×",
                god: "×¤×•×¡×™×“×•×Ÿ",
                icon: "ğŸŒŠğŸ”±",
                description: "×¤×•×¡×™×“×•×Ÿ ×¨×‘ ×¢× ×“×™×™×’ ×¢×œ ×˜×¢× ×›×¨×™×š ×˜×•× ×”, ×•×©×œ×— ×¦×•× ×××™ ×©×œ ××¦×•×ª ×©×¡×•×ª× ××ª ×›×œ × ×ª×™×‘×™ ×”×™×. ×¢×œ×™×š ×œ× ×•×•×˜ ×× ×›×™×ª (×œ××¢×œ×”/×œ××˜×”) ×‘××¢×‘×¨ ×™××™ ×¦×¨ ×›×“×™ ×œ×”×™×× ×¢ ×-20 ×’×•×©×™× ×©×œ ××¦×•×ª ×•×¡×œ×¢×™× ×©×‘××™× ×‘××”×™×¨×•×ª ×œ×¨×•×—×‘! ×–×”×™×¨×•×ª: ××ª×” ×–×– ×¨×§ ×œ××¢×œ×” ×•×œ××˜×”!",
                type: "canvas_game",
                gameName: "poseidon_dodge",
                target: 20 
            },
             {
                id: 7,
                name: "×“×™×•× ×™×¡×•×¡: ××¨×ª×•×Ÿ ×”×‘×¨×× ×™× ×”×§×•×¡××™",
                god: "×“×™×•× ×™×¡×•×¡",
                icon: "ğŸ·âš”ï¸",
                description: "×“×™×•× ×™×¡×•×¡ × ×˜×© ××ª ×”×™×™×Ÿ ×”××¡×•×¨×ª×™ ×•×”××¦×™× ×§×•×§×˜×™×™×œ '××•×—×™×˜×•-×™×•×•× ×™'. ×¢×œ×™×š ×œ×‘×©×œ 3 ×§×•×§×˜×™×™×œ×™× ×‘-25 ×©× ×™×•×ª! ××¡×•×£ ××ª ×©×œ×•×©×ª ×”××¨×›×™×‘×™× (ğŸ‡, â˜ï¸, âš¡) ×•×’×© ×œ××™×›×œ ×”×¢×¨×‘×•×‘ (×”××œ×‘×Ÿ ×”××¨×›×–×™). **×—×•×‘×” ×œ×¢××•×“ ×‘××™×›×œ ×œ××©×š 2 ×©× ×™×•×ª** ×›×“×™ ×œ×¡×™×™× ××ª ×”×¢×¨×‘×•×‘. **×–×”×™×¨×•×ª: ×”××œ ××¨×¡ ×›×•×¢×¡ ×¢×œ ×”×©×˜×•×ª ×•×ª×•×§×£ ××•×ª×š ×¢× ×—×¨×‘×•×ª!** ×¤×’×™×¢×” ××—×¨×‘ ×××¤×¡×ª ××ª ×”××œ××™ ×©×œ×š ×•××‘×˜×œ×ª ××ª ×”×¢×¨×‘×•×‘.",
                type: "canvas_game",
                gameName: "dionysus_cocktail",
                target: 3 
            },
            {
                id: 8,
                name: "×”×¤×™×¡×˜×•×¡: ×”×¨×›×‘×ª ×”×¨×•×‘×•×˜ ×”×× ×¦×—",
                god: "×”×¤×™×¡×˜×•×¡",
                icon: "âš™ï¸ğŸ› ï¸",
                description: "×”×¤×™×¡×˜×•×¡ ×©×›×— ××ª ×ª×—×¨×•×ª ×‘× ×™×™×ª ×”×¨×•×‘×•×˜×™×! ×¢×œ×™×š ×œ×”×¨×›×™×‘ ×¨×•×‘×•×˜ ×-4 ×—×œ×§×™×: ×’×•×£, ×’×œ×’×œ×™×, ×–×¨×•×¢×•×ª ×•×¨××©. ×œ××—×¨ ×”×”×¨×›×‘×”, ×”×¨×•×‘×•×˜ ×™×¦×˜×¨×š ×œ×¢×‘×•×¨ 3 ××›×©×•×œ×™×. **×–×”×™×¨×•×ª: ×”×—×™×‘×•×¨ ×”×œ× × ×›×•×Ÿ ×™×’×¨×•× ×œ×›×©×œ!** (×œ××©×œ, ×’×œ×’×œ×™ ×©×˜×— ×‘××™×¨×•×¥ ××”×™×¨×•×ª). ×”×¨×›×‘ ××ª ×”×¨×•×‘×•×˜ ×ª×•×š 20 ×©× ×™×•×ª. ×’×¨×•×¨ ××ª ×”×—×œ×§×™× ×œ×¢×™×’×•×œ×™× ×‘××¨×›×–.",
                type: "canvas_game",
                gameName: "hephaestus_build",
                target: 3 // ××¡×¤×¨ ×”××›×©×•×œ×™× ×©×”×¨×•×‘×•×˜ ×¦×¨×™×š ×œ×¢×‘×•×¨
            },
            // --- ×§×•×•×¡×˜ 9: ××¨×¡ - ×“×•-×§×¨×‘ ×”×–×¢× (×—×“×©) ---
            {
                id: 9,
                name: "××¨×¡: ×“×•-×§×¨×‘ ×”×–×¢×",
                god: "××¨×¡",
                icon: "âš”ï¸ğŸ›¡ï¸",
                description: "××¨×¡ ×›×•×¢×¡ ×¢×œ×™×š ×¢×œ ×©×¢×–×¨×ª ×œ×“×™×•× ×™×¡×•×¡! ×”×•× ××–××™×Ÿ ××•×ª×š ×œ×“×•-×§×¨×‘ ×‘×©×“×” ×”×§×¨×‘. ×¢×œ×™×š ×œ×”×‘×™×¡ ××ª ××¨×¡ ×‘×××¦×¢×•×ª ×™×¨×™ ×—×¦×™× ×× ×¨×’×˜×™×™×, ×ª×•×š ×”×ª×—××§×•×ª ××”×ª×§×¤×•×ª ×”×—×¨×‘ ×©×œ×•. × ×¦×— ×‘×“×•-×§×¨×‘ ×›×“×™ ×œ×¡×™×™× ××ª ×”×‘×œ×’×Ÿ ×”××•×œ×™××¤×™!",
                type: "canvas_game",
                gameName: "ares_duel",
                target: 1 // × ×™×¦×—×•×Ÿ ××—×“
            }
        ];

        // --- ×¤×•× ×§×¦×™×•×ª ×¢×–×¨ ×›×œ×œ×™×•×ª ---

        // ×¤×•× ×§×¦×™×” ×œ×”×¡×¨×ª ×××–×™× ×™ ×”×¢×›×‘×¨/××’×¢
        function removeMouseListeners() {
            if (!canvas || !mouseHandlersAdded) return; 
            // ×”×•×¡×¨: canvas.removeEventListener('mousedown', handleMouseDownHephaestus);
            // ×”×•×¡×¨: canvas.removeEventListener('mousemove', handleMouseMoveHephaestus);
            // ×”×•×¡×¨: canvas.removeEventListener('mouseup', handleMouseUpHephaestus);
            // ×”×•×¡×¨: canvas.removeEventListener('touchstart', handleMouseDownHephaestus);
            // ×”×•×¡×¨: canvas.removeEventListener('touchmove', handleMouseMoveHephaestus);
            // ×”×•×¡×¨: canvas.removeEventListener('touchend', handleMouseUpHephaestus);
            mouseHandlersAdded = false;
        }

        function renderScreen(htmlContent) {
            // ×‘×™×˜×•×œ ×œ×•×œ××ª ××©×—×§ ×§×•×“××ª ×œ×¤× ×™ ×¨×™× ×“×•×¨ ××¡×š ×—×“×©
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            // ×”×¡×¨×ª ×××–×™× ×™× ×§×•×“××™× ×œ××§×©×™× ×•×œ×¢×›×‘×¨
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            removeMouseListeners(); // ×”×¡×¨×ª ×××–×™× ×™ ×”-DND ×× ×”×™×•

            app.innerHTML = htmlContent;
        }

        function createActionButton(text, onClick) {
            return `
                <button onclick="${onClick}"
                    class="action-btn mt-6 w-full md:w-auto shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-300">
                    ${text}
                </button>
            `;
        }
        
        // ×¤×•× ×§×¦×™×” ×’×œ×•×‘×œ×™×ª ×œ××™×¤×•×¡ ×§×•×•×¡×˜ ×”×¤×™×¡×˜×•×¡ (××©××© ×‘×›×¤×ª×•×¨ RESET ×‘×ª×•×š ×”×§×•×•×¡×˜)
        function resetHephaestusQuest() {
            // ×–×”×” ×œ-resetCurrentQuest ××‘×œ ×©× ×™×•×ª×¨ ×‘×¨×•×¨
             gameState.currentQuest = 8;
             renderQuest();
        }
        

        // --- ×œ×•×’×™×§×ª ××©×—×§ ××¨×›×–×™×ª ---

        function renderIntro() {
            gameState.inProgress = false;
            const content = `
                <div class="space-y-6">
                    <h1 class="text-4xl font-bold text-gray-800">×‘×¨×•×›×™× ×”×‘××™× ×œ<span class="text-red-600">×”×‘×œ×’×Ÿ ×”××•×œ×™××¤×™</span></h1>
                    <p class="text-lg text-gray-600">
                        ××œ×™ ×”××•×œ×™××¤×•×¡ ×™×¦×¨×• ×©×™×‘×•×©×™×. ×¢×œ×™×š ×œ×©×œ×•×˜ ×‘×’×™×‘×•×¨ ×‘×××¦×¢×•×ª **××™× ×™-××©×—×§×™× ×“×™× ××™×™×** ×›×“×™ ×œ×ª×§×Ÿ ××ª ×”× ×–×§!
                    </p>
                    <div class="text-xl font-semibold text-blue-700">
                        ××˜×¨×ª×š: ×”×©×œ× ××ª ×›×œ ${quests.length} ×”×§×•×•×¡×˜×™× ×”×××ª×’×¨×™×!
                    </div>
                    ${createActionButton("×”×ª×—×œ ××¡×¢", "startQuest()")}
                </div>
            `;
            renderScreen(content);
        }

        function startQuest() {
            gameState.currentQuest = 1;
            gameState.score = 0;
            gameState.inProgress = true;
            renderQuest();
        }

        function renderCompletionScreen() {
            const content = `
                <div class="space-y-6">
                    <h1 class="text-5xl font-extrabold text-green-600">ğŸ‰ ×›×œ ×”×›×‘×•×“! ×”×§×•×•×¡×˜ ×”×•×©×œ×! ğŸ‰</h1>
                    <p class="text-2xl text-gray-700">
                        ×”×¦×œ×—×ª ×œ×ª×§×Ÿ ××ª ×›×œ ${quests.length} ×”×©×™×‘×•×©×™× ×”×§×•×¡××™×™×!
                    </p>
                    <div class="text-2xl text-red-600 font-bold">
                        × ×™×§×•×“ ×¡×•×¤×™: ${gameState.score}
                    </div>
                    ${createActionButton("×©×—×§ ×©×•×‘", "renderIntro()")}
                </div>
            `;
            renderScreen(content);
        }

        function handleQuestResult(isCorrect, message, points = 100) {
            // ×¢×¦×™×¨×ª ×œ×•×œ××ª ××©×—×§ ×¡×¤×¦×™×¤×™×ª
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            // ×”×¡×¨×ª ×›×œ ×”×××–×™× ×™× ×œ×¤× ×™ ×”×¦×’×ª ×ª×•×¦××”
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            removeMouseListeners();
            
            let resultHtml;
            // ×× ×–×” ×›×™×©×œ×•×Ÿ, ×›×¤×ª×•×¨ '× ×¡×” ×©×•×‘' ××¤× ×” ×œ-resetCurrentQuest
            if (isCorrect) {
                gameState.score += points;
                resultHtml = `
                    <div class="p-4 bg-green-100 border-r-4 border-green-500 text-green-800 mt-6 rounded-lg">
                        <p class="font-bold">âœ¨ ×”×¦×œ×—×”!</p>
                        <p>${message}</p>
                    </div>
                    ${createActionButton("×”××©×š ×œ×§×•×•×¡×˜ ×”×‘×", "nextQuest()")}
                `;
            } else {
                resultHtml = `
                    <div class="p-4 bg-red-100 border-r-4 border-red-500 text-red-800 mt-6 rounded-lg">
                        <p class="font-bold">âŒ ×›×™×©×œ×•×Ÿ...</p>
                        <p>${message}</p>
                    </div>
                    ${createActionButton("× ×¡×” ×©×•×‘", "resetCurrentQuest()")}
                `;
            }
            // ×¢×“×›×•×Ÿ ××–×•×¨ ×”×ª×•×¦××”
            const questArea = app.querySelector('#quest-area');
            if (questArea) {
                questArea.innerHTML = resultHtml;
            } else {
                 app.querySelector('.game-container').innerHTML += resultHtml;
            }
        }

        function nextQuest() {
            gameState.currentQuest++;
            renderQuest();
        }

        function resetCurrentQuest() {
            renderQuest(); // ×¤×©×•×˜ ×¨×™× ×“×•×¨ ××—×“×© ×©×œ ×”×§×•×•×¡×˜ ×™××ª×—×œ ××ª ×”×›×œ
        }

        function renderQuest() {
            if (gameState.currentQuest > quests.length) {
                renderCompletionScreen();
                return;
            }

            const quest = quests[gameState.currentQuest - 1];
            let questHtml = '';

            // ×›×•×ª×¨×ª ×›×œ×œ×™×ª
            const header = `
                <div class="text-right mb-4 text-sm font-medium text-gray-500">
                    ×§×•×•×¡×˜ ${quest.id} ××ª×•×š ${quests.length}
                </div>
                <h2 class="quest-title flex items-center justify-center gap-3">
                    <span class="text-3xl">${quest.icon}</span> ${quest.name}
                </h2>
                <p class="quest-description text-gray-700">${quest.description}</p>
                <div class="h-0.5 bg-gray-200 w-full mb-6"></div>
            `;

            if (quest.type === 'canvas_game') {
                questHtml = renderCanvasGame(quest);
                renderScreen(header + questHtml);
                setupGame(quest.gameName); // ×¨×§ ××›×™×Ÿ ××ª ×”×§× ×‘×¡, ×œ× ××ª×—×™×œ ××ª ×”×œ×•×œ××”
            }
        }

        // --- ×œ×•×’×™×§×ª ××™× ×™-××©×—×§×™ ×§× ×‘×¡ ---

        function renderCanvasGame(quest) {
            // ×‘×§×•×•×¡×˜ ×”×¤×™×¡×˜×•×¡ ××™×Ÿ ×¦×•×¨×š ×‘×œ×—×¦× ×™ ××•×‘×™×™×œ ×œ×›×Ÿ × ×¡×ª×™×¨ ××•×ª×
            const showTouchControls = (quest.gameName !== 'hephaestus_build');
            // ×‘×§×•×•×¡×˜ ×”×¤×™×¡×˜×•×¡ ×× ×—× ×• ××©×ª××©×™× ×‘×›×¤×ª×•×¨ ×œ×‘×“×™×§×ª ×”×¨×•×‘×•×˜, ×•×œ× ×›×›×¤×ª×•×¨ "×”×ª×—×œ"
            const showStartButton = (quest.gameName !== 'hephaestus_build');

            // ×¢×“×›×•×Ÿ ×”×•×¨××•×ª ×©×œ×™×˜×” ×‘×”×ª×× ×œ×§×•×•×¡×˜ ×”×¤×™×¡×˜×•×¡
            const controlInstructions = quest.gameName === 'hephaestus_build' ? 
                '×”×©×ª××©×• ×‘××§×©×™ ×”×—×™×¦×™× (â† â†‘ â†’ â†“) ×›×“×™ ×œ× ×•×•×˜. ×œ×—×¦×• **×¨×•×•×—** ×›×“×™ ×œ××¡×•×£/×œ×©×—×¨×¨ ×—×œ×§ ×¨×•×‘×•×˜.' : 
                '×”×©×ª××© ×‘××§×©×™ ×”×—×™×¦×™× (â† â†‘ â†’ â†“) ×›×“×™ ×œ×©×œ×•×˜ ×‘×“××•×ª. ×§×œ×™×§ ×¢×œ ×”××§×©×™× ×œ××˜×” ×¢×‘×•×¨ ××•×‘×™×™×œ. (××§×© ×¨×•×•×— ×œ×§×•×•×¡×˜ ×©×œ ××¤×¨×•×“×™×˜×”/××¨×¡).';
            
            // ×›×¤×ª×•×¨ ××™×¤×•×¡ ×œ×§×•×•×¡×˜ ×”×¤×™×¡×˜×•×¡
            const hephaestusResetButton = quest.gameName === 'hephaestus_build' ? 
                `<button onclick="resetHephaestusQuest()" class="action-btn bg-red-500 hover:bg-red-600 focus:ring-red-300 w-full md:w-auto text-base mt-2">××™×¤×•×¡ (RESET)</button>` : '';

            return `
                <div class="flex flex-col items-center space-y-4">
                    <canvas id="gameCanvas" width="350" height="350" 
                        class="border-4 border-gray-900 bg-gray-100 rounded-lg shadow-inner w-full max-w-sm"></canvas>
                    <div id="game-info" class="text-lg font-bold text-red-600">
                        ${quest.gameName === 'hephaestus_build' ? '×‘× ×” ××ª ×”×¨×•×‘×•×˜ ×©×œ×š!' : '×œ×—×¥ \'×”×ª×—×œ ×§×•×•×¡×˜\' ×›×“×™ ×œ×”×ª×—×™×œ!'}
                    </div>
                    <div id="quest-area">
                        <div class="flex flex-col md:flex-row justify-center gap-4">
                            <button onclick="${quest.gameName === 'hephaestus_build' ? 'checkBuildCompletion()' : `startGameLogic('${quest.gameName}')`}" id="start-game-btn"
                                class="action-btn w-64 h-14 text-xl bg-blue-700 hover:bg-blue-800 focus:ring-blue-300 transition duration-150 transform hover:scale-105"
                                style="display: ${showStartButton ? 'block' : 'none'};">
                                ${showStartButton ? '×”×ª×—×œ ×§×•×•×¡×˜' : '×”×ª×—×œ ××™×¨×•×¥ ×¨×•×‘×•×˜!'}
                            </button>
                            ${hephaestusResetButton}
                        </div>
                        <p class="text-sm text-gray-500 mt-4">${controlInstructions}</p>
                        <!-- ×›×¤×ª×•×¨×™ ×©×œ×™×˜×” ×œ××¡×›×™ ××’×¢ -->
                        <div class="touch-controls flex justify-center mt-4 space-x-4 ${showTouchControls ? '' : 'hidden'} md:hidden">
                            <button onmousedown="handleTouchMove(0)" ontouchstart="handleTouchMove(0)" ontouchend="handleTouchStop()">â†</button>
                            <div class="flex flex-col space-y-2">
                                <button onmousedown="handleTouchMove(1)" ontouchstart="handleTouchMove(1)" ontouchend="handleTouchStop()">â†‘</button>
                                <button onmousedown="handleTouchMove(3)" ontouchstart="handleTouchMove(3)" ontouchend="handleTouchStop()">â†“</button>
                            </div>
                            <button onmousedown="handleTouchMove(2)" ontouchstart="handleTouchMove(2)" ontouchend="handleTouchStop()">â†’</button>
                            <!-- ×”×•×¡×¤×ª ×›×¤×ª×•×¨ "×¨×•×•×—" ×œ××’×¢ ×œ×¦×•×¨×š ××™×¡×•×£/×©×—×¨×•×¨ -->
                            <button onmousedown="handleSpacePress()" ontouchstart="handleSpacePress()" ontouchend="handleSpaceRelease()">âš¡</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // ×¤×•× ×§×¦×™×•×ª ×©×œ×™×˜×” ×œ××¡×š ××’×¢ (×œ×ª× ×•×¢×”, ×œ× DND)
        function handleTouchMove(direction) {
            // 0: ×©×××œ, 1: ×œ××¢×œ×”, 2: ×™××™×Ÿ, 3: ×œ××˜×”
            keys = { ArrowLeft: false, ArrowUp: false, ArrowRight: false, ArrowDown: false };
            if (direction === 0) keys.ArrowLeft = true;
            if (direction === 1) keys.ArrowUp = true;
            if (direction === 2) keys.ArrowRight = true;
            if (direction === 3) keys.ArrowDown = true;
        }

        function handleTouchStop() {
            keys = {};
        }

        // --- ×˜×™×¤×•×œ ×‘×œ×—×™×¦×ª ×¨×•×•×— ×‘××’×¢ ---
        function handleSpacePress() {
             keys[' '] = true;
             // ×¢×‘×•×¨ ×§×•×•×¡×˜ ×”×¤×™×¡×˜×•×¡, ×”×¤×¢×œ×ª ×”×œ×•×’×™×§×” ×‘××•×¤×Ÿ ××™×™×“×™ ×‘-update
             if(gameState.currentQuest === 8) {
                // ×—×™×™×‘×™× ×œ×§×¨×•× ×œ×¢×“×›×•×Ÿ ×™×“× ×™ ×›×™ ××™×Ÿ ×œ×•×œ××ª ××©×—×§ ×‘-BUILD
                // ×©×™××• ×œ×‘: ×”×§×•×“ ××ª×—×ª ××¢×‘×™×¨ 0 ×›×˜×™×™××¡×˜×××¤, ×–×” ×‘×¡×“×¨ ×›×™ ×œ×•×’×™×§×ª ×”-BUILD ×œ× ××©×ª××©×ª ×‘×•
                updateHephaestusBuild(0); 
                keys[' '] = false; // ××™×¤×•×¡ ××™×™×“×™ ×œ××—×¨ ×©×™××•×©
             }
        }
        function handleSpaceRelease() {
            // ×¢×‘×•×¨ ×§×•×•×¡×˜×™× ×›××• ××¤×¨×•×“×™×˜×”, ××™×¤×•×¡ ×”××§×© ×™×§×¨×” ×‘×ª×•×š ×”×œ×•×œ××”.
             keys[' '] = false; 
        }
        // --- ×¡×•×£ ×˜×™×¤×•×œ ××’×¢ ×¨×•×•×— ---

        function setupGame(gameName) {
            canvas = document.getElementById('gameCanvas');
            // ×‘×“×™×§×” ×§×¨×™×˜×™×ª: ×”×× ×”×§× ×‘×¡ × ××¦×?
            if (!canvas) return; 
            
            ctx = canvas.getContext('2d');
            
            // ××™×¤×•×¡ ××¦×‘ ××§×©×™×
            keys = {};

            // ×”×¡×¨×ª ×•×”×•×¡×¤×ª ×××–×™× ×™×
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            
            // ××ª×—×•×œ ×”××©×—×§ ×”×¡×¤×¦×™×¤×™
            switch (gameName) {
                case 'zeus_dodge':
                    initZeusDodge();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hades_collect':
                    initHadesCollect();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'artemis_fetch':
                    initArtemisFetch();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hermes_avoidance': 
                    initHermesAvoidance();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'aphrodite_clean':
                    initAphroditeClean();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'poseidon_dodge':
                    initPoseidonDodge();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'dionysus_cocktail':
                    initDionysusCocktail();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hephaestus_build':
                    initHephaestusBuild();
                    // ×©×™× ×•×™: ×”×•×¡×¤×ª ×××–×™× ×™ ××§×©×™× ×œ×©×œ×™×˜×” ×‘×‘× ×™×™×”
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'ares_duel': // ×§×•×•×¡×˜ 9 ×”×—×“×©
                    initAresDuel();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
            }
            
            // ×¦×™×•×¨ ×¨××©×•× ×™ ×©×œ ×”××¡×š ×œ×¤× ×™ ×”×”×ª×—×œ×”, ×¨×§ ×× ×¤×•× ×§×¦×™×™×ª ×¦×™×•×¨ ×§×™×™××ª
            if (canvasState.draw) canvasState.draw();
        }

        // --- ×©×™× ×•×™: startGameLogic × ×©××¨ ×¨×§ ×œ××©×—×§×™ ×œ×•×œ××” ---
        function startGameLogic(gameName) {
            // ××›× ×™×¡ ××ª ×”×œ×•×’×™×§×” ×©×œ ×”×ª×—×œ×ª ×”××©×—×§ (×©×œ×™×˜×” ×‘×›×¤×ª×•×¨)
            const btn = document.getElementById('start-game-btn');
            const info = document.getElementById('game-info');
            
            if (btn) btn.style.display = 'none';
            if (info) info.textContent = '×”××©×—×§ ×‘×¢×™×¦×•××•!';

            // ×”×’×“×¨×ª isRunning ×œ-true ×•×”×ª×—×œ×ª ×”×œ×•×œ××”
            canvasState.isRunning = true;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function handleKeyDown(e) {
            // ×× ×™×¢×ª ×’×œ×™×œ×ª ×”×¢××•×“ ×‘×¢×ª ×©×™××•×© ×‘×—×¦×™×
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            keys[e.key] = true;
        }

        function handleKeyUp(e) {
            // ×¢×‘×•×¨ ×§×•×•×¡×˜ ×”×¤×™×¡×˜×•×¡, ×œ× × ××¤×¡ ×›××Ÿ ××ª ×”×¨×•×•×— ×›×“×™ ×©×”×œ×—×™×¦×” ×ª×¢×‘×•×“ ×¤×¢× ××—×ª
            if(e.key === ' ' && gameState.currentQuest === 8) {
                // × ×™×ª×•×§ ×”×œ×—×™×¦×” ×™×˜×•×¤×œ ×‘×ª×•×š ×”-updateHephaestusBuild ×× ×¦×¨×™×š
                return; 
            }
            // ×¢×‘×•×¨ ×§×•×•×¡×˜ ××¨×¡, ×¦×¨×™×š ×œ××¤×©×¨ ×™×¨×™ ×—×•×–×¨
            if(e.key === ' ' && gameState.currentQuest === 9) {
                return;
            }

            keys[e.key] = false;
        }

        // --- ×œ×•×œ××ª ×”××©×—×§ ×”×¨××©×™×ª ---
        function gameLoop() {
            if (canvasState.isRunning) {
                // ×¢×“×›×•×Ÿ ×•×œ×•×’×™×§×ª ××©×—×§
                canvasState.update(performance.now()); // ××¢×‘×™×¨ timestamp
                // ×¦×™×•×¨
                canvasState.draw();
                // ×”××©×š ×”×œ×•×œ××”
                gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                // ×”××©×—×§ ×”×¡×ª×™×™× (× ×¦×—×•×Ÿ ××• ×”×¤×¡×“)
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
        }

        // --- ×¢×–×¨: ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª ×¨×™×‘×•×¢-×¨×™×‘×•×¢ ---
        function checkCollision(r1, r2) {
            // ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª ××œ×‘× ×™× ×¡×˜× ×“×¨×˜×™×ª
            return r1.x < r2.x + r2.w &&
                   r1.x + r1.w > r2.x &&
                   r1.y < r2.y + r2.h &&
                   r1.y + r1.h > r2.y;
        }

        // --- ×¦×™×•×¨ ×“××•×ª (××©×•×ª×£ ×œ×–××•×¡, ××¨×˜××™×¡, ××¤×¨×•×“×™×˜×”, ×¤×•×¡×™×“×•×Ÿ, ×”×¨××¡, ×“×™×•× ×™×¡×•×¡) ---
        function drawPlayerFigure(player, isBoosted = false) {
            if (!ctx) return; // ×”×’× ×”
            const centerX = player.x + player.w / 2;
            
            // ×§×‘×™×¢×ª ×¦×‘×¢ ×”×“××•×ª ×‘×”×ª×× ×œ××¦×‘ ×”×—×™×–×•×§
            let bodyColor = isBoosted ? '#FFFFFF' : player.color;
            let headColor = isBoosted ? '#FFEA00' : '#FFD700';
            
            // 1. ×’×•×£ (××œ×‘×Ÿ ×©××™×™×¦×’ ×˜×•× ×™×§×”/×©×¨×™×•×Ÿ)
            ctx.fillStyle = bodyColor; 
            ctx.fillRect(player.x + 5, player.y + 10, player.w - 10, player.h - 15);

            // 2. ×¨××© (×§×¡×“×” ××•×–×”×‘×ª)
            ctx.beginPath();
            ctx.arc(centerX, player.y + 7, 7, 0, Math.PI * 2);
            ctx.fillStyle = headColor;
            
            // ××¤×§×˜ ×–×•×”×¨ ×›×©×”×•× ××—×•×–×§ (×œ×¦×•×¨×š Hermes)
            ctx.shadowColor = isBoosted ? '#FFFFFF' : '#FFD700';
            ctx.shadowBlur = isBoosted ? 15 : 8;
            
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0; // ××™×¤×•×¡ ×¦×œ

            // 3. ×¨×’×œ×™×™× (×§×•×•×™× ×¤×©×•×˜×™×)
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 5, player.y + player.h - 5);
            ctx.lineTo(centerX - 5, player.y + player.h);
            ctx.moveTo(centerX + 5, player.y + player.h - 5);
            ctx.lineTo(centerX + 5, player.y + player.h);
            ctx.stroke();
        }

        // --- ×§×•×•×¡×˜ 1: ×–××•×¡ - ××¨×•×¥ ×”×‘×¨×§×™× ---
        function initZeusDodge() {
            const quest = quests[0];
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#007bff', speed: 4 }, 
                lightning: [],
                strikesDodged: 0,
                hits: 0,
                maxHits: 2, 
                lastSpawn: 0,
                spawnRate: 500, 
                update: updateZeusDodge,
                draw: drawZeusDodge,
            };
        }

        function updateZeusDodge(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // ×ª× ×•×¢×ª ×©×—×§×Ÿ
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // ×™×¦×™×¨×ª ×‘×¨×§×™×
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                canvasState.lightning.push({
                    x: Math.random() * (canvas.width - 20) + 10, 
                    y: -10,
                    w: 8, 
                    h: 35,
                    speed: 4 + Math.random() * 2.5, 
                    color: '#FFEA00' 
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(150, canvasState.spawnRate - 15); 
            }

            // ×¢×“×›×•×Ÿ ××™×§×•× ×‘×¨×§×™× ×•×‘×“×™×§×ª ×”×ª× ×’×©×•×ª
            for (let i = canvasState.lightning.length - 1; i >= 0; i--) {
                const bolt = canvasState.lightning[i];
                bolt.y += bolt.speed;

                if (checkCollision(player, bolt)) {
                    // ×¤×’×™×¢×”
                    canvasState.hits++;
                    canvasState.lightning.splice(i, 1);
                    if (canvasState.hits >= canvasState.maxHits) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `×—×˜×¤×ª ${canvasState.hits} ×¤×’×™×¢×•×ª! ×–××•×¡ ×××œ××œ ××©×”×• ×¢×œ '××©×—×§ ×”×•×’×Ÿ'. × ×¡×” ×©×•×‘.`);
                        return;
                    }
                } else if (bolt.y > canvas.height) {
                    // ×‘×¨×§ ×™×¦× ××”××¡×š
                    canvasState.strikesDodged++;
                    canvasState.lightning.splice(i, 1);
                    if (canvasState.strikesDodged >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `×”×ª×—××§×ª ×-15 ×‘×¨×§×™×! ×–××•×¡ ×—×–×¨ ×œ×©×œ×•×˜ ×‘××–×’ ×”××•×•×™×¨. × ×™×§×•×“: 200`, 200);
                    }
                }
            }
        }

        function drawZeusDodge() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ×¦×™×•×¨ ×‘×¨×§×™×
            canvasState.lightning.forEach(bolt => {
                ctx.fillStyle = bolt.color;
                ctx.fillRect(bolt.x, bolt.y, bolt.w, bolt.h);
            });

            // ×¦×™×•×¨ ×©×—×§×Ÿ (×“××•×ª)
            drawPlayerFigure(canvasState.player);

            // ×¢×“×›×•×Ÿ ××™×“×¢
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `×”×ª×—××§×•×ª: ${canvasState.strikesDodged} / ${quest.target} | ×¤×’×™×¢×•×ª: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }

        // --- ×§×•×•×¡×˜ 2: ×”××“×¡ - ××™×¡×•×£ × ×©××•×ª ---
        function initHadesCollect() {
            const quest = quests[1];
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 17.5, y: canvas.height - 40, w: 35, h: 18, color: '#3b82f6', speed: 4.5 }, 
                collectibles: [], 
                obstacles: [], 
                soulsCollected: 0,
                badSoulsHit: 0,
                maxBadSouls: 3,
                lastSpawn: 0,
                spawnRate: 650, 
                update: updateHadesCollect,
                draw: drawHadesCollect,
            };
        }

        function updateHadesCollect(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // ×ª× ×•×¢×ª ×©×—×§×Ÿ
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;

            // ×™×¦×™×¨×ª ××•×‘×™×™×§×˜×™×
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const x = Math.random() * (canvas.width - 20);
                const isCollectible = Math.random() > 0.5; 
                const item = { x, y: -20, r: 10, speed: 2.5 + Math.random() * 2 }; 

                if (isCollectible) {
                    canvasState.collectibles.push({ ...item, w: item.r*2, h: item.r*2, color: '#10b981' }); 
                } else {
                    canvasState.obstacles.push({ ...item, w: item.r*2, h: item.r*2, color: '#ef4444' }); 
                }

                canvasState.lastSpawn = timestamp;
            }

            // ×¢×“×›×•×Ÿ ×•××™×¡×•×£
            for (let i = canvasState.collectibles.length - 1; i >= 0; i--) {
                const item = canvasState.collectibles[i];
                item.y += item.speed;

                // ×‘×“×™×§×ª ××™×¡×•×£ 
                if (checkCollision(player, item)) {
                    canvasState.soulsCollected++;
                    canvasState.collectibles.splice(i, 1);
                    if (canvasState.soulsCollected >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `××¡×¤×ª 8 × ×©××•×ª ×˜×•×‘×•×ª! ×”××“×¡ ××©×‘×— ××ª ×¡×“×¨× ×•×ª×š. × ×™×§×•×“: 300`, 300);
                        return;
                    }
                } else if (item.y > canvas.height) {
                    canvasState.collectibles.splice(i, 1);
                }
            }

            // ×¢×“×›×•×Ÿ ×•×”×™×× ×¢×•×ª
            for (let i = canvasState.obstacles.length - 1; i >= 0; i--) {
                const item = canvasState.obstacles[i];
                item.y += item.speed;

                // ×‘×“×™×§×ª ×¤×’×™×¢×”
                 if (checkCollision(player, item)) {
                    canvasState.badSoulsHit++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.badSoulsHit >= canvasState.maxBadSouls) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `×¤×’×¢×ª ×‘-3 ×’×•×œ×’×œ×•×ª! ×¡×™×¨×ª ×¡×˜×™×§×¡ × ×©×‘×¨×”. × ×¡×” ×©×•×‘.`);
                        return;
                    }
                } else if (item.y > canvas.height) {
                    canvasState.obstacles.splice(i, 1);
                }
            }
        }

        function drawHadesCollect() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ×¦×™×•×¨ × ×©××•×ª ×˜×•×‘×•×ª (×¢×™×’×•×œ×™× ×™×¨×•×§×™×)
            canvasState.collectibles.forEach(item => {
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
                ctx.fillStyle = item.color;
                ctx.fill();
                ctx.closePath();
            });

            // ×¦×™×•×¨ ×’×•×œ×’×œ×•×ª ×¨×¢×•×ª (×¨×™×‘×•×¢×™× ××“×•××™×)
            canvasState.obstacles.forEach(item => {
                ctx.fillStyle = item.color;
                // ×¦×™×•×¨ ×›×¨×™×‘×•×¢ ×‘××§×•× ×¢×™×’×•×œ ×›×“×™ ×œ×™×™×¦×’ ×’×•×œ×’×•×œ×ª
                ctx.fillRect(item.x - item.r, item.y - item.r, item.r * 2, item.r * 2);
            });

            // ×¦×™×•×¨ ×©×—×§×Ÿ (×¡×™×¨×”) - ×¦×•×¨×” ××¢×•×¦×‘×ª
            const player = canvasState.player;
            ctx.fillStyle = '#78350f'; // ×—×•× ×›×”×” (×¡×™×¨×ª ×¢×¥)
            
            // ×’×•×£ ×”×¡×™×¨×” (×˜×¨×¤×– ×”×¤×•×š)
            ctx.beginPath();
            ctx.moveTo(player.x, player.y + player.h); // ×§×¦×” ×©×××œ×™ ×ª×—×ª×•×Ÿ
            ctx.lineTo(player.x + player.w, player.y + player.h); // ×§×¦×” ×™×× ×™ ×ª×—×ª×•×Ÿ
            ctx.lineTo(player.x + player.w - 5, player.y); // ×§×¦×” ×™×× ×™ ×¢×œ×™×•×Ÿ (×—×¨×˜×•×)
            ctx.lineTo(player.x + 5, player.y); // ×§×¦×” ×©×××œ×™ ×¢×œ×™×•×Ÿ (×—×¨×˜×•×)
            ctx.closePath();
            ctx.fill();

            // ×¤×¡ ×“×§×•×¨×˜×™×‘×™ ×›×—×•×œ (×”× ×”×¨)
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(player.x + 2, player.y + player.h - 5, player.w - 4, 3);
            
            // ×¢×“×›×•×Ÿ ××™×“×¢
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `× ×©××•×ª: ${canvasState.soulsCollected} / ${quest.target} | ×’×•×œ×’×œ×•×ª: <span style="color: red">${canvasState.badSoulsHit}</span> / ${canvasState.maxBadSouls}`;
            }
        }

        // --- ×§×•×•×¡×˜ 3: ××¨×˜××™×¡ - ××ª×’×¨ ×™×¨×™ ×”×—×¦×™× (××™×¡×•×£ ×‘×–××Ÿ) ---
        function initArtemisFetch() {
            const quest = quests[2];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 12, y: canvas.height / 2 - 12, w: 24, h: 24, color: '#f59e0b', speed: 4.5 }, 
                gems: [],
                gemsCollected: 0,
                totalTime: 15, 
                timeRemaining: 15,
                lastTick: Date.now(),
                update: updateArtemisFetch,
                draw: drawArtemisFetch,
            };

            // ×™×¦×™×¨×ª 12 ×™×”×œ×•××™×
            for(let i = 0; i < quest.target; i++) {
                 canvasState.gems.push({
                    x: Math.random() * (canvas.width - 30) + 15, 
                    y: Math.random() * (canvas.height - 30) + 15, 
                    w: 15,
                    h: 15,
                    color: '#ffffff', 
                    r: 7.5
                });
            }
        }

        function updateArtemisFetch() {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // ×¢×“×›×•×Ÿ ×˜×™×™××¨
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // ×ª× ×•×¢×ª ×©×—×§×Ÿ
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // ×‘×“×™×§×ª ×’×‘×•×œ×•×ª (×”×¨×•×—×•×ª ×”××‘×œ×‘×œ×•×ª - ××—×–×™×¨ ××ª ×”×©×—×§×Ÿ)
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;


            // ×‘×“×™×§×ª ××™×¡×•×£ ×™×”×œ×•××™×
            for (let i = canvasState.gems.length - 1; i >= 0; i--) {
                const gem = canvasState.gems[i];
                // ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª (×”×™×”×œ×•××™× × ×‘×“×§×™× ×›×¨×™×‘×•×¢×™× ×œ×¦×•×¨×š collision)
                if (checkCollision(player, {x: gem.x - gem.r, y: gem.y - gem.r, w: gem.w, h: gem.h})) {
                    canvasState.gemsCollected++;
                    canvasState.gems.splice(i, 1);
                    if (canvasState.gemsCollected >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `××¡×¤×ª ××ª ×›×œ 12 ×”×™×”×œ×•××™× ×‘×–××Ÿ! ××¨×˜××™×¡ ××¨×•×¦×” ××”×“×™×•×§ ×©×œ×š. × ×™×§×•×“: 500`, 500);
                        return;
                    }
                }
            }

            // ×‘×“×™×§×ª ×–××Ÿ
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `×”×–××Ÿ × ×’××¨! ×œ× ×”×¡×¤×§×ª ×œ××¡×•×£ ××ª ×›×œ ×”×™×”×œ×•××™×. × ×¡×” ×©×•×‘.`);
            }
        }

        function drawArtemisFetch() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ×¦×™×•×¨ ×™×”×œ×•××™× (××¢×•×™× ×™×)
            canvasState.gems.forEach(gem => {
                ctx.fillStyle = gem.color;
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 5;
                const r = gem.r;
                const x = gem.x;
                const y = gem.y;


                // ×¦×™×•×¨ ××¢×•×™×Ÿ
                ctx.beginPath();
                ctx.moveTo(x, y - r); // Top point
                ctx.lineTo(x + r, y); // Right point
                ctx.lineTo(x, y + r); // Bottom point
                ctx.lineTo(x - r, y); // Left point
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0; // ××™×¤×•×¡ ×¦×œ
            });

            // ×¦×™×•×¨ ×©×—×§×Ÿ (×“××•×ª)
            drawPlayerFigure(canvasState.player);

            // ×¢×“×›×•×Ÿ ××™×“×¢
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                info.innerHTML = `×™×”×œ×•××™×: ${canvasState.gemsCollected} / ${quest.target} | ×–××Ÿ: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span> ×©× ×™×•×ª`;
            }
        }

        // --- ×§×•×•×¡×˜ 4: ×”×¨××¡ - ×‘×¨×™×—×” ××¨×©×ª ×”×œ×™×™×–×¨ (Laser Grid Avoidance) ---
        function initHermesAvoidance() {
            const permanentFastSpeed = 9; // ×”××”×™×¨×•×ª ×”××”×™×¨×” ×”×§×‘×•×¢×”
            canvasState = {
                isRunning: false,
                // ×”×“××•×ª ××ª×—×™×œ×” ×‘××”×™×¨×•×ª ×”×’×‘×•×”×” (9)
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#f59e0b', speed: permanentFastSpeed }, 
                walls: [], // ×”×§×™×¨×•×ª ×”××›×™×œ×™× ×¤×¢×¨×™× (Laser Gates)
                wallsDodged: 0, // ×ª×™×§×•×Ÿ ×”×©×
                hits: 0,
                maxHits: 3, 
                lastSpawn: 0,
                spawnRate: 1000, 
                lastTick: Date.now(), // ×”×•×¡×¤×ª lastTick ×œ×—×™×©×•×‘ elapsed
                update: updateHermesAvoidance,
                draw: drawHermesAvoidance,
            };
        }

        function updateHermesAvoidance(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;

            // ×ª× ×•×¢×ª ×©×—×§×Ÿ
            const moveStep = player.speed * elapsed * 60 * 0.1; // ××‘×•×¡×¡ ×¢×œ ××”×™×¨×•×ª 9
            
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;


            // ×™×¦×™×¨×ª ×§×™×¨×•×ª (×¢× ×©× ×™ ×¤×¢×¨×™×)
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const gapWidth = 60 + Math.random() * 20; 
                const minGapDistance = 50; 
                const wallHeight = 15;
                
                // ×—×™×©×•×‘ ××™×§×•× ×©× ×™ ×”×¤×¢×¨×™× (gap1Start < gap2Start)
                const totalSpaceNeeded = 2 * gapWidth + minGapDistance;
                const availableStartSpace = canvas.width - totalSpaceNeeded;

                // ××™×§×•× ×”×ª×—×œ×” ×©×œ ×”×¤×¢×¨ ×”×¨××©×•×Ÿ
                let gap1Start = Math.random() * (availableStartSpace);

                // ××™×§×•× ×”×ª×—×œ×” ×©×œ ×”×¤×¢×¨ ×”×©× ×™
                let gap2Start = gap1Start + gapWidth + minGapDistance + Math.random() * (canvas.width - (gap1Start + gapWidth + minGapDistance) - gapWidth);
                
                // ×•×“× ×©-gap2Start ×œ× ×—×•×¨×’ ××”×§×¦×”
                gap2Start = Math.min(gap2Start, canvas.width - gapWidth - 5);


                canvasState.walls.push({
                    y: -wallHeight,
                    gap1Start: gap1Start,
                    gap1End: gap1Start + gapWidth,
                    gap2Start: gap2Start,
                    gap2End: gap2Start + gapWidth,
                    h: wallHeight,
                    speed: 4.5 + Math.random() * 2.5,
                    color: '#ef4444', // ××“×•× ×œ×™×™×–×¨
                    passed: false, // ×”×× ×”×©×—×§×Ÿ ×¢×‘×¨ ××ª×—×ª×™×• (×—×©×•×‘ ×œ×¡×¤×™×¨×”)
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(700, canvasState.spawnRate - 30); // ×§×¦×‘ ×¢×•×œ×”
            }

            // ×¢×“×›×•×Ÿ ××™×§×•× ×§×™×¨×•×ª ×•×‘×“×™×§×ª ×”×ª× ×’×©×•×ª
            for (let i = canvasState.walls.length - 1; i >= 0; i--) {
                const wall = canvasState.walls[i];
                // ×¢×“×›×•×Ÿ ××™×§×•× ×”×§×™×¨
                wall.y += wall.speed;

                // ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª (×©×—×§×Ÿ × ×ª×§×¢ ×‘×§×™×¨)
                // ×‘×•×“×§×™× ×× ×™×© ×—×¤×™×¤×” ×× ×›×™×ª ×‘×™×Ÿ ×”×©×—×§×Ÿ ×œ×§×™×¨
                if (player.y + player.h > wall.y && player.y < wall.y + wall.h) {
                    
                    let collision = false;
                    
                    // ×‘×“×™×§×” ××•×œ 3 ××§×˜×¢×™ ×œ×™×™×–×¨:
                    
                    // 1. Segment 1 (Left): 0 to gap1Start
                    if (player.x < wall.gap1Start) {
                        collision = true;
                    }
                    
                    // 2. Segment 2 (Middle): gap1End to gap2Start
                    // ×”×ª× ×’×©×•×ª ××ª×¨×—×©×ª ×× ×”×“××•×ª × ×›× ×¡×ª ×œ××–×•×¨ ×”×××¦×¢×™
                    if (player.x + player.w > wall.gap1End && player.x < wall.gap2Start) {
                       collision = true;
                    }
                    
                    // 3. Segment 3 (Right): gap2End to canvas.width
                    if (player.x + player.w > wall.gap2End) {
                        collision = true;
                    }
                    
                    if (collision) {
                        // ×™×© ×”×ª× ×’×©×•×ª: ×—×•×˜×¤×™× ×¤×’×™×¢×”
                        canvasState.hits++;
                        canvasState.walls.splice(i, 1); 
                        
                        if (canvasState.hits >= canvasState.maxHits) {
                            canvasState.isRunning = false;
                            handleQuestResult(false, `× ×ª×§×¢×ª ×™×•×ª×¨ ××“×™! ×”××›×•× ×” ×©×œ ×”×¨××¡ ×”×©×ª×’×¢×”. × ×¡×” ×©×•×‘.`);
                            return;
                        }
                        continue;
                    }
                }

                // ×‘×“×™×§×ª ×™×¦×™××” ××”××¡×š (×•×”×¦×œ×—×”)
                if (wall.y > player.y + player.h && !wall.passed) { // ×©×™× ×•×™: ×× ×”×§×™×¨ ×¢×‘×¨ ××ª ×’×•×‘×” ×”×©×—×§×Ÿ (×œ××˜×”)
                    wall.passed = true;
                    canvasState.wallsDodged++;

                    if (canvasState.wallsDodged >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `×”×ª×—××§×ª ×-15 ×’×“×¨×•×ª ×œ×™×™×–×¨! ×”×¨××¡ ×§×™×‘×œ ××ª ×”××›×•× ×” ×©×œ×• ×‘×—×–×¨×”. × ×™×§×•×“: 400`, 400);
                        return;
                    }
                }
                
                // × ×™×§×•×™ ×§×™×¨×•×ª ×©×™×¦××• ××”××¡×š
                if (wall.y > canvas.height) {
                    canvasState.walls.splice(i, 1);
                }
            }
        }

        function drawHermesAvoidance() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ×¦×™×•×¨ ×§×™×¨×•×ª ×œ×™×™×–×¨ (Laser Gates)
            canvasState.walls.forEach(wall => {
                ctx.fillStyle = wall.color;
                ctx.shadowColor = wall.color;
                ctx.shadowBlur = 10;
                
                // ×§×™×¨ ×©×××œ×™ (Segment 1: 0 to gap1Start)
                ctx.fillRect(0, wall.y, wall.gap1Start, wall.h);
                
                // ×§×™×¨ ×××¦×¢×™ (Segment 2: gap1End to gap2Start)
                ctx.fillRect(wall.gap1End, wall.y, wall.gap2Start - wall.gap1End, wall.h);

                // ×§×™×¨ ×™×× ×™ (Segment 3: gap2End to canvas.width)
                ctx.fillRect(wall.gap2End, wall.y, canvas.width - wall.gap2End, wall.h);
                
                ctx.shadowBlur = 0;
                
                // --- ×¦×™×•×¨ ×”××›×©×•×œ×™× ×”×’×œ×•×™×™× (×œ××¢×œ×”) ---
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.textAlign = 'left';
                // ×¦×™×•×¨ ×§×¦×•×•×ª ×”×¤×¢×¨×™×
                ctx.fillText(`×¤×¢×¨ (${wall.gap1End.toFixed(0)})`, wall.gap1Start, wall.y - 5);
                ctx.fillText(`×¤×¢×¨ (${wall.gap2End.toFixed(0)})`, wall.gap2Start, wall.y - 5);
                

            });

            // ×¦×™×•×¨ ×©×—×§×Ÿ (×“××•×ª)
            drawPlayerFigure(canvasState.player);

            // ×¢×“×›×•×Ÿ ××™×“×¢
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `×”×ª×—××§×•×ª: ${canvasState.wallsDodged} / ${quest.target} | ×¤×’×™×¢×•×ª: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }


        // --- ×§×•×•×¡×˜ 5: ××¤×¨×•×“×™×˜×” - × ×™×§×•×™ ×”×‘×œ×’×Ÿ ×”×¨×•×× ×˜×™ ---

        const ITEM_TYPE = { HEART: 'heart', FLOWER: 'flower' };
        
        function initAphroditeClean() {
            const quest = quests[4];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 15, y: canvas.height / 2 - 15, w: 30, h: 30, color: '#ec4899', speed: 4 }, 
                items: [],
                collectedCount: { heart: 0, flower: 0 },
                totalCollected: 0,
                collectingType: ITEM_TYPE.HEART, // ××ª×—×™×œ ×¢× ×œ×‘×‘×•×ª
                lastTypeSwitch: 0,
                typeSwitchCooldown: 1000, // ×§×•×©×™: 1 ×©× ×™×™×” ×§×™×¨×•×¨
                totalTime: 20, 
                timeRemaining: 20,
                lastTick: Date.now(),
                update: updateAphroditeClean,
                draw: drawAphroditeClean,
            };

            // ×™×¦×™×¨×ª 8 ×œ×‘×‘×•×ª ×•-7 ×¤×¨×—×™× (×¡×”"×› 15)
            const targets = { heart: 8, flower: 7 };
            // FIX: ×”×•×¡×¤×ª ×”-type ×œ×›×œ ×¤×¨×™×˜ ×‘×¢×ª ×™×¦×™×¨×ª×•
            for(let type in targets) {
                for(let i = 0; i < targets[type]; i++) {
                    canvasState.items.push({
                        x: Math.random() * (canvas.width - 30) + 15, 
                        y: Math.random() * (canvas.height - 30) + 15, 
                        w: 15,
                        h: 15,
                        type: type, // *** ×”×•×¡×¤×ª ×¡×•×’ ×”×¤×¨×™×˜ ***
                        r: 7.5
                    });
                }
            }
        }

        function updateAphroditeClean() {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();

            // ×¢×“×›×•×Ÿ ×˜×™×™××¨
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // ×ª× ×•×¢×ª ×©×—×§×Ÿ
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // ×‘×“×™×§×ª ×’×‘×•×œ×•×ª
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;

            // ×”×—×œ×¤×ª ×¡×•×’ ××™×¡×•×£ (×¨×•×•×— - Space)
            const isOnCooldown = now - canvasState.lastTypeSwitch < canvasState.typeSwitchCooldown;
            if (keys[' '] && !isOnCooldown) {
                canvasState.collectingType = canvasState.collectingType === ITEM_TYPE.HEART ? ITEM_TYPE.FLOWER : ITEM_TYPE.HEART;
                canvasState.lastTypeSwitch = now;
                keys[' '] = false; // ×œ×× ×•×¢ ×”×—×œ×¤×” ××™×™×“×™×ª × ×•×¡×¤×ª
            }

            // ×‘×“×™×§×ª ××™×¡×•×£
            for (let i = canvasState.items.length - 1; i >= 0; i--) {
                const item = canvasState.items[i];
                if (checkCollision(player, {x: item.x - item.r, y: item.y - item.r, w: item.w, h: item.h})) {
                    // FIX: ×›×¢×ª ×”-item.type ×§×™×™× ×•× ×™×ª×Ÿ ×œ×‘×“×•×§ ××•×ª×•
                    if (item.type === canvasState.collectingType) {
                        // ××™×¡×•×£ ××•×¦×œ×—
                        canvasState.collectedCount[item.type]++;
                        canvasState.totalCollected++;
                        canvasState.items.splice(i, 1);
                        if (canvasState.totalCollected >= quest.target) {
                            canvasState.isRunning = false;
                            handleQuestResult(true, `××¡×¤×ª ××ª ×›×œ ${quest.target} ×”××¨×›×™×‘×™× ×‘×–××Ÿ! ××¤×¨×•×“×™×˜×” ×™×›×•×œ×” ×œ×”×©×œ×™× ××ª ×©×™×§×•×™ ×”××”×‘×”. × ×™×§×•×“: 600`, 600);
                            return;
                        }
                    } else {
                        // ×¤×’×™×¢×” ×‘×¤×¨×™×˜ ×”×œ× × ×›×•×Ÿ - ××™×Ÿ ×§× ×¡, ×¤×©×•×˜ ×œ× ××•×¡×¤×™×
                    }
                }
            }

            // ×‘×“×™×§×ª ×–××Ÿ
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `×”×–××Ÿ × ×’××¨! ×œ× ××¡×¤×ª ××ª ×›×œ ${quest.target} ×”××¨×›×™×‘×™×. × ×¡×” ×©×•×‘.`);
            }
        }

        function drawAphroditeClean() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const now = Date.now();

            // ×¦×™×•×¨ ×¤×¨×™×˜×™×
            canvasState.items.forEach(item => {
                ctx.shadowBlur = 5;
                if (item.type === ITEM_TYPE.HEART) {
                    // ×¦×™×•×¨ ×œ×‘ (Heart - ×¤×•× ×§×¦×™×™×ª ×¦×™×•×¨ ×¤×©×•×˜×”)
                    ctx.fillStyle = '#f87171';
                    ctx.shadowColor = '#f87171';
                    const h_x = item.x;
                    const h_y = item.y;
                    const r = item.r;
                    
                    ctx.beginPath();
                    // ×©×™××•×© ×‘×¦×•×¨×” ×’×™××•××˜×¨×™×ª ×¤×©×•×˜×” ×™×•×ª×¨ ×œ×‘×˜×™×—×•×ª
                    ctx.moveTo(h_x, h_y + r); 
                    ctx.lineTo(h_x + r, h_y - r);
                    ctx.lineTo(h_x + r / 2, h_y - r * 2);
                    ctx.lineTo(h_x, h_y - r * 1.5);
                    ctx.lineTo(h_x - r / 2, h_y - r * 2);
                    ctx.lineTo(h_x - r, h_y - r);
                    ctx.closePath();
                    ctx.fill();

                } else { // ITEM_TYPE.FLOWER
                    // ×¦×™×•×¨ ×¤×¨×— (Flower - ×¢×™×’×•×œ + ×¢×œ×™ ×›×•×ª×¨×ª ×¤×©×•×˜×™×)
                    ctx.fillStyle = '#818cf8';
                    ctx.shadowColor = '#818cf8';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
                ctx.shadowBlur = 0;
            });

            // ×¦×™×•×¨ ×©×—×§×Ÿ (×“××•×ª)
            drawPlayerFigure(canvasState.player);

            // ×”×“×’×©×ª ××¦×‘ ××™×¡×•×£ × ×•×›×—×™
            const statusColor = canvasState.collectingType === ITEM_TYPE.HEART ? '#f87171' : '#818cf8';
            ctx.fillStyle = statusColor;
            ctx.globalAlpha = 0.2;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            const isOnCooldown = now - canvasState.lastTypeSwitch < canvasState.typeSwitchCooldown;
            const cooldownText = isOnCooldown ? ` (×××ª×™×Ÿ ${((canvasState.typeSwitchCooldown - (now - canvasState.lastTypeSwitch) + 100) / 1000).toFixed(1)} ×©× ')` : '';

            // ×¢×“×›×•×Ÿ ××™×“×¢
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                info.innerHTML = `××¡×•×£: <span style="color: ${statusColor}; font-weight: bold">${canvasState.collectingType === ITEM_TYPE.HEART ? '×œ×‘×‘×•×ª' : '×¤×¨×—×™×'}</span>${cooldownText} | ×¡×”"×›: ${canvasState.totalCollected} / ${quest.target} | ×–××Ÿ: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span>`;
            }
        }

        // --- ×§×•×•×¡×˜ 6: ×¤×•×¡×™×“×•×Ÿ - × ×—×©×•×œ×™ ×”××¦×•×ª ×”×–×•×¢××™× ---
        function initPoseidonDodge() {
            const quest = quests[5];
            canvasState = {
                isRunning: false, 
                player: { x: 30, y: canvas.height / 2 - 15, w: 30, h: 30, color: '#10b981', speed: 4.5 }, // ×”×“××•×ª × ××¦××ª ×‘×¦×“ ×©×××œ
                obstacles: [], // ×’×•×©×™ ××¦×•×ª ×•×¡×œ×¢×™×
                dodgedCount: 0,
                hits: 0,
                maxHits: 2, 
                lastSpawn: 0,
                spawnRate: 400, // ×§×•×©×™: ×§×¦×‘ ×’×‘×•×”
                update: updatePoseidonDodge,
                draw: drawPoseidonDodge,
            };
        }

        function updatePoseidonDodge(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // ×ª× ×•×¢×ª ×©×—×§×Ÿ - ×¨×§ ×œ××¢×œ×” ×•×œ××˜×”
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // ×™×¦×™×¨×ª ××•×‘×™×™×§×˜×™×
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const y = Math.random() * (canvas.height - 20) + 10;
                const h = 15 + Math.random() * 25; // ×’×•×‘×” ××©×ª× ×”
                const w = 15 + Math.random() * 20; // ×¨×•×—×‘ ××©×ª× ×”
                
                canvasState.obstacles.push({
                    x: canvas.width, 
                    y: y - h / 2,
                    w: w, 
                    h: h,
                    speed: 4 + Math.random() * 3, // ×§×•×©×™: ××”×™×¨×•×ª ×’×‘×•×”×”
                    color: Math.random() < 0.3 ? '#4b5563' : '#059669' // ××¦×•×ª ××• ×¡×œ×¢ ××¤×•×¨
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(100, canvasState.spawnRate - 5); // ×§×•×©×™: ×§×¦×‘ ×”×•×¤×¢×” ×’×“×œ
            }

            // ×¢×“×›×•×Ÿ ××™×§×•× ××›×©×•×œ×™× ×•×‘×“×™×§×ª ×”×ª× ×’×©×•×ª
            for (let i = canvasState.obstacles.length - 1; i >= 0; i--) {
                const obstacle = canvasState.obstacles[i];
                obstacle.x -= obstacle.speed;

                if (checkCollision(player, obstacle)) {
                    // ×¤×’×™×¢×”
                    canvasState.hits++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.hits >= canvasState.maxHits) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `×¤×•×¡×™×“×•×Ÿ ×—×¡× ××ª × ×ª×™×‘ ×”××™×! ×—×˜×¤×ª ${canvasState.hits} ×¤×’×™×¢×•×ª. × ×¡×” ×©×•×‘.`);
                        return;
                    }
                } else if (obstacle.x + obstacle.w < 0) {
                    // ××›×©×•×œ ×™×¦× ××”××¡×š
                    canvasState.dodgedCount++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.dodgedCount >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `×”×ª×—××§×ª ×-20 ×’×•×©×™×! ×¤×•×¡×™×“×•×Ÿ ×”×¨×’×™×¢ ××ª ×”×™×. × ×™×§×•×“: 700`, 700);
                    }
                }
            }
        }

        function drawPoseidonDodge() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ×¦×™×•×¨ ××›×©×•×œ×™×
            canvasState.obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.w, obstacle.h);
            });

            // ×¦×™×•×¨ ×©×—×§×Ÿ (×“××•×ª)
            drawPlayerFigure(canvasState.player);

            // ×¢×“×›×•×Ÿ ××™×“×¢
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `×”×ª×—××§×•×ª: ${canvasState.dodgedCount} / ${quest.target} | ×¤×’×™×¢×•×ª: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }

        // --- ×§×•×•×¡×˜ 7: ×“×™×•× ×™×¡×•×¡ - ××¨×ª×•×Ÿ ×”×‘×¨×× ×™× ×”×§×•×¡××™ (Overcooked Style) ---

        const INGREDIENTS = { GRAPE: 'GRAPE', CLOUD: 'CLOUD', LIGHTNING: 'LIGHTNING' };
        
        function initDionysusCocktail() {
            const quest = quests[6];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#9d174d', speed: 4.5 }, 
                items: [], // ××¨×›×™×‘×™× ×¤×–×•×¨×™×
                required: { GRAPE: 1, CLOUD: 1, LIGHTNING: 1 },
                inventory: { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 },
                cocktailsMade: 0,
                totalTime: 25, 
                timeRemaining: 25,
                lastTick: Date.now(),
                lastSpawn: 0,
                
                // --- ×œ×•×’×™×§×ª ×¡×“×¨ ×”×•×¤×¢×” ×—×“×©×” ---
                spawnInterval: 1000, // 1 ×©× ×™×” ×‘×™×Ÿ ×¡×•×’ ××¨×›×™×‘ ×œ×¡×•×’
                spawnSequence: [INGREDIENTS.GRAPE, INGREDIENTS.LIGHTNING, INGREDIENTS.CLOUD],
                sequenceIndex: 0,

                // --- ×œ×•×’×™×§×ª ×‘×™×©×•×œ ×—×“×©×” ---
                isMixing: false,
                mixingStartTime: 0,
                mixTimeRequired: 2000, // 2 ×©× ×™×•×ª
                
                // --- ×œ×•×’×™×§×ª ××¨×¡ ×—×“×©×” ---
                aresAttacks: [], // ×—×¨×‘×•×ª ×©×œ ××¨×¡
                lastAresSpawn: 0,
                aresSpawnRate: 1800, // ×—×¨×‘ ×›×œ 1.8 ×©× ×™×•×ª
                aresSpeed: 4,

                update: updateDionysusCocktail,
                draw: drawDionysusCocktail,
            };
            
            // ×”×’×“×¨×ª ×–××Ÿ ×”×”×•×¤×¢×” ×”×¨××©×•× ×™×ª (××™×“ ××—×¨×™ ×”×”×ª×—×œ×”)
            canvasState.lastSpawn = Date.now();
        }
        
        // ×¤×•× ×§×¦×™×” ×œ×™×¦×™×¨×ª ××¨×›×™×‘ ×¡×¤×¦×™×¤×™
        function spawnIngredient(type) { 
            // ×‘×“×™×§×” ×©×¡×•×’ ×”××¨×›×™×‘ ×ª×§×™×Ÿ
            if (!Object.values(INGREDIENTS).includes(type)) return;

            canvasState.items.push({
                x: Math.random() * (canvas.width - 30) + 15, 
                y: Math.random() * (canvas.height - 30) + 15, 
                w: 20, h: 20, 
                type: type,
                r: 10
            });
        }

        function spawnAresAttack(timestamp) {
            // ×—×¨×‘ ×–×–×” ××•×¤×§×™×ª (××™××™×Ÿ ×œ×©×××œ ××• ××©×××œ ×œ×™××™×Ÿ)
            const isLeftToRight = Math.random() < 0.5;
            const y = Math.random() * (canvas.height - 30) + 15;
            const speed = canvasState.aresSpeed + Math.random() * 1.5;

            canvasState.aresAttacks.push({
                x: isLeftToRight ? -20 : canvas.width,
                y: y,
                w: 30, h: 8, // ×¨×•×—×‘ ×•×’×•×‘×” ×©×œ ×”×—×¨×‘
                speed: isLeftToRight ? speed : -speed,
                color: '#b91c1c', // ××“×•× ×©×œ ××¨×¡
                isLeftToRight: isLeftToRight,
            });
            canvasState.lastAresSpawn = timestamp;
            canvasState.aresSpawnRate = Math.max(1000, canvasState.aresSpawnRate - 50); // ××’×‘×™×¨ ×§×¦×‘
        }


        function updateDionysusCocktail(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();

            // ×¢×“×›×•×Ÿ ×˜×™×™××¨
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // ×ª× ×•×¢×ª ×©×—×§×Ÿ
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // ×‘×“×™×§×ª ×’×‘×•×œ×•×ª
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;

            // ×™×¦×™×¨×ª ××¨×›×™×‘×™× ×—×“×©×™× ×œ×¤×™ ×¡×“×¨ ×§×‘×•×¢ ×•×–×× ×™× (Spawn)
            if (now - canvasState.lastSpawn > canvasState.spawnInterval && canvasState.items.length < 12) {
                
                // 1. ×§×‘×™×¢×ª ×¡×•×’ ×”××¨×›×™×‘ ×”× ×•×›×—×™ ×œ×¤×™ ×”××™× ×“×§×¡
                const typeToSpawn = canvasState.spawnSequence[canvasState.sequenceIndex];

                // 2. ×™×¦×™×¨×ª ×”××¨×›×™×‘
                spawnIngredient(typeToSpawn);
                
                // 3. ×¢×“×›×•×Ÿ ×–××Ÿ
                canvasState.lastSpawn = now;

                // 4. ×§×™×“×•× ×œ××™× ×“×§×¡ ×”×‘× (××—×–×•×¨)
                canvasState.sequenceIndex = (canvasState.sequenceIndex + 1) % canvasState.spawnSequence.length;
            }

            // ×™×¦×™×¨×ª ×”×ª×§×¤×ª ××¨×¡
            if (timestamp - canvasState.lastAresSpawn > canvasState.aresSpawnRate) {
                spawnAresAttack(timestamp);
            }

            // --- ×œ×•×’×™×§×ª ×”×ª×§×¤×•×ª ××¨×¡ ---
            for (let i = canvasState.aresAttacks.length - 1; i >= 0; i--) {
                const sword = canvasState.aresAttacks[i];
                sword.x += sword.speed;

                if (checkCollision(player, sword)) {
                    // ×¤×’×™×¢×” ×××¨×¡: ××™×¤×•×¡ ××œ××™ ×•×‘×™×˜×•×œ ×‘×™×©×•×œ
                    canvasState.inventory = { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 };
                    canvasState.isMixing = false;
                    canvasState.mixingStartTime = 0;
                    canvasState.aresAttacks.splice(i, 1);
                    break; // break ××”×œ×•×œ××” ×”× ×•×›×—×™×ª (×œ×•×œ××ª aresAttacks)
                } else if (sword.x > canvas.width || sword.x + sword.w < 0) {
                    canvasState.aresAttacks.splice(i, 1);
                }
            }


            // ×‘×“×™×§×ª ××™×¡×•×£
            for (let i = canvasState.items.length - 1; i >= 0; i--) {
                const item = canvasState.items[i];
                if (checkCollision(player, item)) {
                    canvasState.inventory[item.type]++;
                    canvasState.items.splice(i, 1);
                    break; // break ××”×œ×•×œ××” ×”× ×•×›×—×™×ª (×œ×•×œ××ª items)
                }
            }
            
            // ×‘×“×™×§×ª ××™×§×¡×¨
            const mixer = { x: canvas.width/2 - 50, y: 10, w: 100, h: 50 }; 
            const isCollidingWithMixer = checkCollision(player, mixer);
            
            const hasAllIngredients = 
                canvasState.inventory.GRAPE >= canvasState.required.GRAPE &&
                canvasState.inventory.CLOUD >= canvasState.required.CLOUD &&
                canvasState.inventory.LIGHTNING >= canvasState.required.LIGHTNING;
            
            // ×œ×•×’×™×§×ª ×‘×™×©×•×œ
            if (isCollidingWithMixer && hasAllIngredients) {
                if (!canvasState.isMixing) {
                    // ×”×ª×—×œ×ª ×‘×™×©×•×œ
                    canvasState.isMixing = true;
                    canvasState.mixingStartTime = now;
                } else {
                    // ×‘×“×™×§×ª ×¡×™×•× ×‘×™×©×•×œ
                    if (now - canvasState.mixingStartTime >= canvasState.mixTimeRequired) {
                        // ×‘×™×©×•×œ ××•×¦×œ×—!
                        canvasState.cocktailsMade++;
                        canvasState.inventory = { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 }; // ××™×¤×•×¡ ××œ××™
                        canvasState.isMixing = false;
                        canvasState.mixingStartTime = 0;

                        if (canvasState.cocktailsMade >= quest.target) {
                            canvasState.isRunning = false;
                            handleQuestResult(true, `×”×›× ×ª 3 ×§×•×§×˜×™×™×œ×™×! ×“×™×•× ×™×¡×•×¡ ×—×•×–×¨ ×œ×™×™×Ÿ ×”×¨×’×™×œ. × ×™×§×•×“: 800`, 800);
                            return;
                        }
                    }
                }
            } else {
                // ×× ×™×¦××ª ××”××™×§×¡×¨ ××• ××™×‘×“×ª ××¨×›×™×‘×™×, ×”×¢×¨×‘×•×‘ ××ª×‘×˜×œ
                if (canvasState.isMixing) {
                    canvasState.isMixing = false;
                    canvasState.mixingStartTime = 0;
                }
            }
            
            // ×‘×“×™×§×ª ×–××Ÿ
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `×”×–××Ÿ × ×’××¨! ×œ× ×”×¡×¤×§×ª ×œ×”×›×™×Ÿ ××ª ×›×œ 3 ×”×§×•×§×˜×™×™×œ×™×. × ×¡×” ×©×•×‘.`);
            }
        }

        function drawDionysusCocktail() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const now = Date.now();
            
            // 1. ×¦×™×•×¨ ××™×›×œ ×”×¢×¨×‘×•×‘ (Mixer)
            const mixer = { x: canvas.width/2 - 50, y: 10, w: 100, h: 50 };
            ctx.fillStyle = '#6d28d9'; // ×¡×’×•×œ ×¢××•×§ ×œ×™×™×Ÿ
            ctx.fillRect(mixer.x, mixer.y, mixer.w, mixer.h);
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 3;
            ctx.strokeRect(mixer.x, mixer.y, mixer.w, mixer.h);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText("×¢×¨×‘×•×‘ (Mix)", canvas.width / 2, 40);
            
            // 1.1. ×¦×™×•×¨ ×¡×¨×’×œ ×”×ª×§×“××•×ª ×‘×™×©×•×œ
            if (canvasState.isMixing) {
                const progress = (now - canvasState.mixingStartTime) / canvasState.mixTimeRequired;
                const barWidth = mixer.w * progress;
                ctx.fillStyle = '#FFD700'; // ×¦×”×•×‘ ×–×”×‘ ×œ×”×ª×§×“××•×ª
                ctx.fillRect(mixer.x, mixer.y + mixer.h - 5, barWidth, 5);
            }


            // 2. ×¦×™×•×¨ ××¨×›×™×‘×™×
            canvasState.items.forEach(item => {
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                // ×¦×™×•×¨ ×‘×××¦×¢×•×ª ××™××•×’'×™
                if (item.type === INGREDIENTS.GRAPE) {
                    ctx.fillText('ğŸ‡', item.x, item.y + 15);
                } else if (item.type === INGREDIENTS.CLOUD) {
                    ctx.fillText('â˜ï¸', item.x, item.y + 15);
                } else if (item.type === INGREDIENTS.LIGHTNING) {
                    ctx.fillText('âš¡', item.x, item.y + 15);
                }
            });
            
            // 3. ×¦×™×•×¨ ×”×ª×§×¤×•×ª ××¨×¡ (×—×¨×‘×•×ª)
            canvasState.aresAttacks.forEach(sword => {
                ctx.fillStyle = sword.color;
                ctx.shadowColor = sword.color;
                ctx.shadowBlur = 10;
                
                // ×¦×™×•×¨ ×œ×”×‘
                ctx.fillRect(sword.x, sword.y, sword.w, sword.h);
                // ×¦×™×•×¨ ×™×“×™×ª (×§×˜× ×”)
                ctx.fillStyle = '#78350f';
                ctx.fillRect(sword.x + sword.w, sword.y + 2, 5, 4);

                ctx.shadowBlur = 0;
            });


            // 4. ×¦×™×•×¨ ×©×—×§×Ÿ (×“××•×ª)
            drawPlayerFigure(canvasState.player);

            // 5. ×¢×“×›×•×Ÿ ××™×“×¢ ×•××œ××™ (Inventory)
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                let mixingStatus = '';
                if (canvasState.isMixing) {
                    const timeLeft = canvasState.mixTimeRequired - (now - canvasState.mixingStartTime);
                    mixingStatus = ` | ××¢×¨×‘×‘... <span class="text-yellow-600">${(timeLeft / 1000).toFixed(1)}</span> ×©× '`;
                }
                
                info.innerHTML = `
                    <div style="direction:rtl; display: flex; justify-content: space-between; width: 100%;">
                        <span>×§×•×§×˜×™×™×œ×™×: <span class="text-green-600">${canvasState.cocktailsMade}</span> / ${quest.target}${mixingStatus}</span>
                        <span>×–××Ÿ: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span> ×©× '</span>
                    </div>
                    <div class="mt-2 text-sm text-gray-700 font-normal">
                        ××œ××™: ğŸ‡:${canvasState.inventory.GRAPE} / â˜ï¸:${canvasState.inventory.CLOUD} / âš¡:${canvasState.inventory.LIGHTNING}
                    </div>
                `;
            }
        }


        // =========================================================
        // --- ×§×•×•×¡×˜ 8: ×”×¤×™×¡×˜×•×¡ - ×”×¨×›×‘×ª ×”×¨×•×‘×•×˜ ×”×× ×¦×— ---
        // =========================================================

        const ROBOT_PARTS = { 
            HEAD: 'HEAD', 
            BODY: 'BODY', 
            ARM: 'ARM', 
            WHEEL: 'WHEEL' 
        };
        
        // 1. ×¤×¨×˜×™ ×”×—×œ×§×™× (×××¤×™×™× ×™× ×©×•× ×™×)
        const PART_VARIANTS = [
            // ×’×•×¤×™× (Body)
            { id: 1, type: ROBOT_PARTS.BODY, name: "×’×•×£ ××¨×•×¥ (×§×œ)", emoji: 'ğŸŸ¥', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 3, type: ROBOT_PARTS.BODY, name: "×’×•×£ ×’××™×© (×××•×–×Ÿ)", emoji: 'ğŸŸ©', stats: { speed: 3, weight: 3, balance: 5 } },

            // ×’×œ×’×œ×™× (Wheel)
            { id: 4, type: ROBOT_PARTS.WHEEL, name: "×’×œ×’×œ×™ ×¡×¤×™×“", emoji: 'ğŸš€', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 6, type: ROBOT_PARTS.WHEEL, name: "×’×œ×’×œ×™ ××—×™×–×” (×××•×–×Ÿ)", emoji: 'ğŸ›¡ï¸', stats: { speed: 3, weight: 3, balance: 5 } },
            
            // ×–×¨×•×¢×•×ª (Arm)
            { id: 7, type: ROBOT_PARTS.ARM, name: "×–×¨×•×¢×•×ª ×›×•×—", emoji: 'ğŸ’ª', stats: { speed: 1, weight: 5, balance: 2 } },
            { id: 9, type: ROBOT_PARTS.ARM, name: "×–×¨×•×¢×•×ª ×›×œ×™ ×¢×‘×•×“×” (×××•×–×Ÿ)", emoji: 'ğŸ› ï¸', stats: { speed: 3, weight: 3, balance: 5 } },

            // ×¨××©×™× (Head)
            { id: 10, type: ROBOT_PARTS.HEAD, name: "×¨××© ×—×™×™×©×Ÿ", emoji: 'ğŸ’¡', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 12, type: ROBOT_PARTS.HEAD, name: "×¨××© ×¤×™×§×•×“ (×××•×–×Ÿ)", emoji: 'âš™ï¸', stats: { speed: 3, weight: 3, balance: 5 } },
        ].filter(p => p.id !== 2 && p.id !== 5 && p.id !== 8 && p.id !== 11); // ×¡×™× ×•×Ÿ ×›×“×™ ×œ×”×©××™×¨ 8 ×—×œ×§×™×, 2 ××›×œ ×¡×•×’

        
        // 2. ×”×’×“×¨×ª ××™×§×•××™ ×”×¨×›×‘×” ×§×‘×•×¢×™×
        // ×™×© ×œ×”×©×ª××© ×‘××™×§×•××™× ×§×‘×•×¢×™× ×›×“×™ ×œ×—×©×‘ ××ª ×”×”×—×–×¨×” ×©×œ ×”×—×œ×§ ×œ×××’×¨
        const INITIAL_PART_POSITIONS = {}; 
        PART_VARIANTS.forEach((p, index) => {
            // ×”×ª×××ª ×”××™×§×•× ×œ××—×¨ ×”×§×™×¦×•×¥ (4 ×©×•×¨×•×ª, 2 ×¢××•×“×•×ª)
            INITIAL_PART_POSITIONS[p.id] = { 
                x: 280 + (index % 2) * 40, // 280, 320
                y: 70 + Math.floor(index / 2) * 55 // 70, 125, 180, 235
            };
        });

        const BUILD_SLOTS = {
            [ROBOT_PARTS.HEAD]: { x: 175, y: 50, radius: 20, assignedPart: null },
            [ROBOT_PARTS.BODY]: { x: 175, y: 120, radius: 25, assignedPart: null },
            [ROBOT_PARTS.ARM]: { x: 175, y: 190, radius: 20, assignedPart: null },
            [ROBOT_PARTS.WHEEL]: { x: 175, y: 260, radius: 25, assignedPart: null },
        };

        // 3. ×”×’×“×¨×ª ××›×©×•×œ×™× ×‘××¡×œ×•×œ (×¢× ×“×¨×™×©×•×ª ×’×œ×•×™×•×ª)
        const OBSTACLES = [
            // --- ×“×¨×™×©×•×ª ×—×“×©×•×ª ---
            // ××”×™×¨×•×ª: ×”×•×¨×“ ×œ-11.5
            { type: 'SPEED_CHALLENGE', name: "××›×©×•×œ 1: ×× ×”×¨×ª ××”×™×¨×•×ª", requiredStat: 'speed', threshold: 11.5, failMessage: "×”×¨×•×‘×•×˜ ×©×œ×š ×”×™×” ××™×˜×™ ××“×™ ×‘×× ×”×¨×ª ×”××”×™×¨×•×ª!" },
            // ×›×•×—: ×”×•×¨×“ ×œ-9.5
            { type: 'FORCE_CHALLENGE', name: "××›×©×•×œ 2: ×§×™×¨ ×”×¨×™×¡×•×ª ×›×‘×“", requiredStat: 'weight', threshold: 9.5, failMessage: "×”×¨×•×‘×•×˜ ×œ× ×”×™×” ×—×–×§ ××¡×¤×™×§ ×›×“×™ ×œ×©×‘×•×¨ ××ª ×§×™×¨ ×”×”×¨×™×¡×•×ª!" },
            // ××™×–×•×Ÿ: ×”×•×¨×“ ×œ-12
            { type: 'PRECISION_CHALLENGE', name: "××›×©×•×œ 3: ×’×©×¨ ×›×‘×œ×™× ×“×§", requiredStat: 'balance', threshold: 12, failMessage: "×”×¨×•×‘×•×˜ ××™×‘×“ ×™×¦×™×‘×•×ª ×¢×œ ×’×©×¨ ×”×›×‘×œ×™× ×•× ×¤×œ!" },
        ];
        
        // 4. ×”×’×“×¨×ª ×¨×•×‘×•×˜×™× ××ª×—×¨×™×
        // ×¨×•×‘×•×˜ 1 (××”×™×¨×•×ª/××¨×•×¥) - ×™× ×¦×— ××ª ×¨×•×‘ ××›×©×•×œ×™ ×”××”×™×¨×•×ª, ×™×™×›×©×œ ×‘××™×–×•×Ÿ
        const RIVAL_RACE = {
            name: "×¨×•×‘×•×˜ ××¨×•×¥ (××“×•×)", emoji: 'ğŸï¸', color: '#b91c1c', 
            stats: { speed: 18, weight: 6, balance: 8 }, // 3 ××”×™×¨×™×, 1 ×××•×–×Ÿ
            progress: 0, passed: 0, isFinished: false, isWinner: false, robotY: 100 // ××™×§×•× ×‘××¡×œ×•×œ
        };
        // ×¨×•×‘×•×˜ 2 (×›×•×—/×”×¨×™×¡×•×ª) - ×™× ×¦×— ××ª ××›×©×•×œ×™ ×”×›×•×—, ×™×™×›×©×œ ×‘××”×™×¨×•×ª
        const RIVAL_POWER = {
            name: "×¨×•×‘×•×˜ ×›×•×— (×›×—×•×œ)", emoji: 'ğŸ§±', color: '#1d4ed8', 
            stats: { speed: 8, weight: 18, balance: 8 }, // 3 ×›×•×—, 1 ×××•×–×Ÿ
            progress: 0, passed: 0, isFinished: false, isWinner: false, robotY: 200 // ××™×§×•× ×‘××¡×œ×•×œ
        };


        function initHephaestusBuild() {
            const quest = quests[7]; // ×§×•×•×¡×˜ 8
            
            // ×™×¦×™×¨×ª ×¢×•×ª×§ ×©×œ ×”×—×œ×§×™× ×•×”×¦×‘×ª× ×‘××™×§×•× ×”×”×ª×—×œ×ª×™ ×”×§×‘×•×¢
            let currentParts = JSON.parse(JSON.stringify(PART_VARIANTS));
            currentParts.forEach((p) => {
                const pos = INITIAL_PART_POSITIONS[p.id];
                p.x = pos.x; 
                p.y = pos.y;
                p.w = 30; 
                p.h = 30;
                p.isHeld = false; // ××¦×‘ ×—×“×©: ×”×× ×”×©×—×§×Ÿ ××—×–×™×§ ××ª ×”×—×œ×§
            });

            // ××™×¤×•×¡ ×¡×œ×•×˜×™×
            for (const key in BUILD_SLOTS) {
                BUILD_SLOTS[key].assignedPart = null;
            }

            canvasState = {
                isRunning: false, 
                phase: 'BUILD', // 'BUILD' | 'TEST'
                
                lastTick: Date.now(),
                
                // BUILD PHASE
                partsPool: currentParts,
                buildSlots: BUILD_SLOTS,
                
                player: { x: 50, y: canvas.height / 2, w: 30, h: 30, color: '#f59e0b', speed: 4 }, // ×“××•×ª ×”×’×™×‘×•×¨
                heldPart: null, // ×”×—×œ×§ ×©×”×©×—×§×Ÿ ××—×–×™×§
                
                // TEST PHASE
                playerRobot: null, // ×”×¨×•×‘×•×˜ ×©×œ ×”×©×—×§×Ÿ
                rivals: [
                    JSON.parse(JSON.stringify(RIVAL_RACE)), 
                    JSON.parse(JSON.stringify(RIVAL_POWER))
                ],
                obstacles: OBSTACLES, 
                obstaclesPassed: 0,
                robotProgress: 0, 
                robotX: 0, 
                robotY: canvas.height / 2 - 20, 
                robotW: 40, 
                robotH: 40,
                robotSpeed: 2, 
                testStartTime: 0,
                testRunning: false,
                
                update: updateHephaestusBuild,
                draw: drawHephaestusBuild,
            };

            // ×”×ª×—×œ ×œ×•×œ××” ××™×“ ×›×“×™ ×œ××¤×©×¨ ×ª× ×•×¢×” ×‘×©×œ×‘ BUILD
            canvasState.isRunning = true; 
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
            
            // ×¢×“×›×•×Ÿ ×”××™×“×¢ ×”×¨××©×•× ×™
            const info = document.getElementById('game-info');
            if (info) info.innerHTML = "× ×•×•×˜ ×¢× ×”×—×¦×™×, ××¡×•×£/×©×—×¨×¨ ×—×œ×§×™× ×¢× **×¨×•×•×—**.";
            
            // ×”×¡×ª×¨×ª ×›×¤×ª×•×¨ ×”×‘×“×™×§×” ×¢×“ ×œ×”×©×œ××ª ×”×”×¨×›×‘×”
            const btn = document.getElementById('start-game-btn');
            if (btn) btn.style.display = 'none';
            // ×•×•×“× ×©×›×¤×ª×•×¨ ×”××™×¤×•×¡ ××•×¦×’
            const resetButton = document.querySelector('button[onclick="resetHephaestusQuest()"]');
            if (resetButton) resetButton.style.display = 'block';

        }
        
        // --- ×¤×•× ×§×¦×™×” ×’×œ×•×‘×œ×™×ª ×œ×‘×“×™×§×ª ×”×©×œ××” ×•×”×ª×—×œ×ª ××™×¨×•×¥ ---
        function checkBuildCompletion() {
            const btn = document.getElementById('start-game-btn');
            const info = document.getElementById('game-info');
            
            // 1. ×‘×“×•×§ ×× ×›×œ ×”×¡×œ×•×˜×™× ××œ××™×
            const allSlotsFilled = Object.values(canvasState.buildSlots).every(slot => slot.assignedPart !== null);
            
            if (allSlotsFilled) {
                // 2. ×—×©×‘ ××ª × ×ª×•× ×™ ×”×¨×•×‘×•×˜ ×”×¡×•×¤×™×™× ×©×œ ×”×©×—×§×Ÿ
                const stats = { speed: 0, weight: 0, balance: 0, totalScore: 0 };
                Object.values(canvasState.buildSlots).forEach(slot => {
                    stats.speed += slot.assignedPart.stats.speed;
                    stats.weight += slot.assignedPart.stats.weight;
                    stats.balance += slot.assignedPart.stats.balance;
                });

                // ×”×’×“×¨×ª ×”×¨×•×‘×•×˜ ×©×œ ×”×©×—×§×Ÿ (×××¦×‘ ×”-BUILD)
                canvasState.playerRobot = {
                    name: "×”×¨×•×‘×•×˜ ×©×œ×š", emoji: 'ğŸ¤–', color: '#059669', 
                    stats: stats,
                    progress: 0, passed: 0, isFinished: false, isWinner: false, 
                    robotY: 300 // ××™×§×•× ×‘××¡×œ×•×œ
                };

                // 3. ×”×’×“×¨ ××ª ××¦×‘ ×”×¨×•×‘×•×˜ ×œ×˜×¡×˜
                canvasState.phase = 'TEST';
                canvasState.testRunning = false; 
                canvasState.obstaclesPassed = 0;
                
                // ××™×¤×•×¡ ××™×§×•××™ ×¨×•×‘×•×˜×™× ××ª×—×¨×™×
                canvasState.rivals.forEach(r => {
                    r.progress = 0; r.passed = 0; r.isFinished = false; r.isWinner = false;
                });
                
                // 4. ×”×¦×’ ×›×¤×ª×•×¨ ×•×”×•×¨××•×ª
                if (btn) {
                    btn.textContent = "×”×ª×—×œ ××™×¨×•×¥ ×¨×•×‘×•×˜!";
                    btn.onclick = () => {
                        // ×”×ª×—×œ×ª ×”××™×¨×•×¥: ××©× ×” ××ª ×”×¡×˜×˜×•×¡ ×œ×¨×™×¦×” ×•×××¤×©×¨ ×œ-updateTest ×œ×–×•×–
                        canvasState.testRunning = true; 
                        // ×œ×•×•×“× ×©×”×œ×•×œ××” ××›×Ÿ ×¨×¦×”
                        if (!canvasState.isRunning) {
                            canvasState.isRunning = true;
                            gameLoopId = requestAnimationFrame(gameLoop);
                        }
                        btn.style.display = 'none'; // ×”×¡×ª×¨ ×›×¤×ª×•×¨
                        // ×”×¡×ª×¨×ª ×›×¤×ª×•×¨ ×”××™×¤×•×¡ ×‘×¨×’×¢ ×©×”××™×¨×•×¥ ××ª×—×™×œ
                        const resetButton = document.querySelector('button[onclick="resetHephaestusQuest()"]');
                        if (resetButton) resetButton.style.display = 'none';

                    };
                    btn.style.display = 'block';
                }

                // ×¢×“×›×•×Ÿ ××™×“×¢ ×¢× ×¡×˜×˜×™×¡×˜×™×§×•×ª
                if (info) info.innerHTML = `×”×¨×›×‘×” ×”×•×©×œ××”! ×”×¨×•×‘×•×˜ ××•×›×Ÿ ×œ××‘×—×Ÿ. <br> **××”×™×¨×•×ª: ${stats.speed} | ×›×•×—: ${stats.weight} | ××™×–×•×Ÿ: ${stats.balance}**`;
                
                // ×¢×¦×•×¨ ××ª ×ª× ×•×¢×ª ×”×’×™×‘×•×¨ (×©×œ×‘ BUILD)
                canvasState.isRunning = false; 
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
                canvasState.draw(); // ×¦×™×•×¨ ×¤×¨×™×™× ××—×“ ×¡×˜×˜×™ ×©×œ ××¦×‘ ×”××™×¨×•×¥ ×œ×¤× ×™ ×”×”×ª×—×œ×”
            } else {
                if (btn) btn.style.display = 'none';
                if (info) info.innerHTML = "× ×•×•×˜ ×¢× ×”×—×¦×™×, ××¡×•×£/×©×—×¨×¨ ×—×œ×§×™× ×¢× **×¨×•×•×—**. ×—×¡×¨×™× ×—×œ×§×™×.";
            }
        }
        
        
        function handleBuildInput() {
            const player = canvasState.player;
            
            // ×‘×“×™×§×” ×× × ×œ×—×¥ ××§×© ×¨×•×•×— (Space)
            if (keys[' ']) {
                
                if (canvasState.heldPart) {
                    // --- ×©×œ×‘ 2: ×©×—×¨×•×¨ ×—×œ×§ ---
                    
                    let dropped = false;
                    
                    // ×‘×•×“×§ ×”×ª× ×’×©×•×ª ××•×œ ×¡×œ×•×˜×™× ×¤× ×•×™×™×
                    for (const key in canvasState.buildSlots) {
                        const slot = canvasState.buildSlots[key];
                        
                        // ×‘×“×™×§×ª ×”×ª× ×’×©×•×ª (××¨×›×– ×”×©×—×§×Ÿ ××•×œ ××¨×›×– ×”×¡×œ×•×˜)
                        const distance = Math.sqrt(
                            Math.pow((player.x + player.w/2) - slot.x, 2) + 
                            Math.pow((player.y + player.h/2) - slot.y, 2)
                        );
                        
                        // ×× ×§×¨×•×‘ ××¡×¤×™×§ ×œ×¡×œ×•×˜ ×•××™×Ÿ ×‘×• ×—×œ×§
                        if (distance < slot.radius + 15 && !slot.assignedPart) { 
                            slot.assignedPart = canvasState.heldPart;
                            canvasState.heldPart.isHeld = false;
                            
                            // ××™×§×•× ×”×—×œ×§ ×‘×¡×œ×•×˜ ×œ×¦×•×¨×š ×¦×™×•×¨
                            canvasState.heldPart.x = slot.x;
                            canvasState.heldPart.y = slot.y;

                            canvasState.heldPart = null;
                            dropped = true;
                            break;
                        }
                    }
                    
                    // ×× ×©×•×—×¨×¨ ×‘×”×¦×œ×—×”, ×‘×•×“×§×™× ×”×©×œ××” ×•××¦×™×™×¨×™× ××—×“×©
                    if (dropped) {
                        // ×‘×“×™×§×” ×”×× ×›×œ ×”×¡×œ×•×˜×™× ××œ××™× ×œ××—×¨ ×”×©×—×¨×•×¨
                        const allFilled = Object.values(canvasState.buildSlots).every(slot => slot.assignedPart !== null);
                        if(allFilled) {
                            checkBuildCompletion(); // ×× ×”×•×©×œ×, ××¢×‘×¨ ×œ×˜×¡×˜
                        } else {
                            canvasState.draw();
                        }
                    } else {
                        // ×× ×œ× ×©×•×—×¨×¨ ×‘×¡×œ×•×˜, ××—×–×™×¨×™× ××•×ª×• ×œ×××’×¨ (×›×“×™ ×©×™×”×™×” ××¤×©×¨ ×œ××¡×•×£ ××•×ª×• ×©×•×‘)
                         canvasState.heldPart.isHeld = false;
                         const originalPos = INITIAL_PART_POSITIONS[canvasState.heldPart.id];
                         canvasState.heldPart.x = originalPos.x;
                         canvasState.heldPart.y = originalPos.y;
                         canvasState.heldPart = null;
                         canvasState.draw();
                    }
                    
                } else {
                    // --- ×©×œ×‘ 1: ××™×¡×•×£ ×—×œ×§ ---
                    
                    // ×‘×•×“×§ ×”×ª× ×’×©×•×ª ××•×œ ×—×œ×§×™× ×¤× ×•×™×™× ×‘×××’×¨
                    for (let i = canvasState.partsPool.length - 1; i >= 0; i--) {
                        const part = canvasState.partsPool[i];
                        
                        // ×¨×§ ×× ×”×—×œ×§ ×œ× ××•×—×–×§ ×•×œ× ××•×¨×›×‘
                        if (!part.isHeld && 
                            !Object.values(canvasState.buildSlots).some(s => s.assignedPart === part) &&
                            checkCollision(player, part)) {
                            
                            canvasState.heldPart = part;
                            part.isHeld = true;
                            canvasState.draw();
                            break;
                        }
                    }
                }
                
                keys[' '] = false; // ××™×¤×•×¡ ×¨×•×•×— ×›×“×™ ×©×œ× ×™×¤×¢×œ ×¨×¦×•×£
            }
        }

        // ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×‘×“×™×§×ª ××›×©×•×œ ×¢×‘×•×¨ ×¨×•×‘×•×˜ (×©×—×§×Ÿ ××• ×™×¨×™×‘)
        function checkRobotObstacle(robot, currentObstacleIndex) {
             const obstacle = canvasState.obstacles[currentObstacleIndex];
             // ×©×™××•×© ×‘×¦×™×•×Ÿ ×”××™×–×•×Ÿ ×”××§×•×¨×™ ×›×›×¤×•×œ 4
             const scoreToCheck = obstacle.requiredStat === 'balance' ? robot.stats.balance * 4 : robot.stats[obstacle.requiredStat];

             if (scoreToCheck < obstacle.threshold) {
                 return { passed: false, message: `${robot.name} × ×›×©×œ ×‘${obstacle.name}. (× ×“×¨×© ${obstacle.threshold}, ×§×™×‘×œ ${scoreToCheck.toFixed(1)})` };
             } else {
                 // ×¨×§ ××¢×‘×™×¨ ××ª ×”××›×©×•×œ (×¢×“×›×•×Ÿ passed × ×¢×©×” ×‘×œ×•×œ××”)
                 return { passed: true, message: null };
             }
        }


        function updateHephaestusBuild(timestamp) {
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            const player = canvasState.player;
            // ×”×¨×•×‘×•×˜ ×©×œ×š ×”×•× ×ª××™×“ ×”×¨××©×•×Ÿ ×‘×¨×©×™××”
            const allRobots = [canvasState.playerRobot, ...canvasState.rivals];


            if (canvasState.phase === 'BUILD') {
                // 1. ×ª× ×•×¢×ª ×©×—×§×Ÿ
                const speed = player.speed * elapsed * 60;
                if (keys['ArrowLeft'] && player.x > 0) player.x -= speed;
                if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += speed;
                if (keys['ArrowUp'] && player.y > 0) player.y -= speed;
                if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += speed;

                // 2. ×¢×“×›×•×Ÿ ××™×§×•× ×”×—×œ×§ ×”××•×—×–×§ (×¦××•×“ ×œ×“××•×ª)
                if (canvasState.heldPart) {
                    canvasState.heldPart.x = player.x + player.w / 2;
                    canvasState.heldPart.y = player.y - 10;
                }

                // 3. ×œ×•×’×™×§×ª ××™×¡×•×£/×©×—×¨×•×¨
                handleBuildInput();

            } else if (canvasState.phase === 'TEST' && canvasState.testRunning) {
                
                let winnerFound = false;
                let firstFinisher = null;
                
                // --- ×¢×“×›×•×Ÿ ×›×œ ×”×¨×•×‘×•×˜×™× ---
                for (const robot of allRobots) {
                    if (robot && !robot.isFinished) {
                        
                        // 1. ×ª× ×•×¢×ª ×”×¨×•×‘×•×˜
                        // ×§×‘×•×¢ ××”×™×¨×•×ª: 1.0 ×œ×›×•×œ×, ×›×“×™ ×©×”×¡×˜×˜×™×¡×˜×™×§×” ×ª×—×œ×™×˜ ××™ ××”×™×¨ ×™×•×ª×¨
                        const speedFactor = 1.0; 
                        const baseSpeed = robot.stats.speed / 100; 
                        robot.progress += baseSpeed * elapsed * 60 * speedFactor; 

                        // 2. ×‘×“×™×§×ª ××›×©×•×œ × ×•×›×—×™
                        const currentObstacleIndex = robot.passed;
                        
                        if (currentObstacleIndex < canvasState.obstacles.length) {
                             const obstacle = canvasState.obstacles[currentObstacleIndex];
                             const obstacleX = 100 + currentObstacleIndex * 100; // ××™×§×•× ×”××›×©×•×œ

                             // ×‘×“×™×§×ª ×”×’×¢×” ×œ××›×©×•×œ (×˜×•×•×— ×§×˜×Ÿ ×œ×¤× ×™ ×”××›×©×•×œ)
                             if (robot.progress + canvasState.robotW >= obstacleX && robot.progress < obstacleX + 10) {
                                 
                                 const result = checkRobotObstacle(robot, currentObstacleIndex);
                                 
                                 if (result.passed) {
                                     // ×¢×‘×¨! ×§×“× ×œ××›×©×•×œ ×”×‘×
                                     robot.passed++;
                                 } else {
                                     // × ×›×©×œ!
                                     robot.isFinished = true;
                                     robot.color = '#78350f'; // ×¦×‘×¢ ×—×•× ×œ×¨×•×‘×•×˜ ×©× ×›×©×œ
                                     
                                     // ×× ×”×¨×•×‘×•×˜ ×©×œ ×”×©×—×§×Ÿ × ×›×©×œ, ×¢×¦×•×¨ ××ª ×”××©×—×§
                                     if (robot === canvasState.playerRobot) {
                                        canvasState.testRunning = false;
                                        canvasState.isRunning = false;
                                        // ×©×™× ×•×™: ××¢×‘×¨ ××™×™×“×™ ×—×–×¨×” ×œ-BUILD
                                        handleQuestResult(false, result.message); 
                                        return; 
                                     }
                                 }
                             }
                        } else if (robot.progress > canvas.width) {
                            // 3. ×”×¨×•×‘×•×˜ ×¡×™×™× ××ª ×”××¡×œ×•×œ
                            robot.isFinished = true;
                            if (!firstFinisher) {
                                firstFinisher = robot; // ×©××•×¨ ××ª ×”×¨×•×‘×•×˜ ×”×¨××©×•×Ÿ ×©×¡×™×™×
                            }
                            winnerFound = true; // ×¡×™××Ÿ ×©×™×© ××™ ×©×¡×™×™×
                        }
                    }
                }
                
                // --- ×‘×“×™×§×ª ×× ×¦×— ×¡×•×¤×™×ª (×¨×§ ×× ××™×©×”×• ×¡×™×™×) ---
                if (winnerFound) {
                    // ×”×›×¨×–×ª ×× ×¦×— ×¢×œ ×¤×™ ××™ ×©×¡×™×™× ×¨××©×•×Ÿ (firstFinisher)
                    if (firstFinisher) {
                        firstFinisher.isWinner = true;
                        
                        if (firstFinisher === canvasState.playerRobot) {
                            handleQuestResult(true, `× ×™×¦×—×•×Ÿ! ×”×¨×•×‘×•×˜ ×©×œ×š ×”×•× ×”×× ×¦×— ×”××•×œ×™××¤×™!`, 900);
                        } else {
                            handleQuestResult(false, `×”×¨×•×‘×•×˜ ×©×œ×š ×”×¤×¡×™×“! ×”×× ×¦×— ×”×•× ${firstFinisher.name}. × ×¡×” ×œ×‘× ×•×ª ×¨×•×‘×•×˜ ×˜×•×‘ ×™×•×ª×¨.`);
                        }
                    }
                    
                    canvasState.testRunning = false;
                    canvasState.isRunning = false;
                }
            }
        }

        // ×¤×•× ×§×¦×™×” ×¦×™×•×¨ ×©×œ ×”×¨×•×‘×•×˜
        function drawRobot(robot) {
            if (!ctx) return;
            
            // ×¦×™×•×¨ ××¡×œ×•×œ ×™×™×—×•×“×™ ×œ×›×œ ×¨×•×‘×•×˜ (××¢×˜ ×¦×œ ×›×“×™ ×©×™×™×¨××” ×›××• ××¡×™×œ×”)
            const trackY = robot.robotY + canvasState.robotH / 2;
            ctx.fillStyle = '#cccccc'; 
            ctx.globalAlpha = 0.5;
            ctx.fillRect(0, trackY - 1, canvas.width, 2);
            ctx.globalAlpha = 1.0;
            
            
            // --- ×¦×™×•×¨ ×”××›×©×•×œ ×”×“×™× ××™ ---
            const currentObstacleIndex = robot.passed;
            if (currentObstacleIndex < canvasState.obstacles.length) {
                const obstacle = canvasState.obstacles[currentObstacleIndex];
                const obstacleX = 100 + currentObstacleIndex * 100;
                
                // ×× ×”×¨×•×‘×•×˜ × ××¦× ×‘×ª×•×š ×˜×•×•×— ×”××›×©×•×œ
                if (robot.progress > obstacleX - 30 && robot.progress < obstacleX + 50) {
                    
                    ctx.globalAlpha = 0.2;
                    if (obstacle.type === 'SPEED_CHALLENGE') {
                        // ×× ×”×¨×ª ×¨×•×— (××“×•×)
                        ctx.fillStyle = '#f87171'; 
                    } else if (obstacle.type === 'FORCE_CHALLENGE') {
                        // ×§×™×¨ ×”×¨×™×¡×•×ª (××¤×•×¨/×›×—×•×œ)
                         ctx.fillStyle = '#3b82f6';
                    } else if (obstacle.type === 'PRECISION_CHALLENGE') {
                         // ×¨×¢×™×“×•×ª (×™×¨×•×§)
                         ctx.fillStyle = '#10b981'; 
                    }
                     // ×¦×™×•×¨ ××¤×§×˜ ×“×™× ××™ ×¨×§ ×¢×œ ×”××¡×œ×•×œ ×©×œ×•
                    ctx.fillRect(obstacleX - 30, trackY - 15, 80, 30);
                    ctx.globalAlpha = 1.0;
                }
            }

            // ×¦×™×•×¨ ×¨×•×‘×•×˜ ×›×¨×™×‘×•×¢ (×œ×¦×•×¨×š ×”×ª× ×’×©×•×ª)
            ctx.fillStyle = robot.color;
            ctx.fillRect(robot.progress, robot.robotY, canvasState.robotW, canvasState.robotH);
            
            // ×¦×™×•×¨ ××™××•×’'×™ ×‘×ª×•×š ×”×¨×™×‘×•×¢
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(robot.emoji, robot.progress + canvasState.robotW / 2, robot.robotY + 30);
            
            // ×¦×™×•×¨ ×©× ×”×¨×•×‘×•×˜
            ctx.fillStyle = '#1f2937';
            ctx.font = '10px Inter';
            ctx.fillText(robot.name, robot.progress + canvasState.robotW / 2, robot.robotY - 5);

            // ×¡×™××•×Ÿ ×¡×˜×˜×•×¡ (×× × ×›×©×œ)
            if (robot.isFinished && !robot.isWinner) {
                 ctx.fillStyle = '#b91c1c';
                 ctx.font = '20px Arial';
                 ctx.fillText('âŒ', robot.progress + canvasState.robotW / 2, robot.robotY + 20);
            }
             // ×¡×™××•×Ÿ ×•×™×–×•××œ×™ ×©×œ ××™ ×¢×‘×¨ ××ª ×”××›×©×•×œ
             if (robot.passed > 0) {
                 ctx.fillStyle = '#059669';
                 ctx.font = '15px Arial';
                 ctx.fillText(`${robot.passed} / 3`, robot.progress + canvasState.robotW / 2, robot.robotY + 48);
             }
        }

        function drawHephaestusBuild() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const info = document.getElementById('game-info');
            
            // ×©×œ×‘ BUILD
            if (canvasState.phase === 'BUILD') {
                const player = canvasState.player;

                // --- ×¦×™×•×¨ ×©×œ×‘ ×”×”×¨×›×‘×” ---
                
                // ×§×• ×”×¤×¨×“×” ×‘×™×Ÿ ××–×•×¨ ×”×¨×›×‘×” ×œ××–×•×¨ ×—×œ×§×™ ×—×™×œ×•×£
                ctx.strokeStyle = '#9ca3af'; 
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 + 30, 0);
                ctx.lineTo(canvas.width / 2 + 30, canvas.height);
                ctx.stroke();

                // 1. ×¦×™×•×¨ ×¡×œ×•×˜×™× (××§×•××•×ª ×”×¨×›×‘×”)
                ctx.textAlign = 'center';
                for (const key in canvasState.buildSlots) {
                    const slot = canvasState.buildSlots[key];
                    ctx.beginPath();
                    ctx.arc(slot.x, slot.y, slot.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = slot.assignedPart ? '#059669' : '#9ca3af';
                    ctx.font = '10px Inter';
                    
                    // ×›×™×ª×•×‘ ×¡×œ×•×˜
                    let text;
                    if (key === ROBOT_PARTS.HEAD) text = "×¨××© (HEAD)";
                    else if (key === ROBOT_PARTS.BODY) text = "×’×•×£ (BODY)";
                    else if (key === ROBOT_PARTS.ARM) text = "×–×¨×•×¢×•×ª (ARM)";
                    else if (key === ROBOT_PARTS.WHEEL) text = "×’×œ×’×œ×™× (WHEEL)";
                    
                    ctx.fillText(text, slot.x, slot.y + slot.radius + 15);
                    
                    // ×¦×™×•×¨ ×”×—×œ×§ ×©×”×•×¦××“ ×œ×¡×œ×•×˜
                    if (slot.assignedPart) {
                        ctx.font = '25px Arial';
                        ctx.fillText(slot.assignedPart.emoji, slot.x, slot.y + 10);
                    }
                }

                // 2. ×¦×™×•×¨ ×××’×¨ ×”×—×œ×§×™× (×™××™×Ÿ)
                ctx.fillStyle = '#1f2937';
                ctx.font = '12px Inter';
                ctx.textAlign = 'right';
                ctx.fillText("×××’×¨ ×—×œ×§×™×:", canvas.width - 20, 30);
                
                // ×œ×•×œ××” ×¢×œ ×›×œ ×”×—×œ×§×™×
                canvasState.partsPool.forEach(part => {
                    // ×¦×™×•×¨ ×¨×§ ×× ×”×—×œ×§ ×œ× ××•×—×–×§ ×¢×œ ×™×“×™ ×”×©×—×§×Ÿ ×•××™×Ÿ ×œ×• ×¡×œ×•×˜
                    let isAssignedToSlot = Object.values(canvasState.buildSlots).some(s => s.assignedPart === part);

                    if (!part.isHeld && !isAssignedToSlot) {
                         // ×¨×§×¢ ×§×˜×Ÿ ×œ×—×œ×§
                        ctx.fillStyle = '#fcd34d';
                        ctx.fillRect(part.x - part.w/2, part.y - part.h/2, part.w, part.h);
                        
                        // ×¦×™×•×¨ ×”××™××•×’'×™
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(part.emoji, part.x, part.y + 7);

                        // ×›×™×ª×•×‘ ××ª×—×ª ×œ××™××•×’'×™
                        ctx.font = '10px Inter';
                        ctx.fillStyle = '#1f2937';
                        ctx.fillText(part.name, part.x, part.y + 25);
                    }
                });

                // 3. ×¦×™×•×¨ ×”×—×œ×§ ×”××•×—×–×§
                if(canvasState.heldPart) {
                    const part = canvasState.heldPart;
                    // ×¨×§×¢ ×œ×—×œ×§ ×”××•×—×–×§
                    ctx.fillStyle = '#f87171'; // ×¦×‘×¢ ××“×•× ×œ×”×“×’×©×”
                    ctx.fillRect(part.x - part.w/2, part.y - part.h/2, part.w, part.h);
                    
                    // ×¦×™×•×¨ ×”××™××•×’'×™
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(part.emoji, part.x, part.y + 7);

                    // ×¦×™×•×¨ ×›×™×ª×•×‘ ×§×˜×Ÿ
                    ctx.font = '10px Inter';
                    ctx.fillStyle = '#1f2937';
                    ctx.fillText(part.name, part.x, part.y + 25);
                }

                // 4. ×¦×™×•×¨ ×”×“××•×ª ×”×©×•×œ×˜×ª
                drawPlayerFigure(player, canvasState.heldPart !== null);

            } 
            
            // ×©×œ×‘ TEST (××™×¨×•×¥ ××•×œ ×™×¨×™×‘×™×)
            else if (canvasState.phase === 'TEST') {
                // --- ×¦×™×•×¨ ×©×œ×‘ ×”××™×¨×•×¥ ---
                ctx.textAlign = 'center';
                
                // 1. ×¦×™×•×¨ ×§×• ×”×‘×¡×™×¡ (×”×¨×¦×¤×”) - × ××ª×— ×œ×¨×•×—×‘ ×”××¡×š
                ctx.strokeStyle = '#1f2937';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - 40);
                ctx.lineTo(canvas.width, canvas.height - 40);
                ctx.stroke();

                // 2. ×¦×™×•×¨ ××›×©×•×œ×™×
                ctx.lineWidth = 3;
                canvasState.obstacles.forEach((obstacle, index) => {
                    const obstacleX = 100 + index * 100;
                    
                    // ×¦×‘×¢ ××¤×•×¨ ×œ×¤× ×™ ×”×”×’×¢×”, ××“×•× ×‘×–××Ÿ ×”××›×©×•×œ
                    let lineColor = '#9ca3af'; 
                    // × ×‘×“×•×§ ××ª ××¦×‘ ×”×¨×•×‘×•×˜ ×©×œ ×”×©×—×§×Ÿ ×œ×¦×•×¨×š ×”×“×’×©×ª ×”××›×©×•×œ ×”× ×•×›×—×™
                    if (canvasState.playerRobot && index === canvasState.playerRobot.passed) {
                        lineColor = '#b91c1c'; // ××“×•×: ×›×¢×ª ×”××‘×—×Ÿ
                        ctx.fillStyle = '#fef3c7'; // ×¦×”×•×‘ ×‘×”×™×¨
                        // ×¦×™×•×¨ ××œ×‘×Ÿ ×”××›×©×•×œ ×›××¢×‘×¨ ×•×™×–×•××œ×™
                        ctx.fillRect(obstacleX, 0, 5, canvas.height); // ×§×• ××›×©×•×œ ×× ×›×™
                        
                    } else if (canvasState.playerRobot && index < canvasState.playerRobot.passed) {
                        lineColor = '#059669'; // ×™×¨×•×§ ××—×¨×™ ××¢×‘×¨
                    }
                    
                    ctx.strokeStyle = lineColor; 
                    
                    // ×¦×™×•×¨ ×¡×™××Ÿ ×”××›×©×•×œ (×§×•)
                    ctx.beginPath();
                    ctx.moveTo(obstacleX, 0);
                    ctx.lineTo(obstacleX, canvas.height - 40);
                    ctx.stroke();
                    
                    // ×›×™×ª×•×‘
                    ctx.fillStyle = '#1f2937';
                    ctx.font = '12px Inter';
                    // ×”×¦×’×ª ×“×¨×™×©×ª ×”×¡×£ ×‘×›×™×ª×•×‘ ×”××›×©×•×œ
                    ctx.fillText(`${obstacle.name}`, obstacleX, 20);
                    ctx.fillText(`(×“×¨×™×©×”: ${obstacle.threshold})`, obstacleX, 35); // ×”×¦×’×ª ×“×¨×™×©×”

                    // ×¡×™××•×Ÿ ×”×¦×œ×—×”
                    if (canvasState.playerRobot && index < canvasState.obstacles.length && canvasState.playerRobot.passed > index) {
                        ctx.fillStyle = '#059669';
                        ctx.font = '20px Arial';
                        ctx.fillText('âœ…', obstacleX, canvas.height - 20);
                    }
                });

                // 3. ×¦×™×•×¨ ×”×¨×•×‘×•×˜×™×
                // ×¨×•×‘×•×˜ ××¨×•×¥
                drawRobot(canvasState.rivals[0]);
                // ×¨×•×‘×•×˜ ×›×•×—
                drawRobot(canvasState.rivals[1]);
                // ×”×¨×•×‘×•×˜ ×©×œ ×”×©×—×§×Ÿ (×ª××™×“ ××—×¨×•×Ÿ ×›×“×™ ×œ×”×™×•×ª ×‘-TOP)
                if (canvasState.playerRobot) drawRobot(canvasState.playerRobot);
                
                // 4. ×¢×“×›×•×Ÿ ××™×“×¢
                if (info && canvasState.playerRobot) {
                    const playerStats = canvasState.playerRobot.stats;
                    
                    info.innerHTML = `
                        <div class="text-xs text-gray-700">
                             ğŸ¤– ×©×œ×š: ××”×™×¨×•×ª: ${playerStats.speed} | ×›×•×—: ${playerStats.weight} | **××™×–×•×Ÿ: ${playerStats.balance}**
                        </div>
                        <div class="text-lg font-bold mt-1">
                            ×©×œ×‘ × ×•×›×—×™: <span class="text-blue-600">${canvasState.playerRobot.passed + 1} / ${quest.target}</span>
                        </div>
                    `;
                }
            }
        }

        // --- ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×¦×™×•×¨ ×¤×¡×™ ×‘×¨×™××•×ª ---
        function drawHealthBar(x, y, width, height, current, max, color) {
            if (!ctx) return;
            const percent = current / max;
            
            // ×¨×§×¢ ××¤×•×¨
            ctx.fillStyle = '#666666';
            ctx.fillRect(x, y, width, height);
            
            // ×¤×¡ ×‘×¨×™××•×ª
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width * percent, height);
            
            // ××¡×’×¨×ª
            ctx.strokeStyle = '#333333';
            ctx.strokeRect(x, y, width, height);
        }
        
        // --- ×¦×™×•×¨ ×“××•×ª ××¨×¡ ××•×ª×××ª ××™×©×™×ª (×›××• ×”×’×™×‘×•×¨, ××‘×œ ×¢× ×©×¨×™×•×Ÿ) ---
        function drawAresFigure(ares) {
            if (!ctx) return;
            const x = ares.x;
            const y = ares.y;
            const w = ares.w; // 50
            const h = ares.h; // 50
            const centerX = x + w / 2;
            
            const bodyW = 20; // ×¨×•×—×‘ ×’×•×£ ×¦×¨
            const bodyH = 30; // ×’×•×‘×” ×’×•×£

            // 1. ×’×•×£ (××œ×‘×Ÿ ×©××™×™×¦×’ ×©×¨×™×•×Ÿ ×›×‘×“) - ×¦×‘×¢ ××“×•× ×›×”×”
            ctx.fillStyle = ares.color; // #b91c1c (××“×•× ×©×œ ××¨×¡)
            // ××™×§×•× ××—×“×© ×›×“×™ ×©×”×’×•×£ ×™×”×™×” ×¦×¨ ×™×•×ª×¨ ×‘××¨×›×–
            ctx.fillRect(centerX - bodyW / 2, y + h * 0.2, bodyW, bodyH); 

            // 2. ×¨××© (×‘×¡×™×¡ ×§×¡×“×”)
            ctx.beginPath();
            ctx.arc(centerX, y + 7, 7, 0, Math.PI * 2);
            ctx.fillStyle = '#555555'; // ××¤×•×¨ ×›×”×”/××ª×›×ª
            ctx.fill();
            ctx.closePath();
            
            // 3. ××’×Ÿ ×¤× ×™×/××¦×— (×–×”×‘)
            ctx.fillStyle = '#FFD700'; 
            ctx.beginPath();
            ctx.moveTo(centerX - 8, y + 7);
            ctx.lineTo(centerX + 8, y + 7);
            ctx.lineTo(centerX, y - 5);
            ctx.closePath();
            ctx.fill();

            // 4. ×¦×™×¦×™×ª/×›×¨×‘×•×œ×ª ××“×•××” (Crest) - ×’×‘×•×”×” ×•×“×¨××˜×™×ª
            ctx.beginPath();
            ctx.moveTo(centerX, y - 5);
            ctx.lineTo(centerX + 3, y - 15);
            ctx.lineTo(centerX - 3, y - 15);
            ctx.closePath();
            ctx.fillStyle = '#ff0000'; // ××“×•× ×–×•×”×¨
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // 5. ×¨×’×œ×™×™× (×§×•×•×™× ×¤×©×•×˜×™×)
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            // ××–×™×– ××ª ×”×¨×’×œ×™×™× ×›×“×™ ×©×™×ª××™××• ×œ×’×•×£ ×”×¦×¨
            ctx.beginPath();
            ctx.moveTo(centerX - 5, y + h - 5);
            ctx.lineTo(centerX - 5, y + h);
            ctx.moveTo(centerX + 5, y + h - 5);
            ctx.lineTo(centerX + 5, y + h);
            ctx.stroke();
        }

        // --- ×§×•×•×¡×˜ 9: ××¨×¡ - ×“×•-×§×¨×‘ ×”×–×¢× ---
        function initAresDuel() {
            const quest = quests[8]; // Quest ID 9 (index 8)
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#f59e0b', speed: 4.5, maxHP: 100, currentHP: 100 }, 
                // ×©×™× ×•×™: ××¨×¡ ××ª×—×™×œ ×‘××™×§×•× ×¡×¤×¦×™×¤×™
                ares: { x: canvas.width / 2 - 25, y: 50, w: 50, h: 50, color: '#b91c1c', maxHP: 150, currentHP: 150, speed: 1.5, lastShot: 0, shootRate: 1500 }, 
                playerProjectiles: [],
                aresProjectiles: [],
                lastPlayerShot: 0,
                playerShootCooldown: 300, // 300ms cooldown for player shooting (Spacebar)
                update: updateAresDuel,
                draw: drawAresDuel,
            };
        }

        function updateAresDuel(timestamp) {
            const player = canvasState.player;
            const ares = canvasState.ares;

            // 1. ×ª× ×•×¢×ª ×©×—×§×Ÿ (Arrows)
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // 2. ×™×¨×™ ×©×—×§×Ÿ (Spacebar)
            if (keys[' '] && timestamp - canvasState.lastPlayerShot > canvasState.playerShootCooldown) {
                // ×™×¦×™×¨×ª ×§×œ×™×¢ ×©×œ ×”×©×—×§×Ÿ
                canvasState.playerProjectiles.push({
                    x: player.x + player.w / 2 - 2, 
                    y: player.y,
                    w: 4, h: 10, speed: 7, damage: 10, color: '#FFD700', type: 'arrow'
                });
                canvasState.lastPlayerShot = timestamp;
                // ××™×Ÿ ××™×¤×•×¡ ×¨×•×•×— ×›××Ÿ, ×›×¤×ª×•×¨ ×”×¨×•×•×— ××˜×•×¤×œ ×‘-handleKeyUp
            }
            
            // 3. ×ª× ×•×¢×” ×•××ª×§×¤×” ×©×œ ××¨×¡
            // ×ª× ×•×¢×”: ×ª× ×•×¢×” ××•×¤×§×™×ª ×¤×©×•×˜×”
            ares.x += ares.speed;
            if (ares.x > canvas.width - ares.w || ares.x < 0) {
                ares.speed *= -1;
            }

            // ×™×¨×™ ××¨×¡ (××–××Ÿ)
            if (timestamp - ares.lastShot > ares.shootRate) {
                // ×™×¦×™×¨×ª ×§×œ×™×¢ ×©×œ ××¨×¡ (×—× ×™×ª ××›×•×•× ×ª)
                const dx = (player.x + player.w / 2) - (ares.x + ares.w / 2);
                const dy = (player.y + player.h / 2) - (ares.y + ares.h / 2);
                const angle = Math.atan2(dy, dx);
                
                canvasState.aresProjectiles.push({
                    x: ares.x + ares.w / 2 - 5, 
                    y: ares.y + ares.h,
                    w: 10, h: 10, speed: 4, damage: 20, color: '#b91c1c',
                    speedX: Math.cos(angle) * 4,
                    speedY: Math.sin(angle) * 4
                });
                ares.lastShot = timestamp;
                // ×”×’×‘×¨×ª ×§×¦×‘ ×™×¨×™
                ares.shootRate = Math.max(800, ares.shootRate - 2);
            }


            // 4. ×¢×“×›×•×Ÿ ×§×œ×™×¢×™ ×©×—×§×Ÿ ×•×‘×“×™×§×ª ×”×ª× ×’×©×•×ª ××•×œ ××¨×¡
            for (let i = canvasState.playerProjectiles.length - 1; i >= 0; i--) {
                const proj = canvasState.playerProjectiles[i];
                proj.y -= proj.speed;

                if (checkCollision(proj, ares)) {
                    ares.currentHP = Math.max(0, ares.currentHP - proj.damage);
                    canvasState.playerProjectiles.splice(i, 1);
                } else if (proj.y < -10) {
                    canvasState.playerProjectiles.splice(i, 1);
                }
            }

            // 5. ×¢×“×›×•×Ÿ ×§×œ×™×¢×™ ××¨×¡ ×•×‘×“×™×§×ª ×”×ª× ×’×©×•×ª ××•×œ ×©×—×§×Ÿ
            for (let i = canvasState.aresProjectiles.length - 1; i >= 0; i--) {
                const proj = canvasState.aresProjectiles[i];
                proj.x += proj.speedX;
                proj.y += proj.speedY;

                if (checkCollision(proj, player)) {
                    player.currentHP = Math.max(0, player.currentHP - proj.damage);
                    canvasState.aresProjectiles.splice(i, 1);
                } else if (proj.y < -10 || proj.y > canvas.height + 10 || proj.x < -10 || proj.x > canvas.width + 10) {
                    canvasState.aresProjectiles.splice(i, 1);
                }
            }
            
            // 6. ×‘×“×™×§×ª ×ª× ××™ × ×™×¦×—×•×Ÿ/×”×¤×¡×“
            if (ares.currentHP <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(true, `×”×‘×¡×ª ××ª ××¨×¡ ×‘×“×•-×§×¨×‘! ×”×–×¢× ×©×œ×• × ×¨×’×¢ ×•×”×‘×œ×’×Ÿ ×”××•×œ×™××¤×™ ×”×¡×ª×™×™×.`, 1200);
            } else if (player.currentHP <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `××¨×¡ ×”×‘×™×¡ ××•×ª×š ×‘×“×•-×§×¨×‘. × ×¡×” ×©×•×‘ ×œ×—××© ××ª ×¢×¦××š!`);
            }
        }

        function drawAresDuel() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const player = canvasState.player;
            const ares = canvasState.ares;

            // 1. ×¦×™×•×¨ ×§×œ×™×¢×™ ××¨×¡ (×—× ×™×ª×•×ª ×× ×¨×’×™×”)
            canvasState.aresProjectiles.forEach(proj => {
                 ctx.fillStyle = proj.color; // ××“×•×
                 ctx.shadowColor = proj.color;
                 ctx.shadowBlur = 10;
                 ctx.fillRect(proj.x, proj.y, proj.w, proj.h);
                 
                 // ×¦×™×•×¨ ×—×¥ ××• ×§×¦×” ×—× ×™×ª
                 ctx.fillStyle = '#FFD700';
                 ctx.fillRect(proj.x + proj.w / 2 - 2, proj.y, 4, 15);

                 ctx.shadowBlur = 0;
            });

            // 2. ×¦×™×•×¨ ×§×œ×™×¢×™ ×©×—×§×Ÿ (×× ×¨×’×™×”)
            canvasState.playerProjectiles.forEach(proj => {
                 ctx.fillStyle = proj.color; // ×¦×”×•×‘
                 ctx.shadowColor = proj.color;
                 ctx.shadowBlur = 8;
                 ctx.fillRect(proj.x, proj.y, proj.w, proj.h);
                 ctx.shadowBlur = 0;
            });

            // 3. ×¦×™×•×¨ ××¨×¡ (××•×™×‘)
            drawAresFigure(ares);

            // 4. ×¦×™×•×¨ ×©×—×§×Ÿ (×“××•×ª)
            drawPlayerFigure(player);

            // 5. ×¦×™×•×¨ ×¤×¡×™ ×‘×¨×™××•×ª
            // ×¤×¡ ×‘×¨×™××•×ª ××¨×¡
            drawHealthBar(ares.x - 10, ares.y - 15, ares.w + 20, 8, ares.currentHP, ares.maxHP, '#ff0000');
            // ×¤×¡ ×‘×¨×™××•×ª ×©×—×§×Ÿ
            drawHealthBar(player.x - 10, player.y + player.h + 5, player.w + 20, 8, player.currentHP, player.maxHP, '#00ff00');
            
            // 6. ×¢×“×›×•×Ÿ ××™×“×¢
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `HP ×©×œ×š: <span style="color: green">${player.currentHP}</span> / ${player.maxHP} | HP ×©×œ ××¨×¡: <span style="color: red">${ares.currentHP}</span> / ${ares.maxHP}`;
            }
        }


        // ×˜×¢×™× ×ª ×”××©×—×§ ×¢× ×¤×ª×™×—×ª ×”×“×£ + ×˜×™×¤×•×œ ×‘×©×’×™××•×ª
        window.onload = function() {
            try {
                // ×‘×“×™×§×” ×× ×”-div ×”×¨××©×™ ×§×™×™×
                if (document.getElementById('game-app')) {
                    renderIntro();
                } else {
                    console.error("Game container #game-app not found.");
                }
            } catch (error) {
                // ×–×” ×™×™×ª×¤×¡ ×¨×§ ×× ×”×©×’×™××” ×”×™× ×‘-renderIntro, ×©×’×™××•×ª Parse ×™×™×ª×¤×¡×• ×¢"×™ ×”-Global Error Handler
                console.error("Game failed to initialize during onload:", error);
            }
        };
    </script>
</body>
</html>
