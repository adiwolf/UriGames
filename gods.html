<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>הבלגן האולימפי - קווסט האלים</title>
    <!-- טעינת Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* הגדרות כלליות וגופן */
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #1e3a8a 0%, #064e3b 100%); /* רקע אולימפוס */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .game-container {
            max-width: 600px;
            width: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            text-align: center;
            direction: rtl;
        }
        .quest-title {
            color: #b91c1c; 
            font-size: 1.875rem;
            font-weight: 700;
            margin-bottom: 1rem;
        }
        .quest-description {
            color: #1f2937;
            margin-bottom: 1.5rem;
            line-height: 1.6;
        }
        /* סגנון כפתורי פעולה */
        .action-btn {
            background-color: #059669;
            color: white;
            border-radius: 9999px;
            padding: 0.75rem 2rem;
            font-size: 1.125rem;
            transition: all 0.2s;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .action-btn:hover {
            background-color: #047857;
            transform: translateY(-2px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
        }
        /* סגנון קנבס */
        #gameCanvas {
            border: 4px solid #1f2937;
            background-color: #e5e7eb;
            touch-action: none; /* למניעת גלילה במסך מגע */
        }
        /* סגנון כפתורי שליטה במגע (למובייל) */
        .touch-controls button {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
            transition: background-color 0.1s;
        }
        .touch-controls button:active {
            background-color: #1d4ed8;
        }
        /* סגנון סרגל סטטוס ספציפי להפיסטוס */
        .hephaestus-status {
            padding: 0.5rem;
            margin-top: 1rem;
            border-radius: 8px;
            background-color: #fef3c7; /* צהוב בהיר */
            border: 1px solid #fcd34d;
            font-size: 0.875rem;
            text-align: right;
        }
    </style>
</head>
<body>

    <div id="game-app" class="game-container">
        <!-- תוכן המשחק ייטען לכאן -->
    </div>

    <script>
        // --- מנגנון גלובלי לטיפול בשגיאות קריטיות ---
        window.addEventListener('error', function(e) {
            const appElement = document.getElementById('game-app');
            if (appElement) {
                // הצגת הודעת שגיאה ויזואלית על המסך
                appElement.innerHTML = `
                    <div style="color: #991b1b; padding: 20px; text-align: center; background-color: #fee2e2; border: 2px solid #ef4444; border-radius: 8px;">
                        <h1 style="font-size: 24px; font-weight: bold;">שגיאת טעינה קריטית! 🚨</h1>
                        <p>המשחק נכשל בטעינה. אנא דווח על השגיאה הבאה:</p>
                        <p style="font-family: monospace; background: #fecaca; padding: 10px; border-radius: 4px; margin-top: 10px; overflow-wrap: break-word; color: #7f1d1d;">
                            ${e.message}
                        </p>
                        <p style="margin-top: 10px;">בדוק את קונסולת המפתחים (F12) לפרטים נוספים.</p>
                    </div>
                `;
            }
            // מונע את הטיפול המובנה של הדפדפן בשגיאה
            e.preventDefault(); 
        });

        // הגדרות בסיסיות
        const app = document.getElementById('game-app');
        let gameState = {
            currentQuest: 0,
            score: 0,
            inProgress: false,
        };

        // --- משתני קנבס גלובליים ---
        let canvas = null, ctx = null; // אתחול כ-null למניעת שגיאות מוקדמות
        let canvasState = {}; // מצב המשחק הנוכחי
        let keys = {}; // מעקב אחר מקשים לחוצים
        let gameLoopId = null; // מזהה לולאת המשחק

        // משתני עזר לניקוי מאזיני עכבר ומגע
        let mouseHandlersAdded = false;

        // --- הגדרות קווסטים ---
        const quests = [
            {
                id: 1,
                name: "זאוס: מרוץ הברקים",
                god: "זאוס",
                icon: "⚡🏃",
                description: "זאוס, תוך כדי ניסיון לשפר את יכולותיו ברשתות חברתיות, התעצבן מטרול ושלח סטורם זעם דיגיטלי. הברקים יצאו משליטה! עליך לנווט במהירות בין הברקים הפראיים כדי לנקז את האנרגיה העודפת ולייצב את שמי האולימפוס לפני שהכול יישרף. קושי גבוה! עליך להתחמק מ-15 ברקים! מותרות רק 2 פגיעות. קצב הברקים גדל במהירות.",
                type: "canvas_game",
                gameName: "zeus_dodge",
                target: 15 
            },
            {
                id: 2,
                name: "האדס: איסוף נשמות על סירת סטיקס",
                god: "האדס",
                icon: "👻🛶",
                description: "האדס ערך טורניר פוקר לילי והפסיד בהתערבות את סדר מיון הנשמות. כתוצאה מכך, גיבורים אגדיים (שצריכים ללכת לשדות אליסיום) נכנסים בטעות למסלול של הנשמות הרעות (הגולגלות האדומות). עליך לשלוט בסירה ולהחזיר את נשמות הגיבורים (עיגולים ירוקים) למסלול הנכון, תוך הימנעות מהגולגלות הזועמות! קושי גבוה! אסוף 8 נשמות טובות. הסיכוי להיתקל בגולגלות רעות הוא 50/50. האובייקטים נעים מהר יותר.",
                type: "canvas_game",
                gameName: "hades_collect",
                target: 8 
            },
            {
                id: 3,
                name: "ארטמיס: אתגר ירי החצים",
                god: "ארטמיס",
                icon: "🏹🎯",
                description: "ארטמיס ערכה תחרות קליעה כושלת עם אפולו והשתמשה ביהלומי כוח כמטרות נעות. כמובן שהם פספסו הכל והיהלומים התפזרו בשדה מטאורים מסוכן. עליך לנוע במהירות כדי לאסוף את כל 12 היהלומים לפני שהם מאבדים את האנרגיה שלהם, או שאפולו יכריז על ניצחון מטופש! קושי גבוה! אסוף 12 יהלומים נוצצים בתוך 15 שניות בלבד. הדמות מעט קטנה יותר.",
                type: "canvas_game",
                gameName: "artemis_fetch",
                target: 12 
            },
             {
                id: 4,
                name: "הרמס: בריחה מרשת הלייזר",
                god: "הרמס",
                icon: "🚀⚡",
                description: "הרמס גנב מכונה לבניית שבילים מיידיים מהפיסטוס והפעיל אותה בטעות על מצב 'אבטחה עוינת'. המכונה מזהה אותך כפולש ומפעילה גדרות לייזר אנרגטיות יורדות! **הרמס הפעיל בך קמע מהירות קבוע, כך שאתה מהיר במיוחד לאורך כל המשימה! כל גדר לייזר מכילה שני פערים שדרכם ניתן לעבור.** עליך לנווט במהירות דרך הפערים הצפופים ולהתחמק מ-15 גדרות לייזר כדי להשבית את המכונה. מותרות רק 3 פגיעות! קצב הגדרות הלייזר גדל במהירות.",
                type: "canvas_game",
                gameName: "hermes_avoidance",
                target: 15 
            },
            {
                id: 5,
                name: "אפרודיטה: ניקוי הבלגן הרומנטי",
                god: "אפרודיטה",
                icon: "💖🌹",
                description: "אפרודיטה ניסתה להכין שיקוי אהבה רב עוצמה, אבל נרדמה והחומרים התפזרו ברוח. עליך לנווט במהירות ולאסוף 15 מרכיבים: 8 לבבות ו-7 פרחים. אתה יכול לאסוף רק סוג אחד בכל פעם, והחלפה בין סוגי האיסוף (מקש רווח) לוקחת שנייה יקרה! סיים ב-20 שניות. קושי: גבוה מאוד.",
                type: "canvas_game",
                gameName: "aphrodite_clean",
                target: 15 
            },
            {
                id: 6,
                name: "פוסידון: נחשולי האצות הזועמים",
                god: "פוסידון",
                icon: "🌊🔱",
                description: "פוסידון רב עם דייג על טעם כריך טונה, ושלח צונאמי של אצות שסותם את כל נתיבי הים. עליך לנווט אנכית (למעלה/למטה) במעבר ימי צר כדי להימנע מ-20 גושים של אצות וסלעים שבאים במהירות לרוחב! זהירות: אתה זז רק למעלה ולמטה!",
                type: "canvas_game",
                gameName: "poseidon_dodge",
                target: 20 
            },
             {
                id: 7,
                name: "דיוניסוס: מרתון הברמנים הקוסמי",
                god: "דיוניסוס",
                icon: "🍷⚔️",
                description: "דיוניסוס נטש את היין המסורתי והמציא קוקטייל 'מוחיטו-יווני'. עליך לבשל 3 קוקטיילים ב-25 שניות! אסוף את שלושת המרכיבים (🍇, ☁️, ⚡) וגש למיכל הערבוב (המלבן המרכזי). **חובה לעמוד במיכל למשך 2 שניות** כדי לסיים את הערבוב. **זהירות: האל ארס כועס על השטות ותוקף אותך עם חרבות!** פגיעה מחרב מאפסת את המלאי שלך ומבטלת את הערבוב.",
                type: "canvas_game",
                gameName: "dionysus_cocktail",
                target: 3 
            },
            {
                id: 8,
                name: "הפיסטוס: הרכבת הרובוט המנצח",
                god: "הפיסטוס",
                icon: "⚙️🛠️",
                description: "הפיסטוס שכח את תחרות בניית הרובוטים! עליך להרכיב רובוט מ-4 חלקים: גוף, גלגלים, זרועות וראש. לאחר ההרכבה, הרובוט יצטרך לעבור 3 מכשולים. **זהירות: החיבור הלא נכון יגרום לכשל!** (למשל, גלגלי שטח במירוץ מהירות). הרכב את הרובוט תוך 20 שניות. גרור את החלקים לעיגולים במרכז.",
                type: "canvas_game",
                gameName: "hephaestus_build",
                target: 3 // מספר המכשולים שהרובוט צריך לעבור
            },
            // --- קווסט 9: ארס - דו-קרב הזעם (חדש) ---
            {
                id: 9,
                name: "ארס: דו-קרב הזעם",
                god: "ארס",
                icon: "⚔️🛡️",
                description: "ארס כועס עליך על שעזרת לדיוניסוס! הוא מזמין אותך לדו-קרב בשדה הקרב. עליך להביס את ארס באמצעות ירי חצים אנרגטיים, תוך התחמקות מהתקפות החרב שלו. נצח בדו-קרב כדי לסיים את הבלגן האולימפי!",
                type: "canvas_game",
                gameName: "ares_duel",
                target: 1 // ניצחון אחד
            }
        ];

        // --- פונקציות עזר כלליות ---

        // פונקציה להסרת מאזיני העכבר/מגע
        function removeMouseListeners() {
            if (!canvas || !mouseHandlersAdded) return; 
            // הוסר: canvas.removeEventListener('mousedown', handleMouseDownHephaestus);
            // הוסר: canvas.removeEventListener('mousemove', handleMouseMoveHephaestus);
            // הוסר: canvas.removeEventListener('mouseup', handleMouseUpHephaestus);
            // הוסר: canvas.removeEventListener('touchstart', handleMouseDownHephaestus);
            // הוסר: canvas.removeEventListener('touchmove', handleMouseMoveHephaestus);
            // הוסר: canvas.removeEventListener('touchend', handleMouseUpHephaestus);
            mouseHandlersAdded = false;
        }

        function renderScreen(htmlContent) {
            // ביטול לולאת משחק קודמת לפני רינדור מסך חדש
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            // הסרת מאזינים קודמים למקשים ולעכבר
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            removeMouseListeners(); // הסרת מאזיני ה-DND אם היו

            app.innerHTML = htmlContent;
        }

        function createActionButton(text, onClick) {
            return `
                <button onclick="${onClick}"
                    class="action-btn mt-6 w-full md:w-auto shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-green-300">
                    ${text}
                </button>
            `;
        }
        
        // פונקציה גלובלית לאיפוס קווסט הפיסטוס (משמש בכפתור RESET בתוך הקווסט)
        function resetHephaestusQuest() {
            // זהה ל-resetCurrentQuest אבל שם יותר ברור
             gameState.currentQuest = 8;
             renderQuest();
        }
        

        // --- לוגיקת משחק מרכזית ---

        function renderIntro() {
            gameState.inProgress = false;
            const content = `
                <div class="space-y-6">
                    <h1 class="text-4xl font-bold text-gray-800">ברוכים הבאים ל<span class="text-red-600">הבלגן האולימפי</span></h1>
                    <p class="text-lg text-gray-600">
                        אלי האולימפוס יצרו שיבושים. עליך לשלוט בגיבור באמצעות **מיני-משחקים דינמיים** כדי לתקן את הנזק!
                    </p>
                    <div class="text-xl font-semibold text-blue-700">
                        מטרתך: השלם את כל ${quests.length} הקווסטים המאתגרים!
                    </div>
                    ${createActionButton("התחל מסע", "startQuest()")}
                </div>
            `;
            renderScreen(content);
        }

        function startQuest() {
            gameState.currentQuest = 1;
            gameState.score = 0;
            gameState.inProgress = true;
            renderQuest();
        }

        function renderCompletionScreen() {
            const content = `
                <div class="space-y-6">
                    <h1 class="text-5xl font-extrabold text-green-600">🎉 כל הכבוד! הקווסט הושלם! 🎉</h1>
                    <p class="text-2xl text-gray-700">
                        הצלחת לתקן את כל ${quests.length} השיבושים הקוסמיים!
                    </p>
                    <div class="text-2xl text-red-600 font-bold">
                        ניקוד סופי: ${gameState.score}
                    </div>
                    ${createActionButton("שחק שוב", "renderIntro()")}
                </div>
            `;
            renderScreen(content);
        }

        function handleQuestResult(isCorrect, message, points = 100) {
            // עצירת לולאת משחק ספציפית
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            // הסרת כל המאזינים לפני הצגת תוצאה
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            removeMouseListeners();
            
            let resultHtml;
            // אם זה כישלון, כפתור 'נסה שוב' מפנה ל-resetCurrentQuest
            if (isCorrect) {
                gameState.score += points;
                resultHtml = `
                    <div class="p-4 bg-green-100 border-r-4 border-green-500 text-green-800 mt-6 rounded-lg">
                        <p class="font-bold">✨ הצלחה!</p>
                        <p>${message}</p>
                    </div>
                    ${createActionButton("המשך לקווסט הבא", "nextQuest()")}
                `;
            } else {
                resultHtml = `
                    <div class="p-4 bg-red-100 border-r-4 border-red-500 text-red-800 mt-6 rounded-lg">
                        <p class="font-bold">❌ כישלון...</p>
                        <p>${message}</p>
                    </div>
                    ${createActionButton("נסה שוב", "resetCurrentQuest()")}
                `;
            }
            // עדכון אזור התוצאה
            const questArea = app.querySelector('#quest-area');
            if (questArea) {
                questArea.innerHTML = resultHtml;
            } else {
                 app.querySelector('.game-container').innerHTML += resultHtml;
            }
        }

        function nextQuest() {
            gameState.currentQuest++;
            renderQuest();
        }

        function resetCurrentQuest() {
            renderQuest(); // פשוט רינדור מחדש של הקווסט יאתחל את הכל
        }

        function renderQuest() {
            if (gameState.currentQuest > quests.length) {
                renderCompletionScreen();
                return;
            }

            const quest = quests[gameState.currentQuest - 1];
            let questHtml = '';

            // כותרת כללית
            const header = `
                <div class="text-right mb-4 text-sm font-medium text-gray-500">
                    קווסט ${quest.id} מתוך ${quests.length}
                </div>
                <h2 class="quest-title flex items-center justify-center gap-3">
                    <span class="text-3xl">${quest.icon}</span> ${quest.name}
                </h2>
                <p class="quest-description text-gray-700">${quest.description}</p>
                <div class="h-0.5 bg-gray-200 w-full mb-6"></div>
            `;

            if (quest.type === 'canvas_game') {
                questHtml = renderCanvasGame(quest);
                renderScreen(header + questHtml);
                setupGame(quest.gameName); // רק מכין את הקנבס, לא מתחיל את הלולאה
            }
        }

        // --- לוגיקת מיני-משחקי קנבס ---

        function renderCanvasGame(quest) {
            // בקווסט הפיסטוס אין צורך בלחצני מובייל לכן נסתיר אותם
            const showTouchControls = (quest.gameName !== 'hephaestus_build');
            // בקווסט הפיסטוס אנחנו משתמשים בכפתור לבדיקת הרובוט, ולא ככפתור "התחל"
            const showStartButton = (quest.gameName !== 'hephaestus_build');

            // עדכון הוראות שליטה בהתאם לקווסט הפיסטוס
            const controlInstructions = quest.gameName === 'hephaestus_build' ? 
                'השתמשו במקשי החיצים (← ↑ → ↓) כדי לנווט. לחצו **רווח** כדי לאסוף/לשחרר חלק רובוט.' : 
                'השתמש במקשי החיצים (← ↑ → ↓) כדי לשלוט בדמות. קליק על המקשים למטה עבור מובייל. (מקש רווח לקווסט של אפרודיטה/ארס).';
            
            // כפתור איפוס לקווסט הפיסטוס
            const hephaestusResetButton = quest.gameName === 'hephaestus_build' ? 
                `<button onclick="resetHephaestusQuest()" class="action-btn bg-red-500 hover:bg-red-600 focus:ring-red-300 w-full md:w-auto text-base mt-2">איפוס (RESET)</button>` : '';

            return `
                <div class="flex flex-col items-center space-y-4">
                    <canvas id="gameCanvas" width="350" height="350" 
                        class="border-4 border-gray-900 bg-gray-100 rounded-lg shadow-inner w-full max-w-sm"></canvas>
                    <div id="game-info" class="text-lg font-bold text-red-600">
                        ${quest.gameName === 'hephaestus_build' ? 'בנה את הרובוט שלך!' : 'לחץ \'התחל קווסט\' כדי להתחיל!'}
                    </div>
                    <div id="quest-area">
                        <div class="flex flex-col md:flex-row justify-center gap-4">
                            <button onclick="${quest.gameName === 'hephaestus_build' ? 'checkBuildCompletion()' : `startGameLogic('${quest.gameName}')`}" id="start-game-btn"
                                class="action-btn w-64 h-14 text-xl bg-blue-700 hover:bg-blue-800 focus:ring-blue-300 transition duration-150 transform hover:scale-105"
                                style="display: ${showStartButton ? 'block' : 'none'};">
                                ${showStartButton ? 'התחל קווסט' : 'התחל מירוץ רובוט!'}
                            </button>
                            ${hephaestusResetButton}
                        </div>
                        <p class="text-sm text-gray-500 mt-4">${controlInstructions}</p>
                        <!-- כפתורי שליטה למסכי מגע -->
                        <div class="touch-controls flex justify-center mt-4 space-x-4 ${showTouchControls ? '' : 'hidden'} md:hidden">
                            <button onmousedown="handleTouchMove(0)" ontouchstart="handleTouchMove(0)" ontouchend="handleTouchStop()">←</button>
                            <div class="flex flex-col space-y-2">
                                <button onmousedown="handleTouchMove(1)" ontouchstart="handleTouchMove(1)" ontouchend="handleTouchStop()">↑</button>
                                <button onmousedown="handleTouchMove(3)" ontouchstart="handleTouchMove(3)" ontouchend="handleTouchStop()">↓</button>
                            </div>
                            <button onmousedown="handleTouchMove(2)" ontouchstart="handleTouchMove(2)" ontouchend="handleTouchStop()">→</button>
                            <!-- הוספת כפתור "רווח" למגע לצורך איסוף/שחרור -->
                            <button onmousedown="handleSpacePress()" ontouchstart="handleSpacePress()" ontouchend="handleSpaceRelease()">⚡</button>
                        </div>
                    </div>
                </div>
            `;
        }

        // פונקציות שליטה למסך מגע (לתנועה, לא DND)
        function handleTouchMove(direction) {
            // 0: שמאל, 1: למעלה, 2: ימין, 3: למטה
            keys = { ArrowLeft: false, ArrowUp: false, ArrowRight: false, ArrowDown: false };
            if (direction === 0) keys.ArrowLeft = true;
            if (direction === 1) keys.ArrowUp = true;
            if (direction === 2) keys.ArrowRight = true;
            if (direction === 3) keys.ArrowDown = true;
        }

        function handleTouchStop() {
            keys = {};
        }

        // --- טיפול בלחיצת רווח במגע ---
        function handleSpacePress() {
             keys[' '] = true;
             // עבור קווסט הפיסטוס, הפעלת הלוגיקה באופן מיידי ב-update
             if(gameState.currentQuest === 8) {
                // חייבים לקרוא לעדכון ידני כי אין לולאת משחק ב-BUILD
                // שימו לב: הקוד מתחת מעביר 0 כטיימסטאמפ, זה בסדר כי לוגיקת ה-BUILD לא משתמשת בו
                updateHephaestusBuild(0); 
                keys[' '] = false; // איפוס מיידי לאחר שימוש
             }
        }
        function handleSpaceRelease() {
            // עבור קווסטים כמו אפרודיטה, איפוס המקש יקרה בתוך הלולאה.
             keys[' '] = false; 
        }
        // --- סוף טיפול מגע רווח ---

        function setupGame(gameName) {
            canvas = document.getElementById('gameCanvas');
            // בדיקה קריטית: האם הקנבס נמצא?
            if (!canvas) return; 
            
            ctx = canvas.getContext('2d');
            
            // איפוס מצב מקשים
            keys = {};

            // הסרת והוספת מאזינים
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
            
            // אתחול המשחק הספציפי
            switch (gameName) {
                case 'zeus_dodge':
                    initZeusDodge();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hades_collect':
                    initHadesCollect();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'artemis_fetch':
                    initArtemisFetch();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hermes_avoidance': 
                    initHermesAvoidance();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'aphrodite_clean':
                    initAphroditeClean();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'poseidon_dodge':
                    initPoseidonDodge();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'dionysus_cocktail':
                    initDionysusCocktail();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'hephaestus_build':
                    initHephaestusBuild();
                    // שינוי: הוספת מאזיני מקשים לשליטה בבנייה
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
                case 'ares_duel': // קווסט 9 החדש
                    initAresDuel();
                    document.addEventListener('keydown', handleKeyDown);
                    document.addEventListener('keyup', handleKeyUp);
                    break;
            }
            
            // ציור ראשוני של המסך לפני ההתחלה, רק אם פונקציית ציור קיימת
            if (canvasState.draw) canvasState.draw();
        }

        // --- שינוי: startGameLogic נשאר רק למשחקי לולאה ---
        function startGameLogic(gameName) {
            // מכניס את הלוגיקה של התחלת המשחק (שליטה בכפתור)
            const btn = document.getElementById('start-game-btn');
            const info = document.getElementById('game-info');
            
            if (btn) btn.style.display = 'none';
            if (info) info.textContent = 'המשחק בעיצומו!';

            // הגדרת isRunning ל-true והתחלת הלולאה
            canvasState.isRunning = true;
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function handleKeyDown(e) {
            // מניעת גלילת העמוד בעת שימוש בחצים
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
            }
            keys[e.key] = true;
        }

        function handleKeyUp(e) {
            // עבור קווסט הפיסטוס, לא נאפס כאן את הרווח כדי שהלחיצה תעבוד פעם אחת
            if(e.key === ' ' && gameState.currentQuest === 8) {
                // ניתוק הלחיצה יטופל בתוך ה-updateHephaestusBuild אם צריך
                return; 
            }
            // עבור קווסט ארס, צריך לאפשר ירי חוזר
            if(e.key === ' ' && gameState.currentQuest === 9) {
                return;
            }

            keys[e.key] = false;
        }

        // --- לולאת המשחק הראשית ---
        function gameLoop() {
            if (canvasState.isRunning) {
                // עדכון ולוגיקת משחק
                canvasState.update(performance.now()); // מעביר timestamp
                // ציור
                canvasState.draw();
                // המשך הלולאה
                gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                // המשחק הסתיים (נצחון או הפסד)
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
        }

        // --- עזר: בדיקת התנגשות ריבוע-ריבוע ---
        function checkCollision(r1, r2) {
            // בדיקת התנגשות מלבנים סטנדרטית
            return r1.x < r2.x + r2.w &&
                   r1.x + r1.w > r2.x &&
                   r1.y < r2.y + r2.h &&
                   r1.y + r1.h > r2.y;
        }

        // --- ציור דמות (משותף לזאוס, ארטמיס, אפרודיטה, פוסידון, הרמס, דיוניסוס) ---
        function drawPlayerFigure(player, isBoosted = false) {
            if (!ctx) return; // הגנה
            const centerX = player.x + player.w / 2;
            
            // קביעת צבע הדמות בהתאם למצב החיזוק
            let bodyColor = isBoosted ? '#FFFFFF' : player.color;
            let headColor = isBoosted ? '#FFEA00' : '#FFD700';
            
            // 1. גוף (מלבן שמייצג טוניקה/שריון)
            ctx.fillStyle = bodyColor; 
            ctx.fillRect(player.x + 5, player.y + 10, player.w - 10, player.h - 15);

            // 2. ראש (קסדה מוזהבת)
            ctx.beginPath();
            ctx.arc(centerX, player.y + 7, 7, 0, Math.PI * 2);
            ctx.fillStyle = headColor;
            
            // אפקט זוהר כשהוא מחוזק (לצורך Hermes)
            ctx.shadowColor = isBoosted ? '#FFFFFF' : '#FFD700';
            ctx.shadowBlur = isBoosted ? 15 : 8;
            
            ctx.fill();
            ctx.closePath();
            ctx.shadowBlur = 0; // איפוס צל

            // 3. רגליים (קווים פשוטים)
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - 5, player.y + player.h - 5);
            ctx.lineTo(centerX - 5, player.y + player.h);
            ctx.moveTo(centerX + 5, player.y + player.h - 5);
            ctx.lineTo(centerX + 5, player.y + player.h);
            ctx.stroke();
        }

        // --- קווסט 1: זאוס - מרוץ הברקים ---
        function initZeusDodge() {
            const quest = quests[0];
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#007bff', speed: 4 }, 
                lightning: [],
                strikesDodged: 0,
                hits: 0,
                maxHits: 2, 
                lastSpawn: 0,
                spawnRate: 500, 
                update: updateZeusDodge,
                draw: drawZeusDodge,
            };
        }

        function updateZeusDodge(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // תנועת שחקן
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // יצירת ברקים
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                canvasState.lightning.push({
                    x: Math.random() * (canvas.width - 20) + 10, 
                    y: -10,
                    w: 8, 
                    h: 35,
                    speed: 4 + Math.random() * 2.5, 
                    color: '#FFEA00' 
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(150, canvasState.spawnRate - 15); 
            }

            // עדכון מיקום ברקים ובדיקת התנגשות
            for (let i = canvasState.lightning.length - 1; i >= 0; i--) {
                const bolt = canvasState.lightning[i];
                bolt.y += bolt.speed;

                if (checkCollision(player, bolt)) {
                    // פגיעה
                    canvasState.hits++;
                    canvasState.lightning.splice(i, 1);
                    if (canvasState.hits >= canvasState.maxHits) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `חטפת ${canvasState.hits} פגיעות! זאוס ממלמל משהו על 'משחק הוגן'. נסה שוב.`);
                        return;
                    }
                } else if (bolt.y > canvas.height) {
                    // ברק יצא מהמסך
                    canvasState.strikesDodged++;
                    canvasState.lightning.splice(i, 1);
                    if (canvasState.strikesDodged >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `התחמקת מ-15 ברקים! זאוס חזר לשלוט במזג האוויר. ניקוד: 200`, 200);
                    }
                }
            }
        }

        function drawZeusDodge() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור ברקים
            canvasState.lightning.forEach(bolt => {
                ctx.fillStyle = bolt.color;
                ctx.fillRect(bolt.x, bolt.y, bolt.w, bolt.h);
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `התחמקות: ${canvasState.strikesDodged} / ${quest.target} | פגיעות: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }

        // --- קווסט 2: האדס - איסוף נשמות ---
        function initHadesCollect() {
            const quest = quests[1];
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 17.5, y: canvas.height - 40, w: 35, h: 18, color: '#3b82f6', speed: 4.5 }, 
                collectibles: [], 
                obstacles: [], 
                soulsCollected: 0,
                badSoulsHit: 0,
                maxBadSouls: 3,
                lastSpawn: 0,
                spawnRate: 650, 
                update: updateHadesCollect,
                draw: drawHadesCollect,
            };
        }

        function updateHadesCollect(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // תנועת שחקן
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;

            // יצירת אובייקטים
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const x = Math.random() * (canvas.width - 20);
                const isCollectible = Math.random() > 0.5; 
                const item = { x, y: -20, r: 10, speed: 2.5 + Math.random() * 2 }; 

                if (isCollectible) {
                    canvasState.collectibles.push({ ...item, w: item.r*2, h: item.r*2, color: '#10b981' }); 
                } else {
                    canvasState.obstacles.push({ ...item, w: item.r*2, h: item.r*2, color: '#ef4444' }); 
                }

                canvasState.lastSpawn = timestamp;
            }

            // עדכון ואיסוף
            for (let i = canvasState.collectibles.length - 1; i >= 0; i--) {
                const item = canvasState.collectibles[i];
                item.y += item.speed;

                // בדיקת איסוף 
                if (checkCollision(player, item)) {
                    canvasState.soulsCollected++;
                    canvasState.collectibles.splice(i, 1);
                    if (canvasState.soulsCollected >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `אספת 8 נשמות טובות! האדס משבח את סדרנותך. ניקוד: 300`, 300);
                        return;
                    }
                } else if (item.y > canvas.height) {
                    canvasState.collectibles.splice(i, 1);
                }
            }

            // עדכון והימנעות
            for (let i = canvasState.obstacles.length - 1; i >= 0; i--) {
                const item = canvasState.obstacles[i];
                item.y += item.speed;

                // בדיקת פגיעה
                 if (checkCollision(player, item)) {
                    canvasState.badSoulsHit++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.badSoulsHit >= canvasState.maxBadSouls) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `פגעת ב-3 גולגלות! סירת סטיקס נשברה. נסה שוב.`);
                        return;
                    }
                } else if (item.y > canvas.height) {
                    canvasState.obstacles.splice(i, 1);
                }
            }
        }

        function drawHadesCollect() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור נשמות טובות (עיגולים ירוקים)
            canvasState.collectibles.forEach(item => {
                ctx.beginPath();
                ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
                ctx.fillStyle = item.color;
                ctx.fill();
                ctx.closePath();
            });

            // ציור גולגלות רעות (ריבועים אדומים)
            canvasState.obstacles.forEach(item => {
                ctx.fillStyle = item.color;
                // ציור כריבוע במקום עיגול כדי לייצג גולגולת
                ctx.fillRect(item.x - item.r, item.y - item.r, item.r * 2, item.r * 2);
            });

            // ציור שחקן (סירה) - צורה מעוצבת
            const player = canvasState.player;
            ctx.fillStyle = '#78350f'; // חום כהה (סירת עץ)
            
            // גוף הסירה (טרפז הפוך)
            ctx.beginPath();
            ctx.moveTo(player.x, player.y + player.h); // קצה שמאלי תחתון
            ctx.lineTo(player.x + player.w, player.y + player.h); // קצה ימני תחתון
            ctx.lineTo(player.x + player.w - 5, player.y); // קצה ימני עליון (חרטום)
            ctx.lineTo(player.x + 5, player.y); // קצה שמאלי עליון (חרטום)
            ctx.closePath();
            ctx.fill();

            // פס דקורטיבי כחול (הנהר)
            ctx.fillStyle = '#3b82f6';
            ctx.fillRect(player.x + 2, player.y + player.h - 5, player.w - 4, 3);
            
            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `נשמות: ${canvasState.soulsCollected} / ${quest.target} | גולגלות: <span style="color: red">${canvasState.badSoulsHit}</span> / ${canvasState.maxBadSouls}`;
            }
        }

        // --- קווסט 3: ארטמיס - אתגר ירי החצים (איסוף בזמן) ---
        function initArtemisFetch() {
            const quest = quests[2];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 12, y: canvas.height / 2 - 12, w: 24, h: 24, color: '#f59e0b', speed: 4.5 }, 
                gems: [],
                gemsCollected: 0,
                totalTime: 15, 
                timeRemaining: 15,
                lastTick: Date.now(),
                update: updateArtemisFetch,
                draw: drawArtemisFetch,
            };

            // יצירת 12 יהלומים
            for(let i = 0; i < quest.target; i++) {
                 canvasState.gems.push({
                    x: Math.random() * (canvas.width - 30) + 15, 
                    y: Math.random() * (canvas.height - 30) + 15, 
                    w: 15,
                    h: 15,
                    color: '#ffffff', 
                    r: 7.5
                });
            }
        }

        function updateArtemisFetch() {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // עדכון טיימר
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // תנועת שחקן
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // בדיקת גבולות (הרוחות המבלבלות - מחזיר את השחקן)
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;


            // בדיקת איסוף יהלומים
            for (let i = canvasState.gems.length - 1; i >= 0; i--) {
                const gem = canvasState.gems[i];
                // בדיקת התנגשות (היהלומים נבדקים כריבועים לצורך collision)
                if (checkCollision(player, {x: gem.x - gem.r, y: gem.y - gem.r, w: gem.w, h: gem.h})) {
                    canvasState.gemsCollected++;
                    canvasState.gems.splice(i, 1);
                    if (canvasState.gemsCollected >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `אספת את כל 12 היהלומים בזמן! ארטמיס מרוצה מהדיוק שלך. ניקוד: 500`, 500);
                        return;
                    }
                }
            }

            // בדיקת זמן
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `הזמן נגמר! לא הספקת לאסוף את כל היהלומים. נסה שוב.`);
            }
        }

        function drawArtemisFetch() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור יהלומים (מעוינים)
            canvasState.gems.forEach(gem => {
                ctx.fillStyle = gem.color;
                ctx.shadowColor = '#000000';
                ctx.shadowBlur = 5;
                const r = gem.r;
                const x = gem.x;
                const y = gem.y;


                // ציור מעוין
                ctx.beginPath();
                ctx.moveTo(x, y - r); // Top point
                ctx.lineTo(x + r, y); // Right point
                ctx.lineTo(x, y + r); // Bottom point
                ctx.lineTo(x - r, y); // Left point
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0; // איפוס צל
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                info.innerHTML = `יהלומים: ${canvasState.gemsCollected} / ${quest.target} | זמן: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span> שניות`;
            }
        }

        // --- קווסט 4: הרמס - בריחה מרשת הלייזר (Laser Grid Avoidance) ---
        function initHermesAvoidance() {
            const permanentFastSpeed = 9; // המהירות המהירה הקבועה
            canvasState = {
                isRunning: false,
                // הדמות מתחילה במהירות הגבוהה (9)
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#f59e0b', speed: permanentFastSpeed }, 
                walls: [], // הקירות המכילים פערים (Laser Gates)
                wallsDodged: 0, // תיקון השם
                hits: 0,
                maxHits: 3, 
                lastSpawn: 0,
                spawnRate: 1000, 
                lastTick: Date.now(), // הוספת lastTick לחישוב elapsed
                update: updateHermesAvoidance,
                draw: drawHermesAvoidance,
            };
        }

        function updateHermesAvoidance(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;

            // תנועת שחקן
            const moveStep = player.speed * elapsed * 60 * 0.1; // מבוסס על מהירות 9
            
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;


            // יצירת קירות (עם שני פערים)
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const gapWidth = 60 + Math.random() * 20; 
                const minGapDistance = 50; 
                const wallHeight = 15;
                
                // חישוב מיקום שני הפערים (gap1Start < gap2Start)
                const totalSpaceNeeded = 2 * gapWidth + minGapDistance;
                const availableStartSpace = canvas.width - totalSpaceNeeded;

                // מיקום התחלה של הפער הראשון
                let gap1Start = Math.random() * (availableStartSpace);

                // מיקום התחלה של הפער השני
                let gap2Start = gap1Start + gapWidth + minGapDistance + Math.random() * (canvas.width - (gap1Start + gapWidth + minGapDistance) - gapWidth);
                
                // ודא ש-gap2Start לא חורג מהקצה
                gap2Start = Math.min(gap2Start, canvas.width - gapWidth - 5);


                canvasState.walls.push({
                    y: -wallHeight,
                    gap1Start: gap1Start,
                    gap1End: gap1Start + gapWidth,
                    gap2Start: gap2Start,
                    gap2End: gap2Start + gapWidth,
                    h: wallHeight,
                    speed: 4.5 + Math.random() * 2.5,
                    color: '#ef4444', // אדום לייזר
                    passed: false, // האם השחקן עבר מתחתיו (חשוב לספירה)
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(700, canvasState.spawnRate - 30); // קצב עולה
            }

            // עדכון מיקום קירות ובדיקת התנגשות
            for (let i = canvasState.walls.length - 1; i >= 0; i--) {
                const wall = canvasState.walls[i];
                // עדכון מיקום הקיר
                wall.y += wall.speed;

                // בדיקת התנגשות (שחקן נתקע בקיר)
                // בודקים אם יש חפיפה אנכית בין השחקן לקיר
                if (player.y + player.h > wall.y && player.y < wall.y + wall.h) {
                    
                    let collision = false;
                    
                    // בדיקה מול 3 מקטעי לייזר:
                    
                    // 1. Segment 1 (Left): 0 to gap1Start
                    if (player.x < wall.gap1Start) {
                        collision = true;
                    }
                    
                    // 2. Segment 2 (Middle): gap1End to gap2Start
                    // התנגשות מתרחשת אם הדמות נכנסת לאזור האמצעי
                    if (player.x + player.w > wall.gap1End && player.x < wall.gap2Start) {
                       collision = true;
                    }
                    
                    // 3. Segment 3 (Right): gap2End to canvas.width
                    if (player.x + player.w > wall.gap2End) {
                        collision = true;
                    }
                    
                    if (collision) {
                        // יש התנגשות: חוטפים פגיעה
                        canvasState.hits++;
                        canvasState.walls.splice(i, 1); 
                        
                        if (canvasState.hits >= canvasState.maxHits) {
                            canvasState.isRunning = false;
                            handleQuestResult(false, `נתקעת יותר מדי! המכונה של הרמס השתגעה. נסה שוב.`);
                            return;
                        }
                        continue;
                    }
                }

                // בדיקת יציאה מהמסך (והצלחה)
                if (wall.y > player.y + player.h && !wall.passed) { // שינוי: אם הקיר עבר את גובה השחקן (למטה)
                    wall.passed = true;
                    canvasState.wallsDodged++;

                    if (canvasState.wallsDodged >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `התחמקת מ-15 גדרות לייזר! הרמס קיבל את המכונה שלו בחזרה. ניקוד: 400`, 400);
                        return;
                    }
                }
                
                // ניקוי קירות שיצאו מהמסך
                if (wall.y > canvas.height) {
                    canvasState.walls.splice(i, 1);
                }
            }
        }

        function drawHermesAvoidance() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור קירות לייזר (Laser Gates)
            canvasState.walls.forEach(wall => {
                ctx.fillStyle = wall.color;
                ctx.shadowColor = wall.color;
                ctx.shadowBlur = 10;
                
                // קיר שמאלי (Segment 1: 0 to gap1Start)
                ctx.fillRect(0, wall.y, wall.gap1Start, wall.h);
                
                // קיר אמצעי (Segment 2: gap1End to gap2Start)
                ctx.fillRect(wall.gap1End, wall.y, wall.gap2Start - wall.gap1End, wall.h);

                // קיר ימני (Segment 3: gap2End to canvas.width)
                ctx.fillRect(wall.gap2End, wall.y, canvas.width - wall.gap2End, wall.h);
                
                ctx.shadowBlur = 0;
                
                // --- ציור המכשולים הגלויים (למעלה) ---
                ctx.fillStyle = 'white';
                ctx.font = '10px Inter';
                ctx.textAlign = 'left';
                // ציור קצוות הפערים
                ctx.fillText(`פער (${wall.gap1End.toFixed(0)})`, wall.gap1Start, wall.y - 5);
                ctx.fillText(`פער (${wall.gap2End.toFixed(0)})`, wall.gap2Start, wall.y - 5);
                

            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `התחמקות: ${canvasState.wallsDodged} / ${quest.target} | פגיעות: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }


        // --- קווסט 5: אפרודיטה - ניקוי הבלגן הרומנטי ---

        const ITEM_TYPE = { HEART: 'heart', FLOWER: 'flower' };
        
        function initAphroditeClean() {
            const quest = quests[4];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 15, y: canvas.height / 2 - 15, w: 30, h: 30, color: '#ec4899', speed: 4 }, 
                items: [],
                collectedCount: { heart: 0, flower: 0 },
                totalCollected: 0,
                collectingType: ITEM_TYPE.HEART, // מתחיל עם לבבות
                lastTypeSwitch: 0,
                typeSwitchCooldown: 1000, // קושי: 1 שנייה קירור
                totalTime: 20, 
                timeRemaining: 20,
                lastTick: Date.now(),
                update: updateAphroditeClean,
                draw: drawAphroditeClean,
            };

            // יצירת 8 לבבות ו-7 פרחים (סה"כ 15)
            const targets = { heart: 8, flower: 7 };
            // FIX: הוספת ה-type לכל פריט בעת יצירתו
            for(let type in targets) {
                for(let i = 0; i < targets[type]; i++) {
                    canvasState.items.push({
                        x: Math.random() * (canvas.width - 30) + 15, 
                        y: Math.random() * (canvas.height - 30) + 15, 
                        w: 15,
                        h: 15,
                        type: type, // *** הוספת סוג הפריט ***
                        r: 7.5
                    });
                }
            }
        }

        function updateAphroditeClean() {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();

            // עדכון טיימר
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // תנועת שחקן
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // בדיקת גבולות
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;

            // החלפת סוג איסוף (רווח - Space)
            const isOnCooldown = now - canvasState.lastTypeSwitch < canvasState.typeSwitchCooldown;
            if (keys[' '] && !isOnCooldown) {
                canvasState.collectingType = canvasState.collectingType === ITEM_TYPE.HEART ? ITEM_TYPE.FLOWER : ITEM_TYPE.HEART;
                canvasState.lastTypeSwitch = now;
                keys[' '] = false; // למנוע החלפה מיידית נוספת
            }

            // בדיקת איסוף
            for (let i = canvasState.items.length - 1; i >= 0; i--) {
                const item = canvasState.items[i];
                if (checkCollision(player, {x: item.x - item.r, y: item.y - item.r, w: item.w, h: item.h})) {
                    // FIX: כעת ה-item.type קיים וניתן לבדוק אותו
                    if (item.type === canvasState.collectingType) {
                        // איסוף מוצלח
                        canvasState.collectedCount[item.type]++;
                        canvasState.totalCollected++;
                        canvasState.items.splice(i, 1);
                        if (canvasState.totalCollected >= quest.target) {
                            canvasState.isRunning = false;
                            handleQuestResult(true, `אספת את כל ${quest.target} המרכיבים בזמן! אפרודיטה יכולה להשלים את שיקוי האהבה. ניקוד: 600`, 600);
                            return;
                        }
                    } else {
                        // פגיעה בפריט הלא נכון - אין קנס, פשוט לא אוספים
                    }
                }
            }

            // בדיקת זמן
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `הזמן נגמר! לא אספת את כל ${quest.target} המרכיבים. נסה שוב.`);
            }
        }

        function drawAphroditeClean() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const now = Date.now();

            // ציור פריטים
            canvasState.items.forEach(item => {
                ctx.shadowBlur = 5;
                if (item.type === ITEM_TYPE.HEART) {
                    // ציור לב (Heart - פונקציית ציור פשוטה)
                    ctx.fillStyle = '#f87171';
                    ctx.shadowColor = '#f87171';
                    const h_x = item.x;
                    const h_y = item.y;
                    const r = item.r;
                    
                    ctx.beginPath();
                    // שימוש בצורה גיאומטרית פשוטה יותר לבטיחות
                    ctx.moveTo(h_x, h_y + r); 
                    ctx.lineTo(h_x + r, h_y - r);
                    ctx.lineTo(h_x + r / 2, h_y - r * 2);
                    ctx.lineTo(h_x, h_y - r * 1.5);
                    ctx.lineTo(h_x - r / 2, h_y - r * 2);
                    ctx.lineTo(h_x - r, h_y - r);
                    ctx.closePath();
                    ctx.fill();

                } else { // ITEM_TYPE.FLOWER
                    // ציור פרח (Flower - עיגול + עלי כותרת פשוטים)
                    ctx.fillStyle = '#818cf8';
                    ctx.shadowColor = '#818cf8';
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.closePath();
                }
                ctx.shadowBlur = 0;
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // הדגשת מצב איסוף נוכחי
            const statusColor = canvasState.collectingType === ITEM_TYPE.HEART ? '#f87171' : '#818cf8';
            ctx.fillStyle = statusColor;
            ctx.globalAlpha = 0.2;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalAlpha = 1.0;

            const isOnCooldown = now - canvasState.lastTypeSwitch < canvasState.typeSwitchCooldown;
            const cooldownText = isOnCooldown ? ` (ממתין ${((canvasState.typeSwitchCooldown - (now - canvasState.lastTypeSwitch) + 100) / 1000).toFixed(1)} שנ')` : '';

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                info.innerHTML = `אסוף: <span style="color: ${statusColor}; font-weight: bold">${canvasState.collectingType === ITEM_TYPE.HEART ? 'לבבות' : 'פרחים'}</span>${cooldownText} | סה"כ: ${canvasState.totalCollected} / ${quest.target} | זמן: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span>`;
            }
        }

        // --- קווסט 6: פוסידון - נחשולי האצות הזועמים ---
        function initPoseidonDodge() {
            const quest = quests[5];
            canvasState = {
                isRunning: false, 
                player: { x: 30, y: canvas.height / 2 - 15, w: 30, h: 30, color: '#10b981', speed: 4.5 }, // הדמות נמצאת בצד שמאל
                obstacles: [], // גושי אצות וסלעים
                dodgedCount: 0,
                hits: 0,
                maxHits: 2, 
                lastSpawn: 0,
                spawnRate: 400, // קושי: קצב גבוה
                update: updatePoseidonDodge,
                draw: drawPoseidonDodge,
            };
        }

        function updatePoseidonDodge(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;

            // תנועת שחקן - רק למעלה ולמטה
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // יצירת אובייקטים
            if (timestamp - canvasState.lastSpawn > canvasState.spawnRate) {
                const y = Math.random() * (canvas.height - 20) + 10;
                const h = 15 + Math.random() * 25; // גובה משתנה
                const w = 15 + Math.random() * 20; // רוחב משתנה
                
                canvasState.obstacles.push({
                    x: canvas.width, 
                    y: y - h / 2,
                    w: w, 
                    h: h,
                    speed: 4 + Math.random() * 3, // קושי: מהירות גבוהה
                    color: Math.random() < 0.3 ? '#4b5563' : '#059669' // אצות או סלע אפור
                });
                canvasState.lastSpawn = timestamp;
                canvasState.spawnRate = Math.max(100, canvasState.spawnRate - 5); // קושי: קצב הופעה גדל
            }

            // עדכון מיקום מכשולים ובדיקת התנגשות
            for (let i = canvasState.obstacles.length - 1; i >= 0; i--) {
                const obstacle = canvasState.obstacles[i];
                obstacle.x -= obstacle.speed;

                if (checkCollision(player, obstacle)) {
                    // פגיעה
                    canvasState.hits++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.hits >= canvasState.maxHits) {
                        canvasState.isRunning = false;
                        handleQuestResult(false, `פוסידון חסם את נתיב המים! חטפת ${canvasState.hits} פגיעות. נסה שוב.`);
                        return;
                    }
                } else if (obstacle.x + obstacle.w < 0) {
                    // מכשול יצא מהמסך
                    canvasState.dodgedCount++;
                    canvasState.obstacles.splice(i, 1);
                    if (canvasState.dodgedCount >= quest.target) {
                        canvasState.isRunning = false;
                        handleQuestResult(true, `התחמקת מ-20 גושים! פוסידון הרגיע את הים. ניקוד: 700`, 700);
                    }
                }
            }
        }

        function drawPoseidonDodge() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ציור מכשולים
            canvasState.obstacles.forEach(obstacle => {
                ctx.fillStyle = obstacle.color;
                ctx.fillRect(obstacle.x, obstacle.y, obstacle.w, obstacle.h);
            });

            // ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `התחמקות: ${canvasState.dodgedCount} / ${quest.target} | פגיעות: <span style="color: red">${canvasState.hits}</span> / ${canvasState.maxHits}`;
            }
        }

        // --- קווסט 7: דיוניסוס - מרתון הברמנים הקוסמי (Overcooked Style) ---

        const INGREDIENTS = { GRAPE: 'GRAPE', CLOUD: 'CLOUD', LIGHTNING: 'LIGHTNING' };
        
        function initDionysusCocktail() {
            const quest = quests[6];
            canvasState = {
                isRunning: false, 
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#9d174d', speed: 4.5 }, 
                items: [], // מרכיבים פזורים
                required: { GRAPE: 1, CLOUD: 1, LIGHTNING: 1 },
                inventory: { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 },
                cocktailsMade: 0,
                totalTime: 25, 
                timeRemaining: 25,
                lastTick: Date.now(),
                lastSpawn: 0,
                
                // --- לוגיקת סדר הופעה חדשה ---
                spawnInterval: 1000, // 1 שניה בין סוג מרכיב לסוג
                spawnSequence: [INGREDIENTS.GRAPE, INGREDIENTS.LIGHTNING, INGREDIENTS.CLOUD],
                sequenceIndex: 0,

                // --- לוגיקת בישול חדשה ---
                isMixing: false,
                mixingStartTime: 0,
                mixTimeRequired: 2000, // 2 שניות
                
                // --- לוגיקת ארס חדשה ---
                aresAttacks: [], // חרבות של ארס
                lastAresSpawn: 0,
                aresSpawnRate: 1800, // חרב כל 1.8 שניות
                aresSpeed: 4,

                update: updateDionysusCocktail,
                draw: drawDionysusCocktail,
            };
            
            // הגדרת זמן ההופעה הראשונית (מיד אחרי ההתחלה)
            canvasState.lastSpawn = Date.now();
        }
        
        // פונקציה ליצירת מרכיב ספציפי
        function spawnIngredient(type) { 
            // בדיקה שסוג המרכיב תקין
            if (!Object.values(INGREDIENTS).includes(type)) return;

            canvasState.items.push({
                x: Math.random() * (canvas.width - 30) + 15, 
                y: Math.random() * (canvas.height - 30) + 15, 
                w: 20, h: 20, 
                type: type,
                r: 10
            });
        }

        function spawnAresAttack(timestamp) {
            // חרב זזה אופקית (מימין לשמאל או משמאל לימין)
            const isLeftToRight = Math.random() < 0.5;
            const y = Math.random() * (canvas.height - 30) + 15;
            const speed = canvasState.aresSpeed + Math.random() * 1.5;

            canvasState.aresAttacks.push({
                x: isLeftToRight ? -20 : canvas.width,
                y: y,
                w: 30, h: 8, // רוחב וגובה של החרב
                speed: isLeftToRight ? speed : -speed,
                color: '#b91c1c', // אדום של ארס
                isLeftToRight: isLeftToRight,
            });
            canvasState.lastAresSpawn = timestamp;
            canvasState.aresSpawnRate = Math.max(1000, canvasState.aresSpawnRate - 50); // מגביר קצב
        }


        function updateDionysusCocktail(timestamp) {
            const quest = quests[gameState.currentQuest - 1];
            const player = canvasState.player;
            const now = Date.now();

            // עדכון טיימר
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            canvasState.timeRemaining = Math.max(0, canvasState.timeRemaining - elapsed);
            
            // תנועת שחקן
            if (keys['ArrowLeft']) player.x -= player.speed;
            if (keys['ArrowRight']) player.x += player.speed;
            if (keys['ArrowUp']) player.y -= player.speed;
            if (keys['ArrowDown']) player.y += player.speed;

            // בדיקת גבולות
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;
            if (player.y < 0) player.y = 0;
            if (player.y > canvas.height - player.h) player.y = canvas.height - player.h;

            // יצירת מרכיבים חדשים לפי סדר קבוע וזמנים (Spawn)
            if (now - canvasState.lastSpawn > canvasState.spawnInterval && canvasState.items.length < 12) {
                
                // 1. קביעת סוג המרכיב הנוכחי לפי האינדקס
                const typeToSpawn = canvasState.spawnSequence[canvasState.sequenceIndex];

                // 2. יצירת המרכיב
                spawnIngredient(typeToSpawn);
                
                // 3. עדכון זמן
                canvasState.lastSpawn = now;

                // 4. קידום לאינדקס הבא (מחזור)
                canvasState.sequenceIndex = (canvasState.sequenceIndex + 1) % canvasState.spawnSequence.length;
            }

            // יצירת התקפת ארס
            if (timestamp - canvasState.lastAresSpawn > canvasState.aresSpawnRate) {
                spawnAresAttack(timestamp);
            }

            // --- לוגיקת התקפות ארס ---
            for (let i = canvasState.aresAttacks.length - 1; i >= 0; i--) {
                const sword = canvasState.aresAttacks[i];
                sword.x += sword.speed;

                if (checkCollision(player, sword)) {
                    // פגיעה מארס: איפוס מלאי וביטול בישול
                    canvasState.inventory = { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 };
                    canvasState.isMixing = false;
                    canvasState.mixingStartTime = 0;
                    canvasState.aresAttacks.splice(i, 1);
                    break; // break מהלולאה הנוכחית (לולאת aresAttacks)
                } else if (sword.x > canvas.width || sword.x + sword.w < 0) {
                    canvasState.aresAttacks.splice(i, 1);
                }
            }


            // בדיקת איסוף
            for (let i = canvasState.items.length - 1; i >= 0; i--) {
                const item = canvasState.items[i];
                if (checkCollision(player, item)) {
                    canvasState.inventory[item.type]++;
                    canvasState.items.splice(i, 1);
                    break; // break מהלולאה הנוכחית (לולאת items)
                }
            }
            
            // בדיקת מיקסר
            const mixer = { x: canvas.width/2 - 50, y: 10, w: 100, h: 50 }; 
            const isCollidingWithMixer = checkCollision(player, mixer);
            
            const hasAllIngredients = 
                canvasState.inventory.GRAPE >= canvasState.required.GRAPE &&
                canvasState.inventory.CLOUD >= canvasState.required.CLOUD &&
                canvasState.inventory.LIGHTNING >= canvasState.required.LIGHTNING;
            
            // לוגיקת בישול
            if (isCollidingWithMixer && hasAllIngredients) {
                if (!canvasState.isMixing) {
                    // התחלת בישול
                    canvasState.isMixing = true;
                    canvasState.mixingStartTime = now;
                } else {
                    // בדיקת סיום בישול
                    if (now - canvasState.mixingStartTime >= canvasState.mixTimeRequired) {
                        // בישול מוצלח!
                        canvasState.cocktailsMade++;
                        canvasState.inventory = { GRAPE: 0, CLOUD: 0, LIGHTNING: 0 }; // איפוס מלאי
                        canvasState.isMixing = false;
                        canvasState.mixingStartTime = 0;

                        if (canvasState.cocktailsMade >= quest.target) {
                            canvasState.isRunning = false;
                            handleQuestResult(true, `הכנת 3 קוקטיילים! דיוניסוס חוזר ליין הרגיל. ניקוד: 800`, 800);
                            return;
                        }
                    }
                }
            } else {
                // אם יצאת מהמיקסר או איבדת מרכיבים, הערבוב מתבטל
                if (canvasState.isMixing) {
                    canvasState.isMixing = false;
                    canvasState.mixingStartTime = 0;
                }
            }
            
            // בדיקת זמן
            if (canvasState.timeRemaining <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `הזמן נגמר! לא הספקת להכין את כל 3 הקוקטיילים. נסה שוב.`);
            }
        }

        function drawDionysusCocktail() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const now = Date.now();
            
            // 1. ציור מיכל הערבוב (Mixer)
            const mixer = { x: canvas.width/2 - 50, y: 10, w: 100, h: 50 };
            ctx.fillStyle = '#6d28d9'; // סגול עמוק ליין
            ctx.fillRect(mixer.x, mixer.y, mixer.w, mixer.h);
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 3;
            ctx.strokeRect(mixer.x, mixer.y, mixer.w, mixer.h);
            
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText("ערבוב (Mix)", canvas.width / 2, 40);
            
            // 1.1. ציור סרגל התקדמות בישול
            if (canvasState.isMixing) {
                const progress = (now - canvasState.mixingStartTime) / canvasState.mixTimeRequired;
                const barWidth = mixer.w * progress;
                ctx.fillStyle = '#FFD700'; // צהוב זהב להתקדמות
                ctx.fillRect(mixer.x, mixer.y + mixer.h - 5, barWidth, 5);
            }


            // 2. ציור מרכיבים
            canvasState.items.forEach(item => {
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                // ציור באמצעות אימוג'י
                if (item.type === INGREDIENTS.GRAPE) {
                    ctx.fillText('🍇', item.x, item.y + 15);
                } else if (item.type === INGREDIENTS.CLOUD) {
                    ctx.fillText('☁️', item.x, item.y + 15);
                } else if (item.type === INGREDIENTS.LIGHTNING) {
                    ctx.fillText('⚡', item.x, item.y + 15);
                }
            });
            
            // 3. ציור התקפות ארס (חרבות)
            canvasState.aresAttacks.forEach(sword => {
                ctx.fillStyle = sword.color;
                ctx.shadowColor = sword.color;
                ctx.shadowBlur = 10;
                
                // ציור להב
                ctx.fillRect(sword.x, sword.y, sword.w, sword.h);
                // ציור ידית (קטנה)
                ctx.fillStyle = '#78350f';
                ctx.fillRect(sword.x + sword.w, sword.y + 2, 5, 4);

                ctx.shadowBlur = 0;
            });


            // 4. ציור שחקן (דמות)
            drawPlayerFigure(canvasState.player);

            // 5. עדכון מידע ומלאי (Inventory)
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                const timeColor = canvasState.timeRemaining < 5 ? 'red' : 'green';
                let mixingStatus = '';
                if (canvasState.isMixing) {
                    const timeLeft = canvasState.mixTimeRequired - (now - canvasState.mixingStartTime);
                    mixingStatus = ` | מערבב... <span class="text-yellow-600">${(timeLeft / 1000).toFixed(1)}</span> שנ'`;
                }
                
                info.innerHTML = `
                    <div style="direction:rtl; display: flex; justify-content: space-between; width: 100%;">
                        <span>קוקטיילים: <span class="text-green-600">${canvasState.cocktailsMade}</span> / ${quest.target}${mixingStatus}</span>
                        <span>זמן: <span style="color: ${timeColor}">${canvasState.timeRemaining.toFixed(1)}</span> שנ'</span>
                    </div>
                    <div class="mt-2 text-sm text-gray-700 font-normal">
                        מלאי: 🍇:${canvasState.inventory.GRAPE} / ☁️:${canvasState.inventory.CLOUD} / ⚡:${canvasState.inventory.LIGHTNING}
                    </div>
                `;
            }
        }


        // =========================================================
        // --- קווסט 8: הפיסטוס - הרכבת הרובוט המנצח ---
        // =========================================================

        const ROBOT_PARTS = { 
            HEAD: 'HEAD', 
            BODY: 'BODY', 
            ARM: 'ARM', 
            WHEEL: 'WHEEL' 
        };
        
        // 1. פרטי החלקים (מאפיינים שונים)
        const PART_VARIANTS = [
            // גופים (Body)
            { id: 1, type: ROBOT_PARTS.BODY, name: "גוף מרוץ (קל)", emoji: '🟥', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 3, type: ROBOT_PARTS.BODY, name: "גוף גמיש (מאוזן)", emoji: '🟩', stats: { speed: 3, weight: 3, balance: 5 } },

            // גלגלים (Wheel)
            { id: 4, type: ROBOT_PARTS.WHEEL, name: "גלגלי ספיד", emoji: '🚀', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 6, type: ROBOT_PARTS.WHEEL, name: "גלגלי אחיזה (מאוזן)", emoji: '🛡️', stats: { speed: 3, weight: 3, balance: 5 } },
            
            // זרועות (Arm)
            { id: 7, type: ROBOT_PARTS.ARM, name: "זרועות כוח", emoji: '💪', stats: { speed: 1, weight: 5, balance: 2 } },
            { id: 9, type: ROBOT_PARTS.ARM, name: "זרועות כלי עבודה (מאוזן)", emoji: '🛠️', stats: { speed: 3, weight: 3, balance: 5 } },

            // ראשים (Head)
            { id: 10, type: ROBOT_PARTS.HEAD, name: "ראש חיישן", emoji: '💡', stats: { speed: 5, weight: 1, balance: 2 } },
            { id: 12, type: ROBOT_PARTS.HEAD, name: "ראש פיקוד (מאוזן)", emoji: '⚙️', stats: { speed: 3, weight: 3, balance: 5 } },
        ].filter(p => p.id !== 2 && p.id !== 5 && p.id !== 8 && p.id !== 11); // סינון כדי להשאיר 8 חלקים, 2 מכל סוג

        
        // 2. הגדרת מיקומי הרכבה קבועים
        // יש להשתמש במיקומים קבועים כדי לחשב את ההחזרה של החלק למאגר
        const INITIAL_PART_POSITIONS = {}; 
        PART_VARIANTS.forEach((p, index) => {
            // התאמת המיקום לאחר הקיצוץ (4 שורות, 2 עמודות)
            INITIAL_PART_POSITIONS[p.id] = { 
                x: 280 + (index % 2) * 40, // 280, 320
                y: 70 + Math.floor(index / 2) * 55 // 70, 125, 180, 235
            };
        });

        const BUILD_SLOTS = {
            [ROBOT_PARTS.HEAD]: { x: 175, y: 50, radius: 20, assignedPart: null },
            [ROBOT_PARTS.BODY]: { x: 175, y: 120, radius: 25, assignedPart: null },
            [ROBOT_PARTS.ARM]: { x: 175, y: 190, radius: 20, assignedPart: null },
            [ROBOT_PARTS.WHEEL]: { x: 175, y: 260, radius: 25, assignedPart: null },
        };

        // 3. הגדרת מכשולים במסלול (עם דרישות גלויות)
        const OBSTACLES = [
            // --- דרישות חדשות ---
            // מהירות: הורד ל-11.5
            { type: 'SPEED_CHALLENGE', name: "מכשול 1: מנהרת מהירות", requiredStat: 'speed', threshold: 11.5, failMessage: "הרובוט שלך היה איטי מדי במנהרת המהירות!" },
            // כוח: הורד ל-9.5
            { type: 'FORCE_CHALLENGE', name: "מכשול 2: קיר הריסות כבד", requiredStat: 'weight', threshold: 9.5, failMessage: "הרובוט לא היה חזק מספיק כדי לשבור את קיר ההריסות!" },
            // איזון: הורד ל-12
            { type: 'PRECISION_CHALLENGE', name: "מכשול 3: גשר כבלים דק", requiredStat: 'balance', threshold: 12, failMessage: "הרובוט איבד יציבות על גשר הכבלים ונפל!" },
        ];
        
        // 4. הגדרת רובוטים מתחרים
        // רובוט 1 (מהירות/מרוץ) - ינצח את רוב מכשולי המהירות, ייכשל באיזון
        const RIVAL_RACE = {
            name: "רובוט מרוץ (אדום)", emoji: '🏎️', color: '#b91c1c', 
            stats: { speed: 18, weight: 6, balance: 8 }, // 3 מהירים, 1 מאוזן
            progress: 0, passed: 0, isFinished: false, isWinner: false, robotY: 100 // מיקום במסלול
        };
        // רובוט 2 (כוח/הריסות) - ינצח את מכשולי הכוח, ייכשל במהירות
        const RIVAL_POWER = {
            name: "רובוט כוח (כחול)", emoji: '🧱', color: '#1d4ed8', 
            stats: { speed: 8, weight: 18, balance: 8 }, // 3 כוח, 1 מאוזן
            progress: 0, passed: 0, isFinished: false, isWinner: false, robotY: 200 // מיקום במסלול
        };


        function initHephaestusBuild() {
            const quest = quests[7]; // קווסט 8
            
            // יצירת עותק של החלקים והצבתם במיקום ההתחלתי הקבוע
            let currentParts = JSON.parse(JSON.stringify(PART_VARIANTS));
            currentParts.forEach((p) => {
                const pos = INITIAL_PART_POSITIONS[p.id];
                p.x = pos.x; 
                p.y = pos.y;
                p.w = 30; 
                p.h = 30;
                p.isHeld = false; // מצב חדש: האם השחקן מחזיק את החלק
            });

            // איפוס סלוטים
            for (const key in BUILD_SLOTS) {
                BUILD_SLOTS[key].assignedPart = null;
            }

            canvasState = {
                isRunning: false, 
                phase: 'BUILD', // 'BUILD' | 'TEST'
                
                lastTick: Date.now(),
                
                // BUILD PHASE
                partsPool: currentParts,
                buildSlots: BUILD_SLOTS,
                
                player: { x: 50, y: canvas.height / 2, w: 30, h: 30, color: '#f59e0b', speed: 4 }, // דמות הגיבור
                heldPart: null, // החלק שהשחקן מחזיק
                
                // TEST PHASE
                playerRobot: null, // הרובוט של השחקן
                rivals: [
                    JSON.parse(JSON.stringify(RIVAL_RACE)), 
                    JSON.parse(JSON.stringify(RIVAL_POWER))
                ],
                obstacles: OBSTACLES, 
                obstaclesPassed: 0,
                robotProgress: 0, 
                robotX: 0, 
                robotY: canvas.height / 2 - 20, 
                robotW: 40, 
                robotH: 40,
                robotSpeed: 2, 
                testStartTime: 0,
                testRunning: false,
                
                update: updateHephaestusBuild,
                draw: drawHephaestusBuild,
            };

            // התחל לולאה מיד כדי לאפשר תנועה בשלב BUILD
            canvasState.isRunning = true; 
            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            gameLoopId = requestAnimationFrame(gameLoop);
            
            // עדכון המידע הראשוני
            const info = document.getElementById('game-info');
            if (info) info.innerHTML = "נווט עם החצים, אסוף/שחרר חלקים עם **רווח**.";
            
            // הסתרת כפתור הבדיקה עד להשלמת ההרכבה
            const btn = document.getElementById('start-game-btn');
            if (btn) btn.style.display = 'none';
            // וודא שכפתור האיפוס מוצג
            const resetButton = document.querySelector('button[onclick="resetHephaestusQuest()"]');
            if (resetButton) resetButton.style.display = 'block';

        }
        
        // --- פונקציה גלובלית לבדיקת השלמה והתחלת מירוץ ---
        function checkBuildCompletion() {
            const btn = document.getElementById('start-game-btn');
            const info = document.getElementById('game-info');
            
            // 1. בדוק אם כל הסלוטים מלאים
            const allSlotsFilled = Object.values(canvasState.buildSlots).every(slot => slot.assignedPart !== null);
            
            if (allSlotsFilled) {
                // 2. חשב את נתוני הרובוט הסופיים של השחקן
                const stats = { speed: 0, weight: 0, balance: 0, totalScore: 0 };
                Object.values(canvasState.buildSlots).forEach(slot => {
                    stats.speed += slot.assignedPart.stats.speed;
                    stats.weight += slot.assignedPart.stats.weight;
                    stats.balance += slot.assignedPart.stats.balance;
                });

                // הגדרת הרובוט של השחקן (ממצב ה-BUILD)
                canvasState.playerRobot = {
                    name: "הרובוט שלך", emoji: '🤖', color: '#059669', 
                    stats: stats,
                    progress: 0, passed: 0, isFinished: false, isWinner: false, 
                    robotY: 300 // מיקום במסלול
                };

                // 3. הגדר את מצב הרובוט לטסט
                canvasState.phase = 'TEST';
                canvasState.testRunning = false; 
                canvasState.obstaclesPassed = 0;
                
                // איפוס מיקומי רובוטים מתחרים
                canvasState.rivals.forEach(r => {
                    r.progress = 0; r.passed = 0; r.isFinished = false; r.isWinner = false;
                });
                
                // 4. הצג כפתור והוראות
                if (btn) {
                    btn.textContent = "התחל מירוץ רובוט!";
                    btn.onclick = () => {
                        // התחלת המירוץ: משנה את הסטטוס לריצה ומאפשר ל-updateTest לזוז
                        canvasState.testRunning = true; 
                        // לוודא שהלולאה אכן רצה
                        if (!canvasState.isRunning) {
                            canvasState.isRunning = true;
                            gameLoopId = requestAnimationFrame(gameLoop);
                        }
                        btn.style.display = 'none'; // הסתר כפתור
                        // הסתרת כפתור האיפוס ברגע שהמירוץ מתחיל
                        const resetButton = document.querySelector('button[onclick="resetHephaestusQuest()"]');
                        if (resetButton) resetButton.style.display = 'none';

                    };
                    btn.style.display = 'block';
                }

                // עדכון מידע עם סטטיסטיקות
                if (info) info.innerHTML = `הרכבה הושלמה! הרובוט מוכן למבחן. <br> **מהירות: ${stats.speed} | כוח: ${stats.weight} | איזון: ${stats.balance}**`;
                
                // עצור את תנועת הגיבור (שלב BUILD)
                canvasState.isRunning = false; 
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
                canvasState.draw(); // ציור פריים אחד סטטי של מצב המירוץ לפני ההתחלה
            } else {
                if (btn) btn.style.display = 'none';
                if (info) info.innerHTML = "נווט עם החצים, אסוף/שחרר חלקים עם **רווח**. חסרים חלקים.";
            }
        }
        
        
        function handleBuildInput() {
            const player = canvasState.player;
            
            // בדיקה אם נלחץ מקש רווח (Space)
            if (keys[' ']) {
                
                if (canvasState.heldPart) {
                    // --- שלב 2: שחרור חלק ---
                    
                    let dropped = false;
                    
                    // בודק התנגשות מול סלוטים פנויים
                    for (const key in canvasState.buildSlots) {
                        const slot = canvasState.buildSlots[key];
                        
                        // בדיקת התנגשות (מרכז השחקן מול מרכז הסלוט)
                        const distance = Math.sqrt(
                            Math.pow((player.x + player.w/2) - slot.x, 2) + 
                            Math.pow((player.y + player.h/2) - slot.y, 2)
                        );
                        
                        // אם קרוב מספיק לסלוט ואין בו חלק
                        if (distance < slot.radius + 15 && !slot.assignedPart) { 
                            slot.assignedPart = canvasState.heldPart;
                            canvasState.heldPart.isHeld = false;
                            
                            // מיקום החלק בסלוט לצורך ציור
                            canvasState.heldPart.x = slot.x;
                            canvasState.heldPart.y = slot.y;

                            canvasState.heldPart = null;
                            dropped = true;
                            break;
                        }
                    }
                    
                    // אם שוחרר בהצלחה, בודקים השלמה ומציירים מחדש
                    if (dropped) {
                        // בדיקה האם כל הסלוטים מלאים לאחר השחרור
                        const allFilled = Object.values(canvasState.buildSlots).every(slot => slot.assignedPart !== null);
                        if(allFilled) {
                            checkBuildCompletion(); // אם הושלם, מעבר לטסט
                        } else {
                            canvasState.draw();
                        }
                    } else {
                        // אם לא שוחרר בסלוט, מחזירים אותו למאגר (כדי שיהיה אפשר לאסוף אותו שוב)
                         canvasState.heldPart.isHeld = false;
                         const originalPos = INITIAL_PART_POSITIONS[canvasState.heldPart.id];
                         canvasState.heldPart.x = originalPos.x;
                         canvasState.heldPart.y = originalPos.y;
                         canvasState.heldPart = null;
                         canvasState.draw();
                    }
                    
                } else {
                    // --- שלב 1: איסוף חלק ---
                    
                    // בודק התנגשות מול חלקים פנויים במאגר
                    for (let i = canvasState.partsPool.length - 1; i >= 0; i--) {
                        const part = canvasState.partsPool[i];
                        
                        // רק אם החלק לא מוחזק ולא מורכב
                        if (!part.isHeld && 
                            !Object.values(canvasState.buildSlots).some(s => s.assignedPart === part) &&
                            checkCollision(player, part)) {
                            
                            canvasState.heldPart = part;
                            part.isHeld = true;
                            canvasState.draw();
                            break;
                        }
                    }
                }
                
                keys[' '] = false; // איפוס רווח כדי שלא יפעל רצוף
            }
        }

        // פונקציית עזר לבדיקת מכשול עבור רובוט (שחקן או יריב)
        function checkRobotObstacle(robot, currentObstacleIndex) {
             const obstacle = canvasState.obstacles[currentObstacleIndex];
             // שימוש בציון האיזון המקורי ככפול 4
             const scoreToCheck = obstacle.requiredStat === 'balance' ? robot.stats.balance * 4 : robot.stats[obstacle.requiredStat];

             if (scoreToCheck < obstacle.threshold) {
                 return { passed: false, message: `${robot.name} נכשל ב${obstacle.name}. (נדרש ${obstacle.threshold}, קיבל ${scoreToCheck.toFixed(1)})` };
             } else {
                 // רק מעביר את המכשול (עדכון passed נעשה בלולאה)
                 return { passed: true, message: null };
             }
        }


        function updateHephaestusBuild(timestamp) {
            const now = Date.now();
            const elapsed = (now - canvasState.lastTick) / 1000;
            canvasState.lastTick = now;
            const player = canvasState.player;
            // הרובוט שלך הוא תמיד הראשון ברשימה
            const allRobots = [canvasState.playerRobot, ...canvasState.rivals];


            if (canvasState.phase === 'BUILD') {
                // 1. תנועת שחקן
                const speed = player.speed * elapsed * 60;
                if (keys['ArrowLeft'] && player.x > 0) player.x -= speed;
                if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += speed;
                if (keys['ArrowUp'] && player.y > 0) player.y -= speed;
                if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += speed;

                // 2. עדכון מיקום החלק המוחזק (צמוד לדמות)
                if (canvasState.heldPart) {
                    canvasState.heldPart.x = player.x + player.w / 2;
                    canvasState.heldPart.y = player.y - 10;
                }

                // 3. לוגיקת איסוף/שחרור
                handleBuildInput();

            } else if (canvasState.phase === 'TEST' && canvasState.testRunning) {
                
                let winnerFound = false;
                let firstFinisher = null;
                
                // --- עדכון כל הרובוטים ---
                for (const robot of allRobots) {
                    if (robot && !robot.isFinished) {
                        
                        // 1. תנועת הרובוט
                        // קבוע מהירות: 1.0 לכולם, כדי שהסטטיסטיקה תחליט מי מהיר יותר
                        const speedFactor = 1.0; 
                        const baseSpeed = robot.stats.speed / 100; 
                        robot.progress += baseSpeed * elapsed * 60 * speedFactor; 

                        // 2. בדיקת מכשול נוכחי
                        const currentObstacleIndex = robot.passed;
                        
                        if (currentObstacleIndex < canvasState.obstacles.length) {
                             const obstacle = canvasState.obstacles[currentObstacleIndex];
                             const obstacleX = 100 + currentObstacleIndex * 100; // מיקום המכשול

                             // בדיקת הגעה למכשול (טווח קטן לפני המכשול)
                             if (robot.progress + canvasState.robotW >= obstacleX && robot.progress < obstacleX + 10) {
                                 
                                 const result = checkRobotObstacle(robot, currentObstacleIndex);
                                 
                                 if (result.passed) {
                                     // עבר! קדם למכשול הבא
                                     robot.passed++;
                                 } else {
                                     // נכשל!
                                     robot.isFinished = true;
                                     robot.color = '#78350f'; // צבע חום לרובוט שנכשל
                                     
                                     // אם הרובוט של השחקן נכשל, עצור את המשחק
                                     if (robot === canvasState.playerRobot) {
                                        canvasState.testRunning = false;
                                        canvasState.isRunning = false;
                                        // שינוי: מעבר מיידי חזרה ל-BUILD
                                        handleQuestResult(false, result.message); 
                                        return; 
                                     }
                                 }
                             }
                        } else if (robot.progress > canvas.width) {
                            // 3. הרובוט סיים את המסלול
                            robot.isFinished = true;
                            if (!firstFinisher) {
                                firstFinisher = robot; // שמור את הרובוט הראשון שסיים
                            }
                            winnerFound = true; // סימן שיש מי שסיים
                        }
                    }
                }
                
                // --- בדיקת מנצח סופית (רק אם מישהו סיים) ---
                if (winnerFound) {
                    // הכרזת מנצח על פי מי שסיים ראשון (firstFinisher)
                    if (firstFinisher) {
                        firstFinisher.isWinner = true;
                        
                        if (firstFinisher === canvasState.playerRobot) {
                            handleQuestResult(true, `ניצחון! הרובוט שלך הוא המנצח האולימפי!`, 900);
                        } else {
                            handleQuestResult(false, `הרובוט שלך הפסיד! המנצח הוא ${firstFinisher.name}. נסה לבנות רובוט טוב יותר.`);
                        }
                    }
                    
                    canvasState.testRunning = false;
                    canvasState.isRunning = false;
                }
            }
        }

        // פונקציה ציור של הרובוט
        function drawRobot(robot) {
            if (!ctx) return;
            
            // ציור מסלול ייחודי לכל רובוט (מעט צל כדי שייראה כמו מסילה)
            const trackY = robot.robotY + canvasState.robotH / 2;
            ctx.fillStyle = '#cccccc'; 
            ctx.globalAlpha = 0.5;
            ctx.fillRect(0, trackY - 1, canvas.width, 2);
            ctx.globalAlpha = 1.0;
            
            
            // --- ציור המכשול הדינמי ---
            const currentObstacleIndex = robot.passed;
            if (currentObstacleIndex < canvasState.obstacles.length) {
                const obstacle = canvasState.obstacles[currentObstacleIndex];
                const obstacleX = 100 + currentObstacleIndex * 100;
                
                // אם הרובוט נמצא בתוך טווח המכשול
                if (robot.progress > obstacleX - 30 && robot.progress < obstacleX + 50) {
                    
                    ctx.globalAlpha = 0.2;
                    if (obstacle.type === 'SPEED_CHALLENGE') {
                        // מנהרת רוח (אדום)
                        ctx.fillStyle = '#f87171'; 
                    } else if (obstacle.type === 'FORCE_CHALLENGE') {
                        // קיר הריסות (אפור/כחול)
                         ctx.fillStyle = '#3b82f6';
                    } else if (obstacle.type === 'PRECISION_CHALLENGE') {
                         // רעידות (ירוק)
                         ctx.fillStyle = '#10b981'; 
                    }
                     // ציור אפקט דינמי רק על המסלול שלו
                    ctx.fillRect(obstacleX - 30, trackY - 15, 80, 30);
                    ctx.globalAlpha = 1.0;
                }
            }

            // ציור רובוט כריבוע (לצורך התנגשות)
            ctx.fillStyle = robot.color;
            ctx.fillRect(robot.progress, robot.robotY, canvasState.robotW, canvasState.robotH);
            
            // ציור אימוג'י בתוך הריבוע
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(robot.emoji, robot.progress + canvasState.robotW / 2, robot.robotY + 30);
            
            // ציור שם הרובוט
            ctx.fillStyle = '#1f2937';
            ctx.font = '10px Inter';
            ctx.fillText(robot.name, robot.progress + canvasState.robotW / 2, robot.robotY - 5);

            // סימון סטטוס (אם נכשל)
            if (robot.isFinished && !robot.isWinner) {
                 ctx.fillStyle = '#b91c1c';
                 ctx.font = '20px Arial';
                 ctx.fillText('❌', robot.progress + canvasState.robotW / 2, robot.robotY + 20);
            }
             // סימון ויזואלי של מי עבר את המכשול
             if (robot.passed > 0) {
                 ctx.fillStyle = '#059669';
                 ctx.font = '15px Arial';
                 ctx.fillText(`${robot.passed} / 3`, robot.progress + canvasState.robotW / 2, robot.robotY + 48);
             }
        }

        function drawHephaestusBuild() {
            if (!ctx) return;
            const quest = quests[gameState.currentQuest - 1];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const info = document.getElementById('game-info');
            
            // שלב BUILD
            if (canvasState.phase === 'BUILD') {
                const player = canvasState.player;

                // --- ציור שלב ההרכבה ---
                
                // קו הפרדה בין אזור הרכבה לאזור חלקי חילוף
                ctx.strokeStyle = '#9ca3af'; 
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(canvas.width / 2 + 30, 0);
                ctx.lineTo(canvas.width / 2 + 30, canvas.height);
                ctx.stroke();

                // 1. ציור סלוטים (מקומות הרכבה)
                ctx.textAlign = 'center';
                for (const key in canvasState.buildSlots) {
                    const slot = canvasState.buildSlots[key];
                    ctx.beginPath();
                    ctx.arc(slot.x, slot.y, slot.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.fillStyle = slot.assignedPart ? '#059669' : '#9ca3af';
                    ctx.font = '10px Inter';
                    
                    // כיתוב סלוט
                    let text;
                    if (key === ROBOT_PARTS.HEAD) text = "ראש (HEAD)";
                    else if (key === ROBOT_PARTS.BODY) text = "גוף (BODY)";
                    else if (key === ROBOT_PARTS.ARM) text = "זרועות (ARM)";
                    else if (key === ROBOT_PARTS.WHEEL) text = "גלגלים (WHEEL)";
                    
                    ctx.fillText(text, slot.x, slot.y + slot.radius + 15);
                    
                    // ציור החלק שהוצמד לסלוט
                    if (slot.assignedPart) {
                        ctx.font = '25px Arial';
                        ctx.fillText(slot.assignedPart.emoji, slot.x, slot.y + 10);
                    }
                }

                // 2. ציור מאגר החלקים (ימין)
                ctx.fillStyle = '#1f2937';
                ctx.font = '12px Inter';
                ctx.textAlign = 'right';
                ctx.fillText("מאגר חלקים:", canvas.width - 20, 30);
                
                // לולאה על כל החלקים
                canvasState.partsPool.forEach(part => {
                    // ציור רק אם החלק לא מוחזק על ידי השחקן ואין לו סלוט
                    let isAssignedToSlot = Object.values(canvasState.buildSlots).some(s => s.assignedPart === part);

                    if (!part.isHeld && !isAssignedToSlot) {
                         // רקע קטן לחלק
                        ctx.fillStyle = '#fcd34d';
                        ctx.fillRect(part.x - part.w/2, part.y - part.h/2, part.w, part.h);
                        
                        // ציור האימוג'י
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(part.emoji, part.x, part.y + 7);

                        // כיתוב מתחת לאימוג'י
                        ctx.font = '10px Inter';
                        ctx.fillStyle = '#1f2937';
                        ctx.fillText(part.name, part.x, part.y + 25);
                    }
                });

                // 3. ציור החלק המוחזק
                if(canvasState.heldPart) {
                    const part = canvasState.heldPart;
                    // רקע לחלק המוחזק
                    ctx.fillStyle = '#f87171'; // צבע אדום להדגשה
                    ctx.fillRect(part.x - part.w/2, part.y - part.h/2, part.w, part.h);
                    
                    // ציור האימוג'י
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(part.emoji, part.x, part.y + 7);

                    // ציור כיתוב קטן
                    ctx.font = '10px Inter';
                    ctx.fillStyle = '#1f2937';
                    ctx.fillText(part.name, part.x, part.y + 25);
                }

                // 4. ציור הדמות השולטת
                drawPlayerFigure(player, canvasState.heldPart !== null);

            } 
            
            // שלב TEST (מירוץ מול יריבים)
            else if (canvasState.phase === 'TEST') {
                // --- ציור שלב המירוץ ---
                ctx.textAlign = 'center';
                
                // 1. ציור קו הבסיס (הרצפה) - נמתח לרוחב המסך
                ctx.strokeStyle = '#1f2937';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, canvas.height - 40);
                ctx.lineTo(canvas.width, canvas.height - 40);
                ctx.stroke();

                // 2. ציור מכשולים
                ctx.lineWidth = 3;
                canvasState.obstacles.forEach((obstacle, index) => {
                    const obstacleX = 100 + index * 100;
                    
                    // צבע אפור לפני ההגעה, אדום בזמן המכשול
                    let lineColor = '#9ca3af'; 
                    // נבדוק את מצב הרובוט של השחקן לצורך הדגשת המכשול הנוכחי
                    if (canvasState.playerRobot && index === canvasState.playerRobot.passed) {
                        lineColor = '#b91c1c'; // אדום: כעת המבחן
                        ctx.fillStyle = '#fef3c7'; // צהוב בהיר
                        // ציור מלבן המכשול כמעבר ויזואלי
                        ctx.fillRect(obstacleX, 0, 5, canvas.height); // קו מכשול אנכי
                        
                    } else if (canvasState.playerRobot && index < canvasState.playerRobot.passed) {
                        lineColor = '#059669'; // ירוק אחרי מעבר
                    }
                    
                    ctx.strokeStyle = lineColor; 
                    
                    // ציור סימן המכשול (קו)
                    ctx.beginPath();
                    ctx.moveTo(obstacleX, 0);
                    ctx.lineTo(obstacleX, canvas.height - 40);
                    ctx.stroke();
                    
                    // כיתוב
                    ctx.fillStyle = '#1f2937';
                    ctx.font = '12px Inter';
                    // הצגת דרישת הסף בכיתוב המכשול
                    ctx.fillText(`${obstacle.name}`, obstacleX, 20);
                    ctx.fillText(`(דרישה: ${obstacle.threshold})`, obstacleX, 35); // הצגת דרישה

                    // סימון הצלחה
                    if (canvasState.playerRobot && index < canvasState.obstacles.length && canvasState.playerRobot.passed > index) {
                        ctx.fillStyle = '#059669';
                        ctx.font = '20px Arial';
                        ctx.fillText('✅', obstacleX, canvas.height - 20);
                    }
                });

                // 3. ציור הרובוטים
                // רובוט מרוץ
                drawRobot(canvasState.rivals[0]);
                // רובוט כוח
                drawRobot(canvasState.rivals[1]);
                // הרובוט של השחקן (תמיד אחרון כדי להיות ב-TOP)
                if (canvasState.playerRobot) drawRobot(canvasState.playerRobot);
                
                // 4. עדכון מידע
                if (info && canvasState.playerRobot) {
                    const playerStats = canvasState.playerRobot.stats;
                    
                    info.innerHTML = `
                        <div class="text-xs text-gray-700">
                             🤖 שלך: מהירות: ${playerStats.speed} | כוח: ${playerStats.weight} | **איזון: ${playerStats.balance}**
                        </div>
                        <div class="text-lg font-bold mt-1">
                            שלב נוכחי: <span class="text-blue-600">${canvasState.playerRobot.passed + 1} / ${quest.target}</span>
                        </div>
                    `;
                }
            }
        }

        // --- פונקציית עזר לציור פסי בריאות ---
        function drawHealthBar(x, y, width, height, current, max, color) {
            if (!ctx) return;
            const percent = current / max;
            
            // רקע אפור
            ctx.fillStyle = '#666666';
            ctx.fillRect(x, y, width, height);
            
            // פס בריאות
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width * percent, height);
            
            // מסגרת
            ctx.strokeStyle = '#333333';
            ctx.strokeRect(x, y, width, height);
        }
        
        // --- ציור דמות ארס מותאמת אישית (כמו הגיבור, אבל עם שריון) ---
        function drawAresFigure(ares) {
            if (!ctx) return;
            const x = ares.x;
            const y = ares.y;
            const w = ares.w; // 50
            const h = ares.h; // 50
            const centerX = x + w / 2;
            
            const bodyW = 20; // רוחב גוף צר
            const bodyH = 30; // גובה גוף

            // 1. גוף (מלבן שמייצג שריון כבד) - צבע אדום כהה
            ctx.fillStyle = ares.color; // #b91c1c (אדום של ארס)
            // מיקום מחדש כדי שהגוף יהיה צר יותר במרכז
            ctx.fillRect(centerX - bodyW / 2, y + h * 0.2, bodyW, bodyH); 

            // 2. ראש (בסיס קסדה)
            ctx.beginPath();
            ctx.arc(centerX, y + 7, 7, 0, Math.PI * 2);
            ctx.fillStyle = '#555555'; // אפור כהה/מתכת
            ctx.fill();
            ctx.closePath();
            
            // 3. מגן פנים/מצח (זהב)
            ctx.fillStyle = '#FFD700'; 
            ctx.beginPath();
            ctx.moveTo(centerX - 8, y + 7);
            ctx.lineTo(centerX + 8, y + 7);
            ctx.lineTo(centerX, y - 5);
            ctx.closePath();
            ctx.fill();

            // 4. ציצית/כרבולת אדומה (Crest) - גבוהה ודרמטית
            ctx.beginPath();
            ctx.moveTo(centerX, y - 5);
            ctx.lineTo(centerX + 3, y - 15);
            ctx.lineTo(centerX - 3, y - 15);
            ctx.closePath();
            ctx.fillStyle = '#ff0000'; // אדום זוהר
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 10;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // 5. רגליים (קווים פשוטים)
            ctx.strokeStyle = '#333333';
            ctx.lineWidth = 2;
            // מזיז את הרגליים כדי שיתאימו לגוף הצר
            ctx.beginPath();
            ctx.moveTo(centerX - 5, y + h - 5);
            ctx.lineTo(centerX - 5, y + h);
            ctx.moveTo(centerX + 5, y + h - 5);
            ctx.lineTo(centerX + 5, y + h);
            ctx.stroke();
        }

        // --- קווסט 9: ארס - דו-קרב הזעם ---
        function initAresDuel() {
            const quest = quests[8]; // Quest ID 9 (index 8)
            canvasState = {
                isRunning: false,
                player: { x: canvas.width / 2 - 15, y: canvas.height - 40, w: 30, h: 30, color: '#f59e0b', speed: 4.5, maxHP: 100, currentHP: 100 }, 
                // שינוי: ארס מתחיל במיקום ספציפי
                ares: { x: canvas.width / 2 - 25, y: 50, w: 50, h: 50, color: '#b91c1c', maxHP: 150, currentHP: 150, speed: 1.5, lastShot: 0, shootRate: 1500 }, 
                playerProjectiles: [],
                aresProjectiles: [],
                lastPlayerShot: 0,
                playerShootCooldown: 300, // 300ms cooldown for player shooting (Spacebar)
                update: updateAresDuel,
                draw: drawAresDuel,
            };
        }

        function updateAresDuel(timestamp) {
            const player = canvasState.player;
            const ares = canvasState.ares;

            // 1. תנועת שחקן (Arrows)
            if (keys['ArrowLeft'] && player.x > 0) player.x -= player.speed;
            if (keys['ArrowRight'] && player.x < canvas.width - player.w) player.x += player.speed;
            if (keys['ArrowUp'] && player.y > 0) player.y -= player.speed;
            if (keys['ArrowDown'] && player.y < canvas.height - player.h) player.y += player.speed;

            // 2. ירי שחקן (Spacebar)
            if (keys[' '] && timestamp - canvasState.lastPlayerShot > canvasState.playerShootCooldown) {
                // יצירת קליע של השחקן
                canvasState.playerProjectiles.push({
                    x: player.x + player.w / 2 - 2, 
                    y: player.y,
                    w: 4, h: 10, speed: 7, damage: 10, color: '#FFD700', type: 'arrow'
                });
                canvasState.lastPlayerShot = timestamp;
                // אין איפוס רווח כאן, כפתור הרווח מטופל ב-handleKeyUp
            }
            
            // 3. תנועה ומתקפה של ארס
            // תנועה: תנועה אופקית פשוטה
            ares.x += ares.speed;
            if (ares.x > canvas.width - ares.w || ares.x < 0) {
                ares.speed *= -1;
            }

            // ירי ארס (מזמן)
            if (timestamp - ares.lastShot > ares.shootRate) {
                // יצירת קליע של ארס (חנית מכוונת)
                const dx = (player.x + player.w / 2) - (ares.x + ares.w / 2);
                const dy = (player.y + player.h / 2) - (ares.y + ares.h / 2);
                const angle = Math.atan2(dy, dx);
                
                canvasState.aresProjectiles.push({
                    x: ares.x + ares.w / 2 - 5, 
                    y: ares.y + ares.h,
                    w: 10, h: 10, speed: 4, damage: 20, color: '#b91c1c',
                    speedX: Math.cos(angle) * 4,
                    speedY: Math.sin(angle) * 4
                });
                ares.lastShot = timestamp;
                // הגברת קצב ירי
                ares.shootRate = Math.max(800, ares.shootRate - 2);
            }


            // 4. עדכון קליעי שחקן ובדיקת התנגשות מול ארס
            for (let i = canvasState.playerProjectiles.length - 1; i >= 0; i--) {
                const proj = canvasState.playerProjectiles[i];
                proj.y -= proj.speed;

                if (checkCollision(proj, ares)) {
                    ares.currentHP = Math.max(0, ares.currentHP - proj.damage);
                    canvasState.playerProjectiles.splice(i, 1);
                } else if (proj.y < -10) {
                    canvasState.playerProjectiles.splice(i, 1);
                }
            }

            // 5. עדכון קליעי ארס ובדיקת התנגשות מול שחקן
            for (let i = canvasState.aresProjectiles.length - 1; i >= 0; i--) {
                const proj = canvasState.aresProjectiles[i];
                proj.x += proj.speedX;
                proj.y += proj.speedY;

                if (checkCollision(proj, player)) {
                    player.currentHP = Math.max(0, player.currentHP - proj.damage);
                    canvasState.aresProjectiles.splice(i, 1);
                } else if (proj.y < -10 || proj.y > canvas.height + 10 || proj.x < -10 || proj.x > canvas.width + 10) {
                    canvasState.aresProjectiles.splice(i, 1);
                }
            }
            
            // 6. בדיקת תנאי ניצחון/הפסד
            if (ares.currentHP <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(true, `הבסת את ארס בדו-קרב! הזעם שלו נרגע והבלגן האולימפי הסתיים.`, 1200);
            } else if (player.currentHP <= 0) {
                canvasState.isRunning = false;
                handleQuestResult(false, `ארס הביס אותך בדו-קרב. נסה שוב לחמש את עצמך!`);
            }
        }

        function drawAresDuel() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const player = canvasState.player;
            const ares = canvasState.ares;

            // 1. ציור קליעי ארס (חניתות אנרגיה)
            canvasState.aresProjectiles.forEach(proj => {
                 ctx.fillStyle = proj.color; // אדום
                 ctx.shadowColor = proj.color;
                 ctx.shadowBlur = 10;
                 ctx.fillRect(proj.x, proj.y, proj.w, proj.h);
                 
                 // ציור חץ או קצה חנית
                 ctx.fillStyle = '#FFD700';
                 ctx.fillRect(proj.x + proj.w / 2 - 2, proj.y, 4, 15);

                 ctx.shadowBlur = 0;
            });

            // 2. ציור קליעי שחקן (אנרגיה)
            canvasState.playerProjectiles.forEach(proj => {
                 ctx.fillStyle = proj.color; // צהוב
                 ctx.shadowColor = proj.color;
                 ctx.shadowBlur = 8;
                 ctx.fillRect(proj.x, proj.y, proj.w, proj.h);
                 ctx.shadowBlur = 0;
            });

            // 3. ציור ארס (אויב)
            drawAresFigure(ares);

            // 4. ציור שחקן (דמות)
            drawPlayerFigure(player);

            // 5. ציור פסי בריאות
            // פס בריאות ארס
            drawHealthBar(ares.x - 10, ares.y - 15, ares.w + 20, 8, ares.currentHP, ares.maxHP, '#ff0000');
            // פס בריאות שחקן
            drawHealthBar(player.x - 10, player.y + player.h + 5, player.w + 20, 8, player.currentHP, player.maxHP, '#00ff00');
            
            // 6. עדכון מידע
            const info = document.getElementById('game-info');
            if (canvasState.isRunning && info) {
                info.innerHTML = `HP שלך: <span style="color: green">${player.currentHP}</span> / ${player.maxHP} | HP של ארס: <span style="color: red">${ares.currentHP}</span> / ${ares.maxHP}`;
            }
        }


        // טעינת המשחק עם פתיחת הדף + טיפול בשגיאות
        window.onload = function() {
            try {
                // בדיקה אם ה-div הראשי קיים
                if (document.getElementById('game-app')) {
                    renderIntro();
                } else {
                    console.error("Game container #game-app not found.");
                }
            } catch (error) {
                // זה ייתפס רק אם השגיאה היא ב-renderIntro, שגיאות Parse ייתפסו ע"י ה-Global Error Handler
                console.error("Game failed to initialize during onload:", error);
            }
        };
    </script>
</body>
</html>
