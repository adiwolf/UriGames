<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>מלחמת חלל</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #000310;
            border: 2px solid #38b6ff;
            box-shadow: 0 0 25px #38b6ff, inset 0 0 15px rgba(56, 182, 255, 0.5);
            cursor: pointer;
        }
        #instructionsBtn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(56, 182, 255, 0.7);
            color: white;
            border: 2px solid white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10;
            transition: background-color 0.3s;
        }
        #instructionsBtn:hover {
            background-color: rgba(56, 182, 255, 1);
        }
        .controls {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 25px;
            border-radius: 10px;
            border: 1px solid #38b6ff;
            box-shadow: 0 0 20px #38b6ff;
            z-index: 20;
            transform: translate(-50%, -50%) scale(0.8);
            opacity: 0;
            pointer-events: none;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .controls.visible {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: auto;
        }
        #closeInstructionsBtn {
            position: absolute;
            top: 10px;
            left: 10px; /* Adjusted for RTL */
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 15;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>

    <button id="instructionsBtn">?</button>
    <div id="overlay" class="hidden"></div>

    <div id="controlsPanel" class="controls">
        <button id="closeInstructionsBtn">X</button>
        <h2>הוראות:</h2>
        <p><strong>תנועה:</strong> מקשי החצים</p>
        <p><strong>ירי:</strong> מקש הרווח</p>
        <p><strong>שדרוגים:</strong> הגע לקצה העליון של המסך!</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const instructionsBtn = document.getElementById('instructionsBtn');
        const closeInstructionsBtn = document.getElementById('closeInstructionsBtn');
        const controlsPanel = document.getElementById('controlsPanel');
        const overlay = document.getElementById('overlay');

        let canvasWidth = window.innerWidth * 0.8;
        let canvasHeight = window.innerHeight * 0.8;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        window.addEventListener('resize', () => {
            canvasWidth = window.innerWidth * 0.8;
            canvasHeight = window.innerHeight * 0.8;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            resetGame();
        });
        
        // --- Game States & Settings ---
        let gameState = 'startScreen'; // 'startScreen', 'playing', 'gameOver'
        let score = 0;
        let gameOver = false;
        let gameWon = false;
        let isPaused = false;
        let level = 1;
        let levelUpMessage = '';
        let levelUpMessageTimer = 0;
        let keys = {};
        
        let bullets = [];
        let enemyBullets = [];
        let stars = [];
        let particles = []; 
        let player = {};
        let enemy = {};
        let lastTime = 0;
        
        // --- DRONE SPECIFICATIONS (USED BY COMMANDER) ---
        const droneSpecs = {
            Fighter: {
                width: 15, height: 15, speed: 200, // מהיר, משוטט חופשי
                targetCooldown: 3000, // משנה מטרה כל 3 שניות
                draw: function() {
                     ctx.fillStyle = '#ffd700'; // Gold/Yellow (Fighter)
                     ctx.strokeStyle = '#ffc800';
                     ctx.lineWidth = 1;
                     ctx.beginPath();
                     ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                     ctx.fill();
                     ctx.stroke();
                }
            },
            Defender: {
                width: 20, height: 20, speed: 100, // איטי, נשאר קרוב למפקד
                targetCooldown: 5000, // משנה מטרה כל 5 שניות
                draw: function() {
                     ctx.fillStyle = '#38b6ff'; // Blue/Cyan (Defender)
                     ctx.strokeStyle = '#00f2ff';
                     ctx.lineWidth = 2;
                     ctx.beginPath();
                     ctx.rect(this.x, this.y, this.width, this.height);
                     ctx.fill();
                     ctx.stroke();
                }
            }
        };

        // --- Helper Function for Wingman Spawning (Used by Commander) ---
        function spawnNewWingman() {
            if (player.shipType !== 'commander' || player.wingmen.length >= player.maxWingmen) return;

            // Randomly pick a drone type
            const types = Object.keys(droneSpecs);
            const droneTypeKey = types[Math.floor(Math.random() * types.length)];
            const spec = droneSpecs[droneTypeKey];

            // Initial random target for the drone in the middle top section
            const newTargetX = Math.random() * canvas.width;
            const newTargetY = canvas.height * 0.1 + Math.random() * (canvas.height * 0.4); 

            player.wingmen.push({ 
                x: player.x + (Math.random() - 0.5) * 50, 
                y: player.y + (Math.random() - 0.5) * 50, 
                width: spec.width, 
                height: spec.height, 
                draw: spec.draw,
                droneType: droneTypeKey, 
                speed: spec.speed, 
                targetX: newTargetX, 
                targetY: newTargetY, 
                vx: 0, 
                vy: 0, 
                targetTimer: 0, 
                targetCooldown: spec.targetCooldown
            });
        }

        // --- Ship Definitions ---
        const shipTypes = {
            // --- SHIP 1: COMMANDER (מפקד) ---
            commander: {
                width: 70, height: 50, speed: 380, // slightly bigger, slightly slower
                wingmanCooldown: 5000, // Initial 5 seconds until first spawn
                maxWingmen: 1, // Max 1 wingman initially
                droneFireCooldown: 700, // Autonomous firing cooldown (ms)
                draw: function() {
                    // Commander aesthetics: boxy, yellow/gold accents
                    ctx.fillStyle = '#ffc800'; ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height * 0.5);
                    ctx.lineTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x + this.width, this.y + this.height * 0.5);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.lineTo(this.x, this.y + this.height);
                    ctx.closePath(); ctx.fill();
                    
                    let cockpitColor = '#111';
                    if (this.timesUpgraded === 1) cockpitColor = '#38b6ff';
                    if (this.timesUpgraded >= 2) cockpitColor = '#00ff7f';
                    ctx.fillStyle = cockpitColor; ctx.strokeStyle = '#ffc800'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.rect(this.x + this.width / 2 - 10, this.y + 10, 20, 20);
                    ctx.fill(); ctx.stroke();
                    
                    // Engine
                    ctx.fillStyle = Math.random() < 0.5 ? '#ffdd00' : '#ff9900'; ctx.beginPath();
                    ctx.rect(this.x + 5, this.y + this.height, this.width - 10, 8 + Math.random() * 8);
                    ctx.fill();
                    
                    this.wingmen.forEach(wingman => wingman.draw());
                },
                shoot: function() {
                    // Commander fires only its main shot (drones shoot autonomously)
                    if (bullets.length < 5) {
                        bullets.push({ x: this.x + this.width / 2 - 2.5, y: this.y, width: 5, height: 15, speed: 600, type: 'bullet' });
                    }
                },
                applyUpgrade: function() {
                    this.timesUpgraded++;
                    if (this.timesUpgraded === 1) {
                         this.wingmanCooldown = 2500; // Faster spawn (from 5s to 2.5s)
                         this.droneFireCooldown = 500; // Faster drone firing
                    }
                    if (this.timesUpgraded === 2) {
                        this.maxWingmen = 3; // Max 3 drones
                        this.droneFireCooldown = 350; // Even faster drone firing
                    }
                    this.y = canvas.height - 70;
                }
            },
            // --- SHIP 2: GUARDIAN (שומר) ---
            guardian: {
                width: 60, height: 50, speed: 300, // px per second
                draw: function() {
                    ctx.fillStyle = '#f0f0f0'; ctx.beginPath(); // Main body
                    ctx.moveTo(this.x, this.y + this.height * 0.2); ctx.lineTo(this.x + this.width, this.y + this.height * 0.2);
                    ctx.lineTo(this.x + this.width * 0.8, this.y + this.height); ctx.lineTo(this.x + this.width * 0.2, this.y + this.height);
                    ctx.closePath(); ctx.fill();
                    let cockpitColor = '#111';
                    if (this.timesUpgraded === 1) cockpitColor = '#ffd700';
                    if (this.timesUpgraded >= 2) cockpitColor = '#00ff7f';
                    ctx.fillStyle = cockpitColor; ctx.strokeStyle = '#ff8c00'; ctx.lineWidth = 2; // Cockpit
                    ctx.fillRect(this.x + this.width / 2 - 10, this.y, 20, 10); ctx.strokeRect(this.x + this.width / 2 - 10, this.y, 20, 10);
                    ctx.fillStyle = Math.random() < 0.5 ? '#ff8c00' : '#ff4500'; ctx.beginPath(); // Engine
                    ctx.rect(this.x + this.width * 0.3, this.y + this.height, this.width*0.4, 10 + Math.random() * 5); ctx.fill();

                    if(this.shield.active){
                        ctx.beginPath();
                        ctx.arc(this.x + this.width/2, this.y + this.height/2, this.shield.radius, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 140, 0, ${0.2 + Math.random() * 0.1})`;
                        ctx.fill();
                        ctx.strokeStyle = `rgba(255, 140, 0, 0.8)`;
                        ctx.stroke();
                    }
                },
                shoot: function() {
                    if (bullets.length > 8) return;
                    for (let i = 0; i < this.pelletCount; i++) {
                        bullets.push({
                            x: this.x + this.width / 2, y: this.y, width: 6, height: 6, speed: 720, type: 'pellet',
                            dx: (Math.random() - 0.5) * this.spread, dy: -1, life: 350 // Nerfed range further
                        });
                    }
                },
                applyUpgrade: function() {
                    this.timesUpgraded++;
                    if (this.timesUpgraded === 1) this.pelletCount += 1; // Nerfed upgrade from +2 to +1
                    if (this.timesUpgraded === 2) this.shield.active = true;
                    this.y = canvas.height - 70;
                }
            },
            // --- SHIP 3: INTERCEPTOR (מיירט) ---
            interceptor: {
                width: 50, height: 60, speed: 420, // px per second
                draw: function() {
                    // Blue Interceptor aesthetics (classic fighter)
                    ctx.fillStyle = '#00f2ff'; ctx.beginPath();
                    ctx.moveTo(this.x + this.width / 2, this.y);
                    ctx.lineTo(this.x, this.y + this.height * 0.8);
                    ctx.lineTo(this.x + this.width, this.y + this.height * 0.8);
                    ctx.closePath(); ctx.fill();
                    let cockpitColor = '#111';
                    if (this.timesUpgraded === 1) cockpitColor = '#ffd700';
                    if (this.timesUpgraded >= 2) cockpitColor = '#00ff7f';
                    ctx.fillStyle = cockpitColor; ctx.strokeStyle = '#38b6ff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height * 0.4, 8, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                    ctx.fillStyle = Math.random() < 0.5 ? '#ffdd00' : '#ff9900'; ctx.beginPath();
                    ctx.moveTo(this.x + this.width * 0.3, this.y + this.height * 0.8);
                    ctx.lineTo(this.x + this.width * 0.7, this.y + this.height * 0.8);
                    ctx.lineTo(this.x + this.width / 2, this.y + this.height + Math.random() * 15);
                    ctx.closePath(); ctx.fill();
                    this.wingmen.forEach(wingman => wingman.draw());
                },
                shoot: function() {
                    if (this.hasDoubleShot) {
                        if (bullets.length < 10) {
                            bullets.push({ x: this.x + this.width * 0.2, y: this.y, width: 5, height: 15, speed: 600, type: 'bullet' });
                            bullets.push({ x: this.x + this.width * 0.8 - 5, y: this.y, width: 5, height: 15, speed: 600, type: 'bullet' });
                        }
                    } else {
                        if (bullets.length < 5) {
                            bullets.push({ x: this.x + this.width / 2 - 2.5, y: this.y, width: 5, height: 15, speed: 600, type: 'bullet' });
                        }
                    }
                    this.wingmen.forEach(wingman => {
                        if (bullets.length < 12) {
                             bullets.push({ x: wingman.x + wingman.width / 2 - 2.5, y: wingman.y, width: 4, height: 12, speed: 600, type: 'bullet' });
                        }
                    });
                },
                createWingmen: function() {
                     if (this.wingmen.length > 0) return;
                     const wingmanDraw = function() {
                         ctx.fillStyle = '#38b6ff'; 
                         ctx.beginPath();
                         ctx.moveTo(this.x + this.width / 2, this.y);
                         ctx.lineTo(this.x, this.y + this.height);
                         ctx.lineTo(this.x + this.width, this.y + this.height);
                         ctx.closePath(); ctx.fill();
                     };
                     this.wingmen.push({ x: 0, y: 0, width: 20, height: 20, draw: wingmanDraw });
                     this.wingmen.push({ x: 0, y: 0, width: 20, height: 20, draw: wingmanDraw });
                },
                applyUpgrade: function() {
                    this.timesUpgraded++;
                    if (this.timesUpgraded === 1) this.hasDoubleShot = true;
                    if (this.timesUpgraded === 2) this.createWingmen();
                    this.y = canvas.height - 70;
                }
            },
            // --- SHIP 4: VANGUARD (חלוץ) ---
            vanguard: {
                width: 80, height: 70, speed: 250, // Slow and heavy
                spreadFactor: 10, // Initial horizontal offset for shots
                draw: function() {
                    ctx.fillStyle = '#8a2be2'; // Deep violet/purple
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + 40);
                    ctx.lineTo(this.x + 20, this.y);
                    ctx.lineTo(this.x + this.width - 20, this.y);
                    ctx.lineTo(this.x + this.width, this.y + 40);
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.lineTo(this.x, this.y + this.height);
                    ctx.closePath(); ctx.fill();

                    // Cockpit/Core
                    let coreColor = '#111';
                    if (this.timesUpgraded === 1) coreColor = '#ffffff';
                    if (this.timesUpgraded >= 2) coreColor = '#ff66ff'; // Pink/Magenta for quad shot
                    ctx.fillStyle = coreColor; ctx.strokeStyle = '#c8a2c8'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.rect(this.x + this.width / 2 - 15, this.y + 20, 30, 15);
                    ctx.fill(); ctx.stroke();

                    // Engines
                    ctx.fillStyle = Math.random() < 0.5 ? '#ff66ff' : '#cc33cc';
                    ctx.fillRect(this.x + 10, this.y + this.height, 15, 10 + Math.random() * 8);
                    ctx.fillRect(this.x + this.width - 25, this.y + this.height, 15, 10 + Math.random() * 8);
                },
                shoot: function() {
                    if (bullets.length < 10) {
                        const base_y = this.y - 10;
                        const base_speed = 500;
                        
                        // Center shot
                        bullets.push({ x: this.x + this.width / 2 - 2, y: base_y, width: 4, height: 20, speed: base_speed, type: 'bullet' });

                        // Spread shots (left and right)
                        bullets.push({ x: this.x + this.width / 2 - this.spreadFactor - 2, y: base_y, width: 4, height: 20, speed: base_speed, type: 'bullet' });
                        bullets.push({ x: this.x + this.width / 2 + this.spreadFactor - 2, y: base_y, width: 4, height: 20, speed: base_speed, type: 'bullet' });

                        if (this.timesUpgraded >= 2) {
                            // Quad/Side shots (U2)
                            bullets.push({ x: this.x + this.width / 2 - this.spreadFactor * 2 - 2, y: base_y, width: 4, height: 20, speed: base_speed, type: 'bullet' });
                            bullets.push({ x: this.x + this.width / 2 + this.spreadFactor * 2 - 2, y: base_y, width: 4, height: 20, speed: base_speed, type: 'bullet' });
                        }
                    }
                },
                applyUpgrade: function() {
                    this.timesUpgraded++;
                    if (this.timesUpgraded === 1) {
                        this.spreadFactor = 20; // Wider spread for U1
                    }
                    if (this.timesUpgraded === 2) {
                        // U2 adds side cannons (quad shot in shoot function)
                        this.spreadFactor = 15; // Re-adjust spread for quad fire pattern
                    }
                    this.y = canvas.height - 70;
                }
            }
        };
        
        // --- Helper Function for Wingman Spawning (Used by Commander) ---
        function spawnNewWingman() {
            if (player.shipType !== 'commander' || player.wingmen.length >= player.maxWingmen) return;

            // Randomly pick a drone type
            const types = Object.keys(droneSpecs);
            const droneTypeKey = types[Math.floor(Math.random() * types.length)];
            const spec = droneSpecs[droneTypeKey];

            // Initial random target for the drone in the middle top section
            const newTargetX = Math.random() * canvas.width;
            const newTargetY = canvas.height * 0.1 + Math.random() * (canvas.height * 0.4); 

            player.wingmen.push({ 
                x: player.x + (Math.random() - 0.5) * 50, 
                y: player.y + (Math.random() - 0.5) * 50, 
                width: spec.width, 
                height: spec.height, 
                draw: spec.draw,
                droneType: droneTypeKey, 
                speed: spec.speed, 
                targetX: newTargetX, 
                targetY: newTargetY, 
                vx: 0, 
                vy: 0, 
                targetTimer: 0, 
                targetCooldown: spec.targetCooldown
            });
        }

        // --- Enemy Definitions ---
        const enemyTypes = [
            { 
                width: 50, height: 50, baseSpeed: 240, bulletSpeed: 400, fireCooldown: 800, // ms
                movementPatterns: ['linear', 'zigzag', 'ellipse'],
                draw: function() { ctx.fillStyle = '#ff4141'; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2, this.y + this.height); ctx.lineTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.y); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#cc2a2a'; ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x - 15, this.y + 10); ctx.lineTo(this.x, this.y + 20); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width + 15, this.y + 10); ctx.lineTo(this.x + this.width, this.y + 20); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#111'; ctx.strokeStyle = '#ff8888'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height * 0.6, 8, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
            },
            { 
                width: 60, height: 60, baseSpeed: 360, bulletSpeed: 500, fireCooldown: 500, wingmen: [], 
                movementPatterns: ['linear', 'zigzag', 'ellipse'],
                draw: function() { ctx.fillStyle = '#c837ff'; ctx.beginPath(); ctx.moveTo(this.x, this.y + 20); ctx.lineTo(this.x + this.width / 2, this.y); ctx.lineTo(this.x + this.width, this.y + 20); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.lineTo(this.x, this.y + this.height); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#9d00e0'; ctx.fillRect(this.x + 10, this.y + this.height, 10, 10); ctx.fillRect(this.x + this.width - 20, this.y + this.height, 10, 10); ctx.fillStyle = '#111'; ctx.strokeStyle = '#f0a0ff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(this.x + this.width / 2 - 10, this.y + 25); ctx.lineTo(this.x + this.width / 2 + 10, this.y + 25); ctx.lineTo(this.x + this.width / 2, this.y + 15); ctx.closePath(); ctx.fill(); ctx.stroke(); this.wingmen.forEach(wingman => wingman.draw()); }
            },
            { 
                width: 100, height: 80, baseSpeed: 120, bulletSpeed: 550, fireCooldown: 600, wingmen: [], 
                movementPatterns: ['linear'], maxLaserCharge: 2000, maxLaserDuration: 3000, // ms
                draw: function() { ctx.fillStyle = '#b30000'; ctx.beginPath(); ctx.moveTo(this.x, this.y + 20); ctx.lineTo(this.x + this.width / 2, this.y); ctx.lineTo(this.x + this.width, this.y + 20); ctx.lineTo(this.x + this.width - 20, this.y + this.height); ctx.lineTo(this.x + 20, this.y + this.height); ctx.closePath(); ctx.fill(); ctx.fillStyle = '#660000'; ctx.fillRect(this.x + this.width / 2 - 10, this.y + this.height, 20, 10); ctx.fillStyle = '#ff5555'; ctx.strokeStyle = '#ffcccc'; ctx.lineWidth = 2; ctx.beginPath(); ctx.rect(this.x + this.width / 2 - 25, this.y + 10, 50, 20); ctx.fill(); ctx.stroke(); if (this.isCharging) { const chargeRatio = this.laserCharge / this.maxLaserCharge; ctx.fillStyle = `rgba(255, 100, 100, ${chargeRatio})`; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height, 15 * chargeRatio, 0, Math.PI * 2); ctx.fill(); } if (this.isFiringLaser) { const laserWidth = 20; const grad = ctx.createLinearGradient(0, this.y + this.height, 0, canvas.height); grad.addColorStop(0, `rgba(255, 0, 0, ${0.5 + Math.random() * 0.5})`); grad.addColorStop(0.5, `rgba(255, 100, 100, ${0.5 + Math.random() * 0.5})`); grad.addColorStop(1, 'rgba(255, 200, 200, 0)'); ctx.fillStyle = grad; ctx.fillRect(this.x + this.width / 2 - laserWidth / 2, this.y + this.height, laserWidth, canvas.height); } }
            }
        ];

        function initPlayer(shipType) {
            const template = shipTypes[shipType];
            player = {
                ...template,
                shipType: shipType, // Added shipType for logic checks
                x: canvas.width / 2 - template.width / 2,
                y: canvas.height - 70,
                dx: 0, dy: 0,
                timesUpgraded: 0,
            };
            if (shipType === 'commander') {
                player.wingmen = [];
                player.wingmanTimer = player.wingmanCooldown; // Start cooldown for spawning
                player.droneFireTimer = 0; // Fire timer for autonomous shooting
                player.droneFireCooldown = template.droneFireCooldown; // Cooldown value
            }
            if (shipType === 'guardian') {
                player.pelletCount = 4;
                player.spread = 1.0;
                player.shield = { active: false, radius: 40 };
            }
            if (shipType === 'interceptor') { 
                player.hasDoubleShot = false;
                player.wingmen = [];
            }
            if (shipType === 'vanguard') { 
                player.spreadFactor = template.spreadFactor;
            }
        }

        function drawStartScreen() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars();
            
            ctx.textAlign = 'center';
            ctx.fillStyle = 'white';
            ctx.font = '50px Arial';
            ctx.fillText('בחר את החללית שלך', canvas.width / 2, canvas.height * 0.15); // Title higher up

            // --- 2x2 Layout Calculations ---
            const boxWidth = 180; 
            const boxHeight = 200; 
            const offset = 30; // Spacing between boxes

            // Calculate overall grid dimensions
            const gridWidth = boxWidth * 2 + offset;
            const gridHeight = boxHeight * 2 + offset;

            // Calculate starting point for centering the 2x2 grid
            const startX = (canvas.width / 2) - (gridWidth / 2);
            const startY = (canvas.height / 2) - (gridHeight / 2);

            // Define coordinates for the 4 boxes
            const row1Y = startY;
            const row2Y = startY + boxHeight + offset;

            const col1X = startX;
            const col2X = startX + boxWidth + offset;

            const box1X = col1X; const box1Y = row1Y; // Commander (Top Left)
            const box2X = col2X; const box2Y = row1Y; // Guardian (Top Right)
            const box3X = col1X; const box3Y = row2Y; // Interceptor (Bottom Left)
            const box4X = col2X; const box4Y = row2Y; // Vanguard (Bottom Right)
            
            // --- Ship 1: COMMANDER (Top Left) ---
            ctx.strokeStyle = '#ffc800'; // Gold border
            ctx.strokeRect(box1X, box1Y, boxWidth, boxHeight);
            shipTypes.commander.draw.call({ x: box1X + (boxWidth-70) / 2, y: box1Y + 50, width: 70, height: 50, timesUpgraded: 0, wingmen: [] });
            ctx.font = '24px Arial';
            ctx.fillText('"מפקד"', box1X + boxWidth/2, box1Y + 160);
            ctx.font = '16px Arial';
            ctx.fillText('שולח מל"טים', box1X + boxWidth/2, box1Y + 185);

            // --- Ship 2: Guardian (Top Right) ---
            ctx.strokeStyle = '#ff8c00';
            ctx.strokeRect(box2X, box2Y, boxWidth, boxHeight);
            shipTypes.guardian.draw.call({ x: box2X + (boxWidth-60) / 2, y: box2Y + 60, width: 60, height: 50, timesUpgraded: 0, shield: {active: false} });
            ctx.font = '24px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText('"שומר"', box2X + boxWidth/2, box2Y + 160);
            ctx.font = '16px Arial';
            ctx.fillText('חזק ומוגן', box2X + boxWidth/2, box2Y + 185);
            
            // --- Ship 3: INTERCEPTOR (Bottom Left) ---
            ctx.strokeStyle = '#38b6ff';
            ctx.strokeRect(box3X, box3Y, boxWidth, boxHeight);
            shipTypes.interceptor.draw.call({ x: box3X + (boxWidth-50) / 2, y: box3Y + 50, width: 50, height: 60, timesUpgraded: 0, wingmen: [] }); 
            ctx.font = '24px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText('"מיירט"', box3X + boxWidth/2, box3Y + 160);
            ctx.font = '16px Arial';
            ctx.fillText('מהיר וקטלני', box3X + boxWidth/2, box3Y + 185);

            // --- Ship 4: VANGUARD (Bottom Right) ---
            ctx.strokeStyle = '#8a2be2'; // Violet border
            ctx.strokeRect(box4X, box4Y, boxWidth, boxHeight);
            shipTypes.vanguard.draw.call({ x: box4X + (boxWidth-80) / 2, y: box4Y + 45, width: 80, height: 70, timesUpgraded: 0 }); 
            ctx.font = '24px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText('"חלוץ"', box4X + boxWidth/2, box4Y + 160);
            ctx.font = '16px Arial';
            ctx.fillText('ירי מפוצל כבד', box4X + boxWidth/2, box4Y + 185);
        }

        function startGame(shipType) {
            initPlayer(shipType);
            gameOver = false; gameWon = false; score = 0; level = 1;
            setupEnemyForLevel(level);
            bullets = []; enemyBullets = []; particles = [];
            createStars();
            gameState = 'playing';
            // lastTime = 0; // Removing this fixes the time jump bug on restart
            requestAnimationFrame(mainLoop);
        }

        canvas.addEventListener('click', (e) => {
            if (gameState !== 'startScreen') return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const boxWidth = 180; 
            const boxHeight = 200; 
            const offset = 30;

            const gridWidth = boxWidth * 2 + offset;
            const gridHeight = boxHeight * 2 + offset;
            const startX = (canvas.width / 2) - (gridWidth / 2);
            const startY = (canvas.height / 2) - (gridHeight / 2);

            const row1Y = startY;
            const row2Y = startY + boxHeight + offset;

            const col1X = startX;
            const col2X = startX + boxWidth + offset;
            
            // Check if click is within the grid vertically and horizontally
            if (x > startX && x < startX + gridWidth && y > startY && y < startY + gridHeight) { 
                
                // Row 1 check (Commander & Guardian)
                if (y >= row1Y && y < row1Y + boxHeight) {
                    if (x >= col1X && x < col1X + boxWidth) {
                        startGame('commander'); // Top Left
                    } else if (x >= col2X && x < col2X + boxWidth) {
                        startGame('guardian'); // Top Right
                    }
                } 
                // Row 2 check (Interceptor & Vanguard)
                else if (y >= row2Y && y < row2Y + boxHeight) { 
                    if (x >= col1X && x < col1X + boxWidth) {
                        startGame('interceptor'); // Bottom Left
                    } else if (x >= col2X && x < col2X + boxWidth) {
                        startGame('vanguard'); // Bottom Right
                    }
                }
            }
        });

        // --- Core Game Functions ---
        function setupEnemyForLevel(level) {
            const type = enemyTypes[level - 1];
            const pattern = type.movementPatterns[Math.floor(Math.random() * type.movementPatterns.length)];
            
            enemy = {
                ...type,
                x: canvas.width / 2 - type.width / 2,
                y: 30,
                speed: type.baseSpeed,
                movementPattern: pattern,
                angle: 0,
                dy: 120, // px per second
                laserCharge: 0, laserDuration: 0,
                isCharging: false, isFiringLaser: false,
                fireTimer: type.fireCooldown,
            };

            if (pattern === 'ellipse') {
                enemy.centerX = canvas.width / 2;
                enemy.centerY = 120;
                enemy.radiusX = canvas.width / 4;
                enemy.radiusY = 60;
            }

            if (level === 2) { createEnemyWingmen(); }
        }

        function createStars() {
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.5, alpha: Math.random() });
            }
        }
        function drawStars() {
            stars.forEach(star => {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.alpha})`;
                ctx.fill();
                star.alpha += (Math.random() - 0.5) * 0.1;
                if (star.alpha > 1) star.alpha = 1; if (star.alpha < 0.1) star.alpha = 0.1;
            });
        }

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space' && gameState === 'playing' && !isPaused) {
                // All ships fire the main shot on keydown
                player.shoot();
            }
            if (e.code === 'Enter' && gameState === 'gameOver') resetGame();
        });
        document.addEventListener('keyup', (e) => { 
            keys[e.code] = false; 
        });
        
        function enemyShoot() {
             if (enemyBullets.length < 3) {
                enemyBullets.push({ x: enemy.x + enemy.width / 2 - 3, y: enemy.y + enemy.height, width: 6, height: 18, speed: enemy.bulletSpeed });
             }
        }
        function createExplosion(x, y, color) {
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 300, vy: (Math.random() - 0.5) * 300,
                    life: 700, // ms
                    color: color, size: Math.random() * 3 + 1
                });
            }
        }
        function handleParticles(deltaTime) {
            const dt = deltaTime / 1000;
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.life -= deltaTime;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.globalAlpha = p.life / 700; // Fade out effect
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fillStyle = p.color;
                    ctx.fill();
                    ctx.globalAlpha = 1.0; // Reset alpha
                }
            }
        }

        function updatePlayerPosition(deltaTime) {
            const dt = deltaTime / 1000;
            player.dx = 0; player.dy = 0;
            if (keys['ArrowRight'] || keys['KeyD']) player.dx = player.speed;
            if (keys['ArrowLeft'] || keys['KeyA']) player.dx = -player.speed;
            if (keys['ArrowUp'] || keys['KeyW']) player.dy = -player.speed;
            if (keys['ArrowDown'] || keys['KeyS']) player.dy = player.speed;
            
            player.x += player.dx * dt;
            player.y += player.dy * dt;

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
            
            if (player.y < 0) {
                player.applyUpgrade();
            }
            if (player.y + player.height > canvas.height) player.y = canvas.height - player.height;
            
            // --- Commander Ship Wingman Spawning & Autonomous Firing Logic ---
            if (player.shipType === 'commander') {
                // 1. Spawning Logic
                player.wingmanTimer -= deltaTime;
                
                if (player.wingmanTimer <= 0) {
                    // Check if we can spawn a new wingman
                    if (player.wingmen.length < player.maxWingmen) {
                        spawnNewWingman();
                    }
                    player.wingmanTimer = player.wingmanCooldown; // Reset timer regardless of spawn success
                }

                // 2. Autonomous Firing Logic
                if (player.wingmen.length > 0) {
                    player.droneFireTimer -= deltaTime;
                    if (player.droneFireTimer <= 0) {
                        player.wingmen.forEach(wingman => {
                            // Wingmen shoot autonomously (basic shot)
                            bullets.push({ x: wingman.x + wingman.width / 2 - 2, y: wingman.y, width: 4, height: 12, speed: 600, type: 'bullet' });
                        });
                        player.droneFireTimer = player.droneFireCooldown;
                    }
                }
            }

            // --- Update Wingmen Position: Free Roaming AI ---
            if (player.shipType === 'commander' && player.wingmen) {
                player.wingmen.forEach((wingman, index) => {
                    const dt = deltaTime / 1000;
                    
                    const distanceToTarget = Math.hypot(wingman.targetX - wingman.x, wingman.targetY - wingman.y);
                    wingman.targetTimer += deltaTime;

                    // 1. Check if target is reached or timer expired (Drone AI)
                    if (distanceToTarget < 10 || wingman.targetTimer > wingman.targetCooldown) {
                        wingman.targetTimer = 0;
                        
                        let targetAreaX, targetAreaY;

                        if (wingman.droneType === 'Fighter') {
                            // Fighter: Roams the top half of the screen
                            targetAreaX = Math.random() * canvas.width;
                            targetAreaY = canvas.height * 0.1 + Math.random() * (canvas.height * 0.5); 
                        } else {
                            // Defender: Stays closer to the player
                            const maxOffset = 100;
                            targetAreaX = player.x + player.width / 2 + (Math.random() - 0.5) * maxOffset;
                            targetAreaY = player.y + player.height / 2 + (Math.random() - 0.5) * maxOffset;
                            
                            // Ensure Defender target is within screen bounds
                            targetAreaX = Math.max(wingman.width / 2, Math.min(canvas.width - wingman.width / 2, targetAreaX));
                            targetAreaY = Math.max(canvas.height / 2, Math.min(canvas.height - wingman.height / 2, targetAreaY));
                        }
                        
                        wingman.targetX = targetAreaX - wingman.width / 2;
                        wingman.targetY = targetAreaY - wingman.height / 2;

                        // Recalculate velocity vector towards new target
                        const angle = Math.atan2(wingman.targetY - wingman.y, wingman.targetX - wingman.x);
                        wingman.vx = Math.cos(angle) * wingman.speed;
                        wingman.vy = Math.sin(angle) * wingman.speed;
                    }

                    // 2. Update position based on velocity
                    wingman.x += wingman.vx * dt;
                    wingman.y += wingman.vy * dt;

                    // Keep drones within bounds
                    if (wingman.x < 0) { wingman.x = 0; wingman.targetTimer = wingman.targetCooldown; }
                    if (wingman.x + wingman.width > canvas.width) { wingman.x = canvas.width - wingman.width; wingman.targetTimer = wingman.targetCooldown; }
                    if (wingman.y < 0) { wingman.y = 0; wingman.targetTimer = wingman.targetCooldown; }
                    if (wingman.y + wingman.height > canvas.height) { wingman.y = canvas.height - wingman.height; wingman.targetTimer = wingman.targetCooldown; }

                });
            } else if (player.shipType === 'interceptor' && player.wingmen) {
                // INTERCEPTOR: Fixed formation logic (kept for the other ship)
                player.wingmen.forEach((wingman, index) => {
                    const offset = (index === 0 ? -1 : 1) * (player.width + 10);
                    wingman.x = player.x + player.width / 2 + offset - wingman.width / 2;
                    wingman.y = player.y + 20;
                });
            }
        }
        
        // This function is no longer needed globally as it is now defined inside shipTypes.interceptor
        function createWingmen() {}

        function createEnemyWingmen() {
            enemy.wingmen = [];
            const wingmanDraw = function() {
                ctx.fillStyle = '#c837ff'; ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y + this.height);
                ctx.lineTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.y);
                ctx.closePath(); ctx.fill();
            };
            enemy.wingmen.push({ x: 0, y: 0, width: 25, height: 25, draw: wingmanDraw });
            enemy.wingmen.push({ x: 0, y: 0, width: 25, height: 25, draw: wingmanDraw });
        }
        
        function updateEnemyMovement(deltaTime) {
            const dt = deltaTime / 1000;
            switch (enemy.movementPattern) {
                case 'linear':
                case 'zigzag':
                    enemy.x += enemy.speed * dt;
                    if (enemy.movementPattern === 'zigzag') {
                        enemy.y += enemy.dy * dt;
                        // Vertical bounce for zigzag
                        if (enemy.y <= 20) {
                            enemy.y = 20;
                            enemy.dy *= -1;
                        } else if (enemy.y + enemy.height >= 200) {
                            enemy.y = 200 - enemy.height;
                            enemy.dy *= -1;
                        }
                    }
                    // Horizontal wrap-around for both linear and zigzag
                    if (enemy.x > canvas.width) {
                        enemy.x = 0 - enemy.width;
                    } else if (enemy.x + enemy.width < 0) {
                        enemy.x = canvas.width;
                    }
                    break;
                case 'ellipse':
                    enemy.angle += 1.2 * Math.sign(enemy.speed) * dt;
                    enemy.x = enemy.centerX + Math.cos(enemy.angle) * enemy.radiusX - enemy.width / 2;
                    enemy.y = enemy.centerY + Math.sin(enemy.angle) * enemy.radiusY - enemy.height / 2;
                    break;
            }
        }

        function updateEnemy(deltaTime) {
            const dt = deltaTime / 1000;
            updateEnemyMovement(deltaTime);

            enemy.fireTimer -= deltaTime;
            if (enemy.fireTimer <= 0 && !gameOver && !enemy.isFiringLaser && !enemy.isCharging) {
                enemyShoot();
                enemy.fireTimer = enemy.fireCooldown / (1 + (score % 10) * 0.05 * level); // Fire faster with score
            }

            if (level === 3) {
                if (!enemy.isCharging && !enemy.isFiringLaser && Math.random() < 0.01) {
                    enemy.isCharging = true;
                }
                if (enemy.isCharging) {
                    enemy.laserCharge += deltaTime;
                    if (enemy.laserCharge >= enemy.maxLaserCharge) {
                        enemy.isCharging = false;
                        enemy.isFiringLaser = true;
                        enemy.laserDuration = enemy.maxLaserDuration;
                    }
                }
                if (enemy.isFiringLaser) {
                    enemy.laserDuration -= deltaTime;
                    if (enemy.laserDuration <= 0) {
                        enemy.isFiringLaser = false;
                        enemy.laserCharge = 0;
                    }
                }
            }
            
            if (enemy.wingmen && enemy.wingmen.length > 0) { 
                enemy.wingmen.forEach((wingman, index) => {
                     const offset = (index === 0 ? -1 : 1) * (enemy.width / 2 + 20);
                     wingman.x = enemy.x + enemy.width / 2 + offset - wingman.width / 2;
                     wingman.y = enemy.y + 40;
                     if (Math.random() < 0.5 * dt) { 
                         enemyBullets.push({ x: wingman.x + wingman.width / 2 - 3, y: wingman.y + wingman.height, width: 5, height: 15, speed: enemy.bulletSpeed * 0.9 });
                     }
                });
            }
        }

        function handleBullets(deltaTime) {
            const dt = deltaTime / 1000;
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Update position first for all bullets
                if (bullet.type === 'pellet') {
                    bullet.x += bullet.dx * bullet.speed * dt;
                    bullet.y += bullet.dy * bullet.speed * dt;
                    bullet.life -= deltaTime;
                } else { // standard bullet
                    bullet.y -= bullet.speed * dt;
                }

                // Collision detection
                let bulletRemoved = false;
                if ( enemy && bullet.x < enemy.x + enemy.width && bullet.x + bullet.width > enemy.x &&
                    bullet.y < enemy.y + enemy.height && bullet.y + bullet.height > enemy.y ) {
                    
                    bullets.splice(i, 1);
                    bulletRemoved = true; 
                    
                    // Simple score increase
                    score += 1; 

                    if (score >= 50) {
                        gameWon = true; gameOver = true;
                        createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#ffd700');
                        continue; // Skip to next bullet
                    }

                    let enemyColor = '#ff4141';
                    if (level === 2) enemyColor = '#c837ff'; if (level === 3) enemyColor = '#b30000';
                    createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemyColor);

                    if (level === 1 && score >= 10) { startLevel(2); }
                    else if (level === 2 && score >= 25) { startLevel(3); }
                    else {
                        const currentLevel = level; const oldSpeedDirection = Math.sign(enemy.speed);
                        setupEnemyForLevel(currentLevel);
                        const baseSpeed = enemy.baseSpeed + (score % 10) * 3 * level;
                        enemy.speed = baseSpeed * oldSpeedDirection;
                        if (level === 2) { createEnemyWingmen(); }
                    }
                }
                
                if (!bulletRemoved && enemy && enemy.wingmen) {
                    for (let j = enemy.wingmen.length - 1; j >= 0; j--) {
                        const wingman = enemy.wingmen[j];
                        if ( bullet.x < wingman.x + wingman.width && bullet.x + bullet.width > wingman.x &&
                            bullet.y < wingman.y + wingman.height && bullet.y + bullet.height > wingman.y ) {
                            bullets.splice(i, 1); bulletRemoved = true; 
                            
                            score += 2; // Wingman gives double base score

                            createExplosion(wingman.x + wingman.width / 2, wingman.y + wingman.height / 2, '#c837ff');
                            enemy.wingmen.splice(j, 1); break;
                        }
                    }
                }

                // Remove off-screen or expired bullets
                if ((bullet.type === 'pellet' && bullet.life <= 0) || (bullet.type !== 'pellet' && bullet.y < 0)) {
                    if(!bulletRemoved) bullets.splice(i, 1);
                }
            }
        }
        
        // This new function only draws the bullets
        function drawBullets() {
            bullets.forEach(bullet => {
                let color = '#fff000';
                let shadowColor = '#fff000';
                
                if (bullet.type === 'pellet') {
                    ctx.fillStyle = '#ffaf4d';
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    return; // Stop here for pellet
                }

                ctx.fillStyle = color; 
                ctx.shadowColor = shadowColor; 
                ctx.shadowBlur = 10;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            ctx.shadowBlur = 0; // Reset shadow
        }

        function handleEnemyBullets(deltaTime) {
            const dt = deltaTime / 1000;
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.y += bullet.speed * dt;
                
                let bulletRemoved = false;

                if (player.shield && player.shield.active) {
                    const bulletCenterX = bullet.x + bullet.width / 2;
                    const bulletCenterY = bullet.y + bullet.height / 2;
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;
                    const dist = Math.hypot(bulletCenterX - playerCenterX, bulletCenterY - playerCenterY);
                    
                    if (dist < player.shield.radius) {
                        player.shield.active = false;
                        enemyBullets.splice(i, 1);
                        createExplosion(player.x + player.width/2, player.y + player.height/2, '#ff8c00');
                        continue;
                    }
                }

                if ( bullet.x < player.x + player.width && bullet.x + bullet.width > player.x &&
                    bullet.y < player.y + player.height && bullet.y + player.height > player.y ) {
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#00f2ff');
                    gameOver = true;
                    bulletRemoved = true; 
                    if (i < enemyBullets.length) enemyBullets.splice(i, 1);
                }
                
                if (!bulletRemoved && player.wingmen) {
                    for (let j = player.wingmen.length - 1; j >= 0; j--) {
                        const wingman = player.wingmen[j];
                        // Check collision with Commander drones
                        if (player.shipType === 'commander' && 
                            bullet.x < wingman.x + wingman.width && bullet.x + bullet.width > wingman.x &&
                            bullet.y < wingman.y + wingman.height && bullet.y + wingman.height > wingman.y ) {
                            enemyBullets.splice(i, 1);
                            bulletRemoved = true;
                            createExplosion(wingman.x + wingman.width / 2, wingman.y + wingman.height / 2, droneSpecs[wingman.droneType].draw.fillStyle);
                            player.wingmen.splice(j, 1);
                            break;
                        }
                         // Check collision with Interceptor wingmen
                        if (player.shipType === 'interceptor' && 
                            bullet.x < wingman.x + wingman.width && bullet.x + bullet.width > wingman.x &&
                            bullet.y < wingman.y + wingman.height && bullet.y + wingman.height > wingman.y ) {
                            enemyBullets.splice(i, 1);
                            bulletRemoved = true;
                            createExplosion(wingman.x + wingman.width / 2, wingman.y + wingman.height / 2, '#00f2ff');
                            player.wingmen.splice(j, 1);
                            break;
                        }
                    }
                }

                if (!bulletRemoved && bullet.y > canvas.height) {
                    enemyBullets.splice(i, 1);
                }
            }
        }
        
        // This new function only draws the bullets
        function drawBullets() {
            bullets.forEach(bullet => {
                let color = '#fff000';
                let shadowColor = '#fff000';
                
                if (bullet.type === 'pellet') {
                    ctx.fillStyle = '#ffaf4d';
                    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
                    return; // Stop here for pellet
                }

                ctx.fillStyle = color; 
                ctx.shadowColor = shadowColor; 
                ctx.shadowBlur = 10;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            ctx.shadowBlur = 0; // Reset shadow
        }

        function drawEnemyBullets() {
            enemyBullets.forEach(bullet => {
                ctx.fillStyle = '#ff00ff'; 
                ctx.shadowColor = '#ff00ff'; 
                ctx.shadowBlur = 10;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
            ctx.shadowBlur = 0; // Reset shadow
        }


        function checkCollision() {
            if (!enemy) return;

            if (player.shield && player.shield.active) {
                 const dist = Math.hypot((enemy.x + enemy.width/2) - (player.x + player.width/2), (enemy.y + enemy.height/2) - (player.y + player.height/2));
                 if (dist < player.shield.radius + enemy.width/2) {
                     player.shield.active = false;
                     score++;
                     createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, '#ff4141');
                     const currentLevel = level; const oldSpeedDirection = Math.sign(enemy.speed);
                     setupEnemyForLevel(currentLevel);
                     const baseSpeed = enemy.baseSpeed + (score % 10) * 3 * level;
                     enemy.speed = baseSpeed * oldSpeedDirection;
                     return;
                 }
            }
            
            if (player.x < enemy.x + enemy.width && player.x + player.width > enemy.x &&
                player.y < enemy.y + enemy.height && player.y + player.height > enemy.y) {
                createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#00f2ff');
                createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, level === 1 ? '#ff4141' : '#c837ff');
                gameOver = true; return;
            }
            if (enemy.wingmen) {
                for (const wingman of enemy.wingmen) {
                    if (player.x < wingman.x + wingman.width && player.x + player.width > wingman.x &&
                        player.y < wingman.y + wingman.height && player.y + player.height > wingman.y) {
                        createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#00f2ff');
                        createExplosion(wingman.x + wingman.width / 2, wingman.y + wingman.height / 2, '#c837ff');
                        gameOver = true; return;
                    }
                }
            }
            if (level === 3 && enemy.isFiringLaser) {
                const laserWidth = 20;
                const laserX = enemy.x + enemy.width / 2 - laserWidth / 2;
                if (player.x < laserX + laserWidth && player.x + player.width > laserX) {
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2, '#00f2ff');
                    gameOver = true; return;
                }
            }
        }
        
        function startLevel(newLevel) {
            level = newLevel;
            setupEnemyForLevel(level);
            levelUpMessage = `שלב ${level}!`;
            levelUpMessageTimer = 3000; // 3 seconds
        }
        function drawUI(deltaTime) {
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`ניקוד: ${score}`, canvas.width - 20, 40);
            ctx.textAlign = 'left';
            ctx.fillText(`שלב: ${level}`, 20, 40);
            if (player.shipType === 'commander' && player.wingmen) {
                ctx.font = '16px Arial';
                const fireText = player.wingmen.length >= player.maxWingmen ? '' : ` (טעינה: ${Math.max(0, (player.wingmanTimer / 1000).toFixed(1))}s)`;
                ctx.fillText(`מל"טים: ${player.wingmen.length} / ${player.maxWingmen}${fireText}`, 20, 70);
            }
            if (levelUpMessageTimer > 0) {
                ctx.font = '60px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 223, 0, ' + (levelUpMessageTimer / 3000) + ')';
                ctx.fillText(levelUpMessage, canvas.width / 2, canvas.height / 2);
                levelUpMessageTimer -= deltaTime;
            }
        }
        function showGameOver() {
            gameState = 'gameOver';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.textAlign = 'center';
            if (gameWon) {
                ctx.fillStyle = '#ffd700';
                ctx.font = '60px Arial';
                ctx.fillText('ניצחון!', canvas.width / 2, canvas.height / 2 - 40);
                ctx.font = '30px Arial';
                ctx.fillText(`כל הכבוד! השלמת את המשחק!`, canvas.width / 2, canvas.height / 2 + 20);
            } else {
                ctx.fillStyle = 'white';
                ctx.font = '50px Arial';
                ctx.fillText('המשחק נגמר!', canvas.width / 2, canvas.height / 2 - 40);
                ctx.font = '30px Arial';
                ctx.fillText(`ניקוד סופי: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            }
            ctx.font = '20px Arial';
            ctx.fillStyle = 'white';
            ctx.fillText('לחץ על Enter כדי להתחיל מחדש', canvas.width / 2, canvas.height / 2 + 70);
        }
        
        function resetGame() {
            gameState = 'startScreen';
            lastTime = 0; // Reset time only when going back to start screen
            requestAnimationFrame(mainLoop);
        }

        function mainLoop(timestamp = 0) {
            if (isPaused) {
                lastTime = timestamp; // Prevent time jump after unpausing
                requestAnimationFrame(mainLoop);
                return;
            }

            if (lastTime === 0) {
                lastTime = timestamp;
                requestAnimationFrame(mainLoop);
                return;
            }

            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            if (gameState === 'startScreen') {
                drawStartScreen();
                requestAnimationFrame(mainLoop);
            } else if (gameState === 'playing') {
                if (gameOver) {
                    showGameOver();
                    return; 
                }
                
                // --- UPDATE LOGIC ---
                updatePlayerPosition(deltaTime);
                updateEnemy(deltaTime);
                handleBullets(deltaTime);       
                handleEnemyBullets(deltaTime);  
                if (!gameOver) checkCollision();

                // --- DRAW LOGIC ---
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawStars();
                if (player.draw) player.draw();
                if (enemy.draw) enemy.draw();
                drawBullets(); // New draw call
                drawEnemyBullets(); // New draw call
                handleParticles(deltaTime);
                drawUI(deltaTime);

                requestAnimationFrame(mainLoop);
            } else if (gameState === 'gameOver') {
                showGameOver();
            }
        }
        
        // --- Event Listeners for Instructions ---
        instructionsBtn.addEventListener('click', () => {
            if (gameState !== 'playing') return;
            isPaused = true;
            controlsPanel.classList.add('visible');
            overlay.classList.remove('hidden');
        });

        closeInstructionsBtn.addEventListener('click', () => {
            isPaused = false;
            controlsPanel.classList.remove('visible');
            overlay.classList.add('hidden');
            requestAnimationFrame(mainLoop); // Resume game
        });
        
        // --- Initial Load ---
        resetGame();

    </script>
</body>
</html>
